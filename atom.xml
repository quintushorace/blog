<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浩子</title>
  
  <subtitle>学无止境</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-17T02:46:36.888Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Horace Zhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>adb 命令大全</title>
    <link href="http://yoursite.com/2019/01/17/adb-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://yoursite.com/2019/01/17/adb-命令大全/</id>
    <published>2019-01-17T02:25:04.000Z</published>
    <updated>2019-01-17T02:46:36.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="adb-命令大全"><a href="#adb-命令大全" class="headerlink" title="adb 命令大全"></a>adb 命令大全</h2><p>转自 <a href="https://blog.csdn.net/zhonglunshun/article/details/78362439" target="_blank" rel="noopener">https://blog.csdn.net/zhonglunshun/article/details/78362439</a></p><p> <strong>此文章内容整合自网络，欢迎转载。</strong></p><h2 id="ADB是什么"><a href="#ADB是什么" class="headerlink" title="ADB是什么"></a>ADB是什么</h2><hr><p> Adb的全称为Android Debug Bridge：android调试桥梁，下图为Android官方对adb的介绍：<br> <img src="http://upload-images.jianshu.io/upload_images/1888909-6b953b11bddfae15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"><br> 可以看出，Android的初衷是用adb这样的一个工具来协助开发人员在开发android应用的过程中更快更好的调试apk，因此adb具有安装卸载apk、拷贝推送文件、查看设备硬件信息、查看应用程序占用资源、在设备执行shell命令等功能；</p><p> 我们可以在android sdk安装目录的platform-tools目录下找到adb工具；</p><h2 id="ADB架构"><a href="#ADB架构" class="headerlink" title="ADB架构"></a>ADB架构</h2><hr><p> 为了方便理解，我们从三个指令入手，我们经常会用到adb start-server，adb devices,adb kill-server。<br> 然后我们经常会看到这样的输出界面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">* daemon not running. starting it now at tcp:5037 *</span><br><span class="line">* daemon started successfully *</span><br></pre></td></tr></table></figure><p> 于是这里有三点疑问，为什么是server，server对应的是服务器或者服务端吧？如果手机是客户端，服务端是不是指电脑上开启的服务。还有这个呆萌（daemon ）又是啥？</p><p> ADB是一个C/S架构的应用程序，由三部分组成：</p><ol start="2"><li>运行在pc端的adb client：<br> 命令行程序”adb”用于从shell或脚本中运行adb命令。首先，“adb”程序尝试定位主机上的ADB服务器，如果找不到ADB服务器，“adb”程序自动启动一个ADB服务器。接下来，当设备的adbd和pc端的adb server建立连接后，adb client就可以向ADB servcer发送服务请求；</li><li>运行在pc端的adb server：<br> ADB Server是运行在主机上的一个后台进程。它的作用在于检测USB端口感知设备的连接和拔除，以及模拟器实例的启动或停止，ADB Server还需要将adb client的请求通过usb或者tcp的方式发送到对应的adbd上；</li><li>运行在设备端的常驻进程adb demon (adbd)：<br> 程序“adbd”作为一个后台进程在Android设备或模拟器系统中运行。它的作用是连接ADB服务器，并且为运行在主机上的客户端提供一些服务；<br> <img src="http://upload-images.jianshu.io/upload_images/1888909-4d3f0bec471b5dfc.png?imageMogr2/auto-orient/strip" alt="这里写图片描述"><br> <img src="http://upload-images.jianshu.io/upload_images/1888909-2a4a68b3d96ee4b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述">  <h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2></li></ol><hr><p> adb能做什么?答案是所有能对手机的操作都能用adb实现。也就是说如果你玩的6，你就是触摸屏完全坏了，显示屏完全坏了，就只是给你一个主板，你照样能完成你要做的动作。当然在一般场景不推荐这样做，效率优先嘛。</p><p> 接下来的内容是转自github上一位大牛的<a href="https://github.com/mzlogin/awesome-adb" target="_blank" rel="noopener">博客</a>，如有侵权请告知，立即删除；<br> 后期</p><h3 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h3><p> adb 命令的基本语法如下：</p><blockquote><p>adb [-d|-e|-s ]</p><p> 如果只有一个设备/模拟器连接时，可以省略掉 [-d|-e|-s ] 这一部分，直接使用 adb 。</p></blockquote><h3 id="为命令指定目标设备"><a href="#为命令指定目标设备" class="headerlink" title="为命令指定目标设备"></a>为命令指定目标设备</h3><p> 如果有多个设备/模拟器连接，则需要为命令指定目标设备。</p><pre><code>参数                      | 含义                              ----------------------- | ---------------------------------d                      | 指定当前唯一通过 USB 连接的 Android 设备为命令目标-e                      | 指定当前唯一运行的模拟器为命令目标               -s &amp;lt;serialNumber&amp;gt; | 指定相应 serialNumber 号的设备/模拟器为命令目标</code></pre><p> 在多个设备/模拟器连接的情况下较常用的是 -s 参数，serialNumber 可以通过 adb devices 命令获取。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ adb devices</span><br><span class="line"></span><br><span class="line">List of devices attached</span><br><span class="line">cf264b8f    device</span><br><span class="line">emulator-5554   device</span><br><span class="line">10.129.164.6:5555   device</span><br></pre></td></tr></table></figure><p> 输出里的 cf264b8f、emulator-5554 和 10.129.164.6:5555 即为 serialNumber。</p><p> 比如这时想指定 cf264b8f 这个设备来运行 adb 命令获取屏幕分辨率：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb -s cf264b8f shell wm size</span><br></pre></td></tr></table></figure><p> 又如想给 10.129.164.6:5555 这个设备安装应用（这种形式的 serialNumber 格式为 :，一般为无线连接的设备或 Genymotion 等第三方 Android 模拟器）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb -s 10.129.164.6:5555 install test.apk</span><br></pre></td></tr></table></figure><p> <em>遇到多设备/模拟器的情况均使用这几个参数为命令指定目标设备，下文中为简化描述，不再重复。</em></p><h3 id="启动-停止"><a href="#启动-停止" class="headerlink" title="启动/停止"></a>启动/停止</h3><p> 启动 adb server 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb start-server</span><br></pre></td></tr></table></figure><p> （一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。）</p><p> 停止 adb server 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb kill-server</span><br></pre></td></tr></table></figure><h3 id="查看-adb-版本"><a href="#查看-adb-版本" class="headerlink" title="查看 adb 版本"></a>查看 adb 版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb version</span><br></pre></td></tr></table></figure><p> 示例输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Android Debug Bridge version 1.0.36</span><br><span class="line">Revision 8f855a3d9b35-android</span><br></pre></td></tr></table></figure><h3 id="以-root-权限运行-adbd"><a href="#以-root-权限运行-adbd" class="headerlink" title="以 root 权限运行 adbd"></a>以 root 权限运行 adbd</h3><p> adb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。</p><p> 所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 adb xxx 执行。这时可以 adb shell 然后 su 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。</p><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br></pre></td></tr></table></figure><p> 正常输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restarting adbd as root</span><br></pre></td></tr></table></figure><p> 现在再运行 adb shell，看看命令行提示符是不是变成 # 了？</p><p> 有些手机 root 后也无法通过 adb root 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 adbd cannot run as root in production builds，此时可以先安装 <strong>adbd Insecure</strong>，然后 adb root 试试。</p><p> 相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 <strong>adb unroot</strong> 命令。</p><h3 id="指定-adb-server-的网络端口"><a href="#指定-adb-server-的网络端口" class="headerlink" title="指定 adb server 的网络端口"></a>指定 adb server 的网络端口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb -P &lt;port&gt; start-server</span><br></pre></td></tr></table></figure><p> 默认端口为 5037。</p><h2 id="设备连接管理"><a href="#设备连接管理" class="headerlink" title="设备连接管理"></a>设备连接管理</h2><hr><h3 id="查询已连接设备-模拟器"><a href="#查询已连接设备-模拟器" class="headerlink" title="查询已连接设备/模拟器"></a>查询已连接设备/模拟器</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure><p> 输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">cf264b8f    device</span><br><span class="line">emulator-5554   device</span><br><span class="line">10.129.164.6:5555   device</span><br></pre></td></tr></table></figure><p> 输出格式为 [serialNumber] [state]，serialNumber 即我们常说的 SN，state 有如下几种：</p><p> offline —— 表示设备未连接成功或无响应。</p><p> device —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。</p><p> no device —— 没有设备/模拟器连接。</p><p> 以上输出显示当前已经连接了三台设备/模拟器，cf264b8f、emulator-5554 和 10.129.164.6:5555 分别是它们的 SN。从 emulator-5554 这个名字可以看出它是一个 Android 模拟器，而 10.129.164.6:5555 这种形为 : 的 serialNumber 一般是无线连接的设备或 Genymotion 等第三方 Android 模拟器。</p><p> 常见异常输出：</p><p> 没有设备/模拟器连接成功。</p><p> List of devices attached<br> 设备/模拟器未连接到 adb 或无响应。</p><p> List of devices attached<br> cf264b8f offline</p><h3 id="USB-连接"><a href="#USB-连接" class="headerlink" title="USB 连接"></a>USB 连接</h3><p> 通过 USB 连接来正常使用 adb 需要保证几点：</p><p> 硬件状态正常。</p><p> 包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。</p><p> Android 设备的开发者选项和 USB 调试模式已开启。</p><p> 可以到「设置」-「开发者选项」-「Android 调试」查看。</p><p> 如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。</p><p> 设备驱动状态正常。</p><p> 这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。</p><p> 通过 USB 线连接好电脑和设备后确认状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure><p> 如果能看到<br> xxxxxx device<br> 说明连接成功。</p><h3 id="无线连接（需要借助-USB-线）"><a href="#无线连接（需要借助-USB-线）" class="headerlink" title="无线连接（需要借助 USB 线）"></a>无线连接（需要借助 USB 线）</h3><p> 除了可以通过 USB 连接设备与电脑来使用 adb，也可以通过无线连接——虽然连接过程中也有需要使用 USB 的步骤，但是连接成功之后你的设备就可以在一定范围内摆脱 USB 连接线的限制啦！</p><p> 操作步骤：<br> 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。<br> 将设备与电脑通过 USB 线连接。<br> 应确保连接成功（可运行 adb devices 看是否能列出该设备）。<br> 让设备在 5555 端口监听 TCP/IP 连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb tcpip 5555</span><br></pre></td></tr></table></figure><p> 断开 USB 连接。<br> 找到设备的 IP 地址。<br> 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 查看设备信息 - IP 地址 一节里的方法用 adb 命令来查看。</p><p> 通过 IP 地址连接设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb connect &lt;device-ip-address&gt;</span><br></pre></td></tr></table></figure><p> 这里的 就是上一步中找到的设备 IP 地址。</p><p> 确认连接状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure><p> 如果能看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;device-ip-address&gt;:5555 device</span><br></pre></td></tr></table></figure><p> 说明连接成功。<br> 如果连接不了，请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行  <code>adb connect &lt;device-ip-address&gt;</code>  那一步；<br> 如果还是不行的话，通过 adb kill-server 重新启动 adb 然后从头再来一次试试。</p><p> 断开无线连接<br> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb disconnect &lt;device-ip-address&gt;</span><br></pre></td></tr></table></figure><h3 id="无线连接（无需借助-USB-线）"><a href="#无线连接（无需借助-USB-线）" class="headerlink" title="无线连接（无需借助 USB 线）"></a>无线连接（无需借助 USB 线）</h3><p> 注：需要 root 权限。</p><p> 上一节「无线连接（需要借助 USB 线）」是官方文档里介绍的方法，需要借助于 USB 数据线来实现无线连接。<br> 既然我们想要实现无线连接，那能不能所有步骤下来都是无线的呢？答案是能的。<br> 在 Android 设备上安装一个终端模拟器。<br> 已经安装过的设备可以跳过此步。我使用的终端模拟器下载地址是：Terminal Emulator for Android Downloads<br> 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。<br> 打开 Android 设备上的终端模拟器，在里面依次运行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line">setprop service.adb.tcp.port 5555</span><br></pre></td></tr></table></figure><p> 找到 Android 设备的 IP 地址。</p><p> 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 查看设备信息 - IP 地址 一节里的方法用 adb 命令来查看。</p><p> 在电脑上通过 adb 和 IP 地址连接 Android 设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb connect &lt;device-ip-address&gt;</span><br></pre></td></tr></table></figure><p> 这里的 就是上一步中找到的设备 IP 地址。</p><p> 如果能看到 connected to :5555 这样的输出则表示连接成功。</p><p> <strong>节注一：</strong></p><p> 有的设备，比如小米 5S + MIUI 8.0 + Android 6.0.1 MXB48T，可能在第 5 步之前需要重启 adbd 服务，在设备的终端模拟器上运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restart adbd</span><br></pre></td></tr></table></figure><p> 如果 restart 无效，尝试以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop adbd</span><br><span class="line">start adbd</span><br></pre></td></tr></table></figure><h2 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h2><h3 id="查看应用列表"><a href="#查看应用列表" class="headerlink" title="查看应用列表"></a>查看应用列表</h3><p> 查看应用列表的基本命令格式是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER]</span><br></pre></td></tr></table></figure><p> 即在 adb shell pm list packages 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下：</p><pre><code>参数             | 显示列表                   -------------- | -----------------------无              | 所有应用                   -f             | 显示应用关联的 apk 文件         -d             | 只显示 disabled 的应用       -e             | 只显示 enabled 的应用        -s             | 只显示系统应用                -3             | 只显示第三方应用               -i             | 显示应用的 installer        -u             | 包含已卸载应用                &amp;lt;FILTER&amp;gt; | 包名包含 &amp;lt;FILTER&amp;gt; 字符串</code></pre><h3 id="所有应用"><a href="#所有应用" class="headerlink" title="所有应用"></a>所有应用</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages</span><br></pre></td></tr></table></figure><p> 输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package:com.android.smoketest</span><br><span class="line">package:com.example.android.livecubes</span><br><span class="line">package:com.android.providers.telephony</span><br><span class="line">package:com.google.android.googlequicksearchbox</span><br><span class="line">package:com.android.providers.calendar</span><br><span class="line">package:com.android.providers.media</span><br><span class="line">package:com.android.protips</span><br><span class="line">package:com.android.documentsui</span><br><span class="line">package:com.android.gallery</span><br><span class="line">package:com.android.externalstorage</span><br><span class="line">...</span><br><span class="line">// other packages here</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="系统应用"><a href="#系统应用" class="headerlink" title="系统应用"></a>系统应用</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages -s</span><br></pre></td></tr></table></figure><h3 id="第三方应用"><a href="#第三方应用" class="headerlink" title="第三方应用"></a>第三方应用</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages -3</span><br></pre></td></tr></table></figure><p> 包名包含某字符串的应用<br> 比如要查看包名包含字符串 mazhuang 的应用列表，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages mazhuang</span><br></pre></td></tr></table></figure><p> 当然也可以使用 grep 来过滤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages | grep mazhuang</span><br></pre></td></tr></table></figure><h3 id="安装-APK"><a href="#安装-APK" class="headerlink" title="安装 APK"></a>安装 APK</h3><p> 命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install [-lrtsdg] &lt;path_to_apk&gt;</span><br></pre></td></tr></table></figure><p> 参数：</p><p> adb install 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下：</p><pre><code>参数 | 含义                                                                   -- | ----------------------------------------------------------------------l | 将应用安装到保护目录 /mnt/asec                                                 -r | 允许覆盖安装                                                               -t | 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=&quot;true&quot; 的应用-s | 将应用安装到 sdcard                                                        -d | 允许降级覆盖安装                                                             -g | 授予所有运行时权限                                                            </code></pre><p> 运行命令后如果见到类似如下输出（状态为 Success）代表安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[100%] /data/local/tmp/1.apk</span><br><span class="line">    pkg: /data/local/tmp/1.apk</span><br><span class="line">Success</span><br></pre></td></tr></table></figure><p> 上面是当前最新版 v1.0.36 的 adb 的输出，会显示 push apk 文件到手机的进度百分比。</p><p> 使用旧版本 adb 的输出则是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">12040 KB/s (22205609 bytes in 1.801s)</span><br><span class="line">        pkg: /data/local/tmp/SogouInput_android_v8.3_sweb.apk</span><br><span class="line">Success</span><br></pre></td></tr></table></figure><p> 而如果状态为 Failure 则表示安装失败，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[100%] /data/local/tmp/map-20160831.apk</span><br><span class="line">        pkg: /data/local/tmp/map-20160831.apk</span><br><span class="line">Failure [INSTALL_FAILED_ALREADY_EXISTS]</span><br></pre></td></tr></table></figure><p> 常见安装失败输出代码、含义及可能的解决办法如下：</p><pre><code>输出                                                                  | 含义                                                     | 解决办法                                                           ------------------------------------------------------------------- | ------------------------------------------------------ | ---------------------------------------------------------------INSTALL_FAILED_ALREADY_EXISTS                                       | 应用已经存在，或卸载了但没卸载干净                                      | adb install 时使用 -r 参数，或者先 adb uninstall &amp;lt;packagename&amp;gt; 再安装INSTALL_FAILED_INVALID_APK                                          | 无效的 APK 文件                                             |                                                                INSTALL_FAILED_INVALID_URI                                          | 无效的 APK 文件名                                            | 确保 APK 文件名里无中文                                                 INSTALL_FAILED_INSUFFICIENT_STORAGE                                 | 空间不足                                                   | 清理空间                                                           INSTALL_FAILED_DUPLICATE_PACKAGE                                    | 已经存在同名程序                                               |                                                                INSTALL_FAILED_NO_SHARED_USER                                       | 请求的共享用户不存在                                             |                                                                INSTALL_FAILED_UPDATE_INCOMPATIBLE                                  | 以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致                   | 先 adb uninstall &amp;lt;packagename&amp;gt; 再安装                        INSTALL_FAILED_SHARED_USER_INCOMPATIBLE                             | 请求的共享用户存在但签名不一致                                        |                                                                INSTALL_FAILED_MISSING_SHARED_LIBRARY                               | 安装包使用了设备上不可用的共享库                                       |                                                                INSTALL_FAILED_REPLACE_COULDNT_DELETE                               | 替换时无法删除                                                |                                                                INSTALL_FAILED_DEXOPT                                               | dex 优化验证失败或空间不足                                        |                                                                INSTALL_FAILED_OLDER_SDK                                            | 设备系统版本低于应用要求                                           |                                                                INSTALL_FAILED_CONFLICTING_PROVIDER                                 | 设备里已经存在与应用里同名的 content provider                        |                                                                INSTALL_FAILED_NEWER_SDK                                            | 设备系统版本高于应用要求                                           |                                                                INSTALL_FAILED_TEST_ONLY                                            | 应用是 test-only 的，但安装时没有指定 -t 参数                         |                                                                INSTALL_FAILED_CPU_ABI_INCOMPATIBLE                                 | 包含不兼容设备 CPU 应用程序二进制接口的 native code                     |                                                                INSTALL_FAILED_MISSING_FEATURE                                      | 应用使用了设备不可用的功能                                          |                                                                INSTALL_FAILED_CONTAINER_ERROR                                      | 1. sdcard 访问失败;2. 应用签名与 ROM 签名一致，被当作内置应用。              | 1. 确认 sdcard 可用，或者安装到内置存储;2. 打包时不与 ROM 使用相同签名。                 INSTALL_FAILED_INVALID_INSTALL_LOCATION                             | 1. 不能安装到指定位置;2. 应用签名与 ROM 签名一致，被当作内置应用。                | 1. 切换安装位置，添加或删除 -s 参数;2. 打包时不与 ROM 使用相同签名。                     INSTALL_FAILED_MEDIA_UNAVAILABLE                                    | 安装位置不可用                                                | 一般为 sdcard，确认 sdcard 可用或安装到内置存储                                INSTALL_FAILED_VERIFICATION_TIMEOUT                                 | 验证安装包超时                                                |                                                                INSTALL_FAILED_VERIFICATION_FAILURE                                 | 验证安装包失败                                                |                                                                INSTALL_FAILED_PACKAGE_CHANGED                                      | 应用与调用程序期望的不一致                                          |                                                                INSTALL_FAILED_UID_CHANGED                                          | 以前安装过该应用，与本次分配的 UID 不一致                                | 清除以前安装过的残留文件                                                   INSTALL_FAILED_VERSION_DOWNGRADE                                    | 已经安装了该应用更高版本                                           | 使用 -d 参数                                                       INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE                           | 已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限             |                                                                INSTALL_PARSE_FAILED_NOT_APK                                        | 指定路径不是文件，或不是以 .apk 结尾                                  |                                                                INSTALL_PARSE_FAILED_BAD_MANIFEST                                   | 无法解析的 AndroidManifest.xml 文件                           |                                                                INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION                           | 解析器遇到异常                                                |                                                                INSTALL_PARSE_FAILED_NO_CERTIFICATES                                | 安装包没有签名                                                |                                                                INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES                      | 已安装该应用，且签名与 APK 文件不一致                                  | 先卸载设备上的该应用，再安装                                                 INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING                           | 解析 APK 文件时遇到 CertificateEncodingException              |                                                                INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME                               | manifest 文件里没有或者使用了无效的包名                               |                                                                INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID                             | manifest 文件里指定了无效的共享用户 ID                              |                                                                INSTALL_PARSE_FAILED_MANIFEST_MALFORMED                             | 解析 manifest 文件时遇到结构性错误                                 |                                                                INSTALL_PARSE_FAILED_MANIFEST_EMPTY                                 | 在 manifest 文件里找不到找可操作标签（instrumentation 或 application） |                                                                INSTALL_FAILED_INTERNAL_ERROR                                       | 因系统问题安装失败                                              |                                                                INSTALL_FAILED_USER_RESTRICTED                                      | 用户被限制安装应用                                              |                                                                INSTALL_FAILED_DUPLICATE_PERMISSION                                 | 应用尝试定义一个已经存在的权限名称                                      |                                                                INSTALL_FAILED_NO_MATCHING_ABIS                                     | 应用包含设备的应用程序二进制接口不支持的 native code                       |                                                                INSTALL_CANCELED_BY_USER                                            | 应用安装需要在设备上确认，但未操作设备或点了取消                               | 在设备上同意安装                                                       INSTALL_FAILED_ACWF_INCOMPATIBLE                                    | 应用程序与设备不兼容                                             |                                                                does not contain AndroidManifest.xml                                | 无效的 APK 文件                                             |                                                                is not a valid zip file                                             | 无效的 APK 文件                                             |                                                                Offline                                                             | 设备未连接成功                                                | 先将设备与 adb 连接成功                                                 unauthorized                                                        | 设备未授权允许调试                                              |                                                                error: device not found                                             | 没有连接成功的设备                                              | 先将设备与 adb 连接成功                                                 protocol failure                                                    | 设备已断开连接                                                | 先将设备与 adb 连接成功                                                 Unknown option: -s                                                  | Android 2.2 以下不支持安装到 sdcard                            | 不使用 -s 参数                                                      No space left on device                                             | 空间不足                                                   | 清理空间                                                           Permission denied … sdcard …                                        | sdcard 不可用                                             |                                                                signatures do not match the previously installed version; ignoring! | 已安装该应用且签名不一致                                           | 先卸载设备上的该应用，再安装                                                 </code></pre><p> 参考：<a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/content/pm/PackageManager.java" target="_blank" rel="noopener">[PackageManager.java]</a></p><h3 id="adb-install-内部原理简介"><a href="#adb-install-内部原理简介" class="headerlink" title="adb install 内部原理简介"></a>adb install 内部原理简介</h3><p> adb install 实际是分三步完成：</p><ol start="2"><li>push apk 文件到 /data/local/tmp。</li><li>调用 pm install 安装。</li><li>删除 /data/local/tmp 下的对应 apk 文件。  所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。</li></ol><h3 id="卸载应用"><a href="#卸载应用" class="headerlink" title="卸载应用"></a>卸载应用</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall [-k] &lt;packagename&gt;</span><br></pre></td></tr></table></figure><p> <code>&lt;packagename&gt;</code>  表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录。<br> 命令示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall com.qihoo360.mobilesafe</span><br></pre></td></tr></table></figure><p> 表示卸载 360 手机卫士。</p><h3 id="清除应用数据与缓存"><a href="#清除应用数据与缓存" class="headerlink" title="清除应用数据与缓存"></a>清除应用数据与缓存</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm clear &lt;packagename&gt;</span><br></pre></td></tr></table></figure><p> <code>&lt;packagename&gt;</code>  表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。</p><p> 命令示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm clear com.qihoo360.mobilesafe</span><br></pre></td></tr></table></figure><p> 表示清除 360 手机卫士的数据和缓存。</p><h3 id="查看前台-Activity"><a href="#查看前台-Activity" class="headerlink" title="查看前台 Activity"></a>查看前台 Activity</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity activities | grep mFocusedActivity</span><br></pre></td></tr></table></figure><p> 输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mFocusedActivity: ActivityRecord&#123;8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42&#125;</span><br></pre></td></tr></table></figure><p> 其中的  <code>com.cyanogenmod.trebuchet/com.android.launcher3.Launcher</code>  就是当前处于前台的 Activity。</p><h3 id="查看正在运行的-Services"><a href="#查看正在运行的-Services" class="headerlink" title="查看正在运行的 Services"></a>查看正在运行的 Services</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity services [&lt;packagename&gt;]</span><br></pre></td></tr></table></figure><p> <code>&lt;packagename&gt;</code>  参数不是必须的，指定  <code>&lt;packagename&gt;</code>  表示查看与某个包名相关的 Services，不指定表示查看所有 Services。</p><p> <code>&lt;packagename&gt;</code>  不一定要给出完整的包名，比如运行 adb shell dumpsys activity services org.mazhuang，那么包名 org.mazhuang.demo1、org.mazhuang.demo2 和 org.mazhuang123 等相关的 Services 都会列出来。</p><h3 id="查看应用详细信息"><a href="#查看应用详细信息" class="headerlink" title="查看应用详细信息"></a>查看应用详细信息</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys package &lt;packagename&gt;</span><br></pre></td></tr></table></figure><p> 输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。</p><p> <code>&lt;packagename&gt;</code>  表示应用包名。</p><p> 输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">Activity Resolver Table:</span><br><span class="line">  Non-Data Actions:</span><br><span class="line">      android.intent.action.MAIN:</span><br><span class="line">        5b4cba8 org.mazhuang.guanggoo/.SplashActivity filter 5ec9dcc</span><br><span class="line">          Action: &quot;android.intent.action.MAIN&quot;</span><br><span class="line">          Category: &quot;android.intent.category.LAUNCHER&quot;</span><br><span class="line">          AutoVerify=false</span><br><span class="line"></span><br><span class="line">Registered ContentProviders:</span><br><span class="line">  org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider:</span><br><span class="line">    Provider&#123;7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider&#125;</span><br><span class="line"></span><br><span class="line">ContentProvider Authorities:</span><br><span class="line">  [org.mazhuang.guanggoo.fileProvider]:</span><br><span class="line">    Provider&#123;7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider&#125;</span><br><span class="line">      applicationInfo=ApplicationInfo&#123;7754242 org.mazhuang.guanggoo&#125;</span><br><span class="line"></span><br><span class="line">Key Set Manager:</span><br><span class="line">  [org.mazhuang.guanggoo]</span><br><span class="line">      Signing KeySets: 501</span><br><span class="line"></span><br><span class="line">Packages:</span><br><span class="line">  Package [org.mazhuang.guanggoo] (c1d7f):</span><br><span class="line">    userId=10394</span><br><span class="line">    pkg=Package&#123;55f714c org.mazhuang.guanggoo&#125;</span><br><span class="line">    codePath=/data/app/org.mazhuang.guanggoo-2</span><br><span class="line">    resourcePath=/data/app/org.mazhuang.guanggoo-2</span><br><span class="line">    legacyNativeLibraryDir=/data/app/org.mazhuang.guanggoo-2/lib</span><br><span class="line">    primaryCpuAbi=null</span><br><span class="line">    secondaryCpuAbi=null</span><br><span class="line">    versionCode=74 minSdk=15 targetSdk=25</span><br><span class="line">    versionName=1.1.74</span><br><span class="line">    splits=[base]</span><br><span class="line">    apkSigningVersion=2</span><br><span class="line">    applicationInfo=ApplicationInfo&#123;7754242 org.mazhuang.guanggoo&#125;</span><br><span class="line">    flags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ]</span><br><span class="line">    privateFlags=[ RESIZEABLE_ACTIVITIES ]</span><br><span class="line">    dataDir=/data/user/0/org.mazhuang.guanggoo</span><br><span class="line">    supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity]</span><br><span class="line">    timeStamp=2017-10-22 23:50:53</span><br><span class="line">    firstInstallTime=2017-10-22 23:50:25</span><br><span class="line">    lastUpdateTime=2017-10-22 23:50:55</span><br><span class="line">    installerPackageName=com.miui.packageinstaller</span><br><span class="line">    signatures=PackageSignatures&#123;af09595 [53c7caa2]&#125;</span><br><span class="line">    installPermissionsFixed=true installStatus=1</span><br><span class="line">    pkgFlags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ]</span><br><span class="line">    requested permissions:</span><br><span class="line">      android.permission.READ_PHONE_STATE</span><br><span class="line">      android.permission.INTERNET</span><br><span class="line">      android.permission.ACCESS_NETWORK_STATE</span><br><span class="line">      android.permission.ACCESS_WIFI_STATE</span><br><span class="line">      android.permission.READ_LOGS</span><br><span class="line">      android.permission.WRITE_EXTERNAL_STORAGE</span><br><span class="line">      android.permission.READ_EXTERNAL_STORAGE</span><br><span class="line">    install permissions:</span><br><span class="line">      android.permission.INTERNET: granted=true</span><br><span class="line">      android.permission.ACCESS_NETWORK_STATE: granted=true</span><br><span class="line">      android.permission.ACCESS_WIFI_STATE: granted=true</span><br><span class="line">    User 0: ceDataInode=1155675 installed=true hidden=false suspended=false stopped=true notLaunched=false enabled=0</span><br><span class="line">      gids=[3003]</span><br><span class="line">      runtime permissions:</span><br><span class="line">        android.permission.READ_EXTERNAL_STORAGE: granted=true</span><br><span class="line">        android.permission.READ_PHONE_STATE: granted=true</span><br><span class="line">        android.permission.WRITE_EXTERNAL_STORAGE: granted=true</span><br><span class="line">    User 999: ceDataInode=0 installed=false hidden=false suspended=false stopped=true notLaunched=true enabled=0</span><br><span class="line">      gids=[3003]</span><br><span class="line">      runtime permissions:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dexopt state:</span><br><span class="line">  [org.mazhuang.guanggoo]</span><br><span class="line">    Instruction Set: arm64</span><br><span class="line">      path: /data/app/org.mazhuang.guanggoo-2/base.apk</span><br><span class="line">      status: /data/app/org.mazhuang.guanggoo-2/oat/arm64/base.odex [compilation_filter=speed-profile, status=kOatUpToDa</span><br><span class="line">      te]</span><br></pre></td></tr></table></figure><h2 id="与应用交互"><a href="#与应用交互" class="headerlink" title="与应用交互"></a>与应用交互</h2><p> 主要是使用  <code>am &lt;command&gt;</code>  命令，常用的  <code>&lt;command&gt;</code>  如下：</p><pre><code>command                               | 用途                            ------------------------------------- | ------------------------------start [options] &amp;lt;INTENT&amp;gt;        | 启动 &amp;lt;INTENT&amp;gt; 指定的 Activitystartservice [options] &amp;lt;INTENT&amp;gt; | 启动 &amp;lt;INTENT&amp;gt; 指定的 Servicebroadcast [options] &amp;lt;INTENT&amp;gt;    | 发送 &amp;lt;INTENT&amp;gt; 指定的广播       force-stop &amp;lt;packagename&amp;gt;        | 停止 &amp;lt;packagename&amp;gt; 相关的进程  </code></pre><p> <code>&lt;INTENT&gt;</code>  参数很灵活，和写 Android 程序时代码里的 Intent 相对应。</p><p> 用于决定 intent 对象的选项如下：</p><pre><code>参数                   | 含义                                                                     -------------------- | ------------------------------------------------------------------------a &amp;lt;ACTION&amp;gt;    | 指定 action，比如 android.intent.action.VIEW                                -c &amp;lt;CATEGORY&amp;gt;  | 指定 category，比如 android.intent.category.APP_CONTACTS                    -n &amp;lt;COMPONENT&amp;gt; | 指定完整 component 名，用于明确指定启动哪个 Activity，如 com.example.app/.ExampleActivity</code></pre><p> <code>&lt;INTENT&gt;</code>  里还能带数据，就像写代码时的 Bundle 一样：</p><pre><code>参数                                                                         | 含义                                               -------------------------------------------------------------------------- | ---------------------------------------------------esn &amp;lt;EXTRA_KEY&amp;gt;                                                    | null 值（只有 key 名）                                 `-e                                                                        | –es &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_STRING_VALUE&amp;gt;`--ez &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_BOOLEAN_VALUE&amp;gt;                         | boolean 值                                        --ei &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_INT_VALUE&amp;gt;                             | integer 值                                        --el &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_LONG_VALUE&amp;gt;                            | long 值                                           --ef &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_FLOAT_VALUE&amp;gt;                           | float 值                                          --eu &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_URI_VALUE&amp;gt;                             | URI                                              --ecn &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_COMPONENT_NAME_VALUE&amp;gt;                 | component name                                   --eia &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_INT_VALUE&amp;gt;[,&amp;lt;EXTRA_INT_VALUE...]   | integer 数组                                       --ela &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_LONG_VALUE&amp;gt;[,&amp;lt;EXTRA_LONG_VALUE...] | long 数组                                          </code></pre><h3 id="调起-Activity"><a href="#调起-Activity" class="headerlink" title="调起 Activity"></a>调起 Activity</h3><p> 命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure><p> 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -n com.tencent.mm/.ui.LauncherUI</span><br></pre></td></tr></table></figure><p> 表示调起微信主界面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es &quot;toast&quot; &quot;hello, world&quot;</span><br></pre></td></tr></table></figure><p> 表示调起 org.mazhuang.boottimemeasure/.MainActivity 并传给它 string 数据键值对 toast - hello, world。</p><h3 id="调起-Service"><a href="#调起-Service" class="headerlink" title="调起 Service"></a>调起 Service</h3><p> 命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am startservice [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure><p> 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService</span><br></pre></td></tr></table></figure><p> 表示调起微信的某 Service。</p><h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><p> 命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am broadcast [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure><p> 可以向所有组件广播，也可以只向指定组件广播。</p><p> 例如，向所有组件广播 BOOT_COMPLETED：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED</span><br></pre></td></tr></table></figure><p> 又例如，只向 org.mazhuang.boottimemeasure/.BootCompletedReceiver 广播 BOOT_COMPLETED：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure/.BootCompletedReceiver</span><br></pre></td></tr></table></figure><p> 这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。<br> 既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机：</p><pre><code>action                                          | 触发时机                       ----------------------------------------------- | ---------------------------android.net.conn.CONNECTIVITY_CHANGE            | 网络连接发生变化                   android.intent.action.SCREEN_ON                 | 屏幕点亮                       android.intent.action.SCREEN_OFF                | 屏幕熄灭                       android.intent.action.BATTERY_LOW               | 电量低，会弹出电量低提示框              android.intent.action.BATTERY_OKAY              | 电量恢复了                      android.intent.action.BOOT_COMPLETED            | 设备启动完毕                     android.intent.action.DEVICE_STORAGE_LOW        | 存储空间过低                     android.intent.action.DEVICE_STORAGE_OK         | 存储空间恢复                     android.intent.action.PACKAGE_ADDED             | 安装了新的应用                    android.net.wifi.STATE_CHANGE                   | WiFi 连接状态发生变化              android.net.wifi.WIFI_STATE_CHANGED             | WiFi 状态变为启用/关闭/正在启动/正在关闭/未知android.intent.action.BATTERY_CHANGED           | 电池电量发生变化                   android.intent.action.INPUT_METHOD_CHANGED      | 系统输入法发生变化                  android.intent.action.ACTION_POWER_CONNECTED    | 外部电源连接                     android.intent.action.ACTION_POWER_DISCONNECTED | 外部电源断开连接                   android.intent.action.DREAMING_STARTED          | 系统开始休眠                     android.intent.action.DREAMING_STOPPED          | 系统停止休眠                     android.intent.action.WALLPAPER_CHANGED         | 壁纸发生变化                     android.intent.action.HEADSET_PLUG              | 插入耳机                       android.intent.action.MEDIA_UNMOUNTED           | 卸载外部介质                     android.intent.action.MEDIA_MOUNTED             | 挂载外部介质                     android.os.action.POWER_SAVE_MODE_CHANGED       | 省电模式开启                     </code></pre><p> <em>（以上广播均可使用 adb 触发）</em></p><h3 id="强制停止应用"><a href="#强制停止应用" class="headerlink" title="强制停止应用"></a>强制停止应用</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am force-stop &lt;packagename&gt;</span><br></pre></td></tr></table></figure><p> 命令示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am force-stop com.qihoo360.mobilesafe</span><br></pre></td></tr></table></figure><p> 表示停止 360 安全卫士的一切进程与服务。</p><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="复制设备里的文件到电脑"><a href="#复制设备里的文件到电脑" class="headerlink" title="复制设备里的文件到电脑"></a>复制设备里的文件到电脑</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull &lt;设备里的文件路径&gt; [电脑上的目录]</span><br></pre></td></tr></table></figure><p> 其中 电脑上的目录 参数可以省略，默认复制到当前目录。</p><p> 例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /sdcard/sr.mp4 ~/tmp/</span><br></pre></td></tr></table></figure><p> <em>小技巧：</em>设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 adb shell 和 su 命令在 adb shell 里获取 root 权限后，先 cp /path/on/device /sdcard/filename 将文件复制到 sdcard，然后 adb pull /sdcard/filename /path/on/pc。</p><h3 id="复制电脑里的文件到设备"><a href="#复制电脑里的文件到设备" class="headerlink" title="复制电脑里的文件到设备"></a>复制电脑里的文件到设备</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt;</span><br></pre></td></tr></table></figure><p> 例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push ~/sr.mp4 /sdcard/</span><br></pre></td></tr></table></figure><p> <em>小技巧：</em>设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 adb push /path/on/pc /sdcard/filename，然后 adb shell 和 su 在 adb shell 里获取 root 权限后，cp /sdcard/filename /path/on/device。</p><h2 id="模拟按键-输入"><a href="#模拟按键-输入" class="headerlink" title="模拟按键/输入"></a>模拟按键/输入</h2><p> 在 adb shell 里有个很实用的命令叫 input，通过它可以做一些有趣的事情。<br> input 命令的完整 help 信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]</span><br><span class="line"></span><br><span class="line">The sources are:</span><br><span class="line">      mouse</span><br><span class="line">      keyboard</span><br><span class="line">      joystick</span><br><span class="line">      touchnavigation</span><br><span class="line">      touchpad</span><br><span class="line">      trackball</span><br><span class="line">      stylus</span><br><span class="line">      dpad</span><br><span class="line">      gesture</span><br><span class="line">      touchscreen</span><br><span class="line">      gamepad</span><br><span class="line"></span><br><span class="line">The commands and default sources are:</span><br><span class="line">      text &lt;string&gt; (Default: touchscreen)</span><br><span class="line">      keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard)</span><br><span class="line">      tap &lt;x&gt; &lt;y&gt; (Default: touchscreen)</span><br><span class="line">      swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)</span><br><span class="line">      press (Default: trackball)</span><br><span class="line">      roll &lt;dx&gt; &lt;dy&gt; (Default: trackball)</span><br></pre></td></tr></table></figure><p> 比如模拟点击：//在屏幕上点击坐标点x=50 y=250的位置。</p><blockquote><p>adb shell input tap 50 250</p><p> 比如使用 adb shell input keyevent 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 KeyEvent，摘引部分我觉得有意思的如下：</p></blockquote><pre><code>keycode | 含义                  ------- | --------------------3       | HOME 键              4       | 返回键                 5       | 打开拨号应用              6       | 挂断电话                24      | 增加音量                25      | 降低音量                26      | 电源键                 27      | 拍照（需要在相机应用里）        64      | 打开浏览器               82      | 菜单键                 85      | 播放/暂停               86      | 停止播放                87      | 播放下一首               88      | 播放上一首               122     | 移动光标到行首或列表顶部        123     | 移动光标到行末或列表底部        126     | 恢复播放                127     | 暂停播放                164     | 静音                  176     | 打开系统设置              187     | 切换应用                207     | 打开联系人               208     | 打开日历                209     | 打开音乐                210     | 打开计算器               220     | 降低屏幕亮度              221     | 提高屏幕亮度              223     | 系统休眠                224     | 点亮屏幕                231     | 打开语音助手              276     | 如果没有 wakelock 则让系统休眠</code></pre><p> 下面是 input 命令的一些用法举例。</p><h3 id="电源键"><a href="#电源键" class="headerlink" title="电源键"></a>电源键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db shell input keyevent 26</span><br></pre></td></tr></table></figure><p> 执行效果相当于按电源键。</p><h3 id="菜单键"><a href="#菜单键" class="headerlink" title="菜单键"></a>菜单键</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 82</span><br></pre></td></tr></table></figure><h3 id="HOME-键"><a href="#HOME-键" class="headerlink" title="HOME 键"></a>HOME 键</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 3</span><br></pre></td></tr></table></figure><h3 id="返回键"><a href="#返回键" class="headerlink" title="返回键"></a>返回键</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 4</span><br></pre></td></tr></table></figure><h3 id="音量控制"><a href="#音量控制" class="headerlink" title="音量控制"></a>音量控制</h3><p> <strong>增加音量：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 24</span><br></pre></td></tr></table></figure><p> <strong>降低音量：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 25</span><br></pre></td></tr></table></figure><p> <strong>静音：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 164</span><br></pre></td></tr></table></figure><h3 id="媒体控制"><a href="#媒体控制" class="headerlink" title="媒体控制"></a>媒体控制</h3><p> <strong>播放/暂停：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 85</span><br></pre></td></tr></table></figure><p> <strong>停止播放：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 86</span><br></pre></td></tr></table></figure><p> <strong>播放下一首：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 87</span><br></pre></td></tr></table></figure><p> <strong>播放上一首：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 88</span><br></pre></td></tr></table></figure><p> <strong>恢复播放：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 126</span><br></pre></td></tr></table></figure><p> <strong>暂停播放：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 127</span><br></pre></td></tr></table></figure><h3 id="点亮-熄灭屏幕"><a href="#点亮-熄灭屏幕" class="headerlink" title="点亮/熄灭屏幕"></a>点亮/熄灭屏幕</h3><p> 可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。</p><p> <strong>点亮屏幕：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 224</span><br></pre></td></tr></table></figure><p> <strong>熄灭屏幕：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 223</span><br></pre></td></tr></table></figure><h3 id="滑动解锁"><a href="#滑动解锁" class="headerlink" title="滑动解锁"></a>滑动解锁</h3><p> 如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 input swipe 来解锁。</p><p> 命令（参数以机型 Nexus 5，向上滑动手势解锁举例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input swipe 300 1000 300 500</span><br></pre></td></tr></table></figure><p> 参数 300 1000 300 500 分别表示起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标。</p><h3 id="输入文本"><a href="#输入文本" class="headerlink" title="输入文本"></a>输入文本</h3><p> 在焦点处于某文本框时，可以通过 input 命令来输入文本。</p><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input text hello</span><br></pre></td></tr></table></figure><p> 现在 hello 出现在文本框了。</p><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p> Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。</p><h3 id="Android-日志"><a href="#Android-日志" class="headerlink" title="Android 日志"></a>Android 日志</h3><p> 命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ...</span><br></pre></td></tr></table></figure><p> 常用用法列举如下：</p><p> 按级别过滤日志</p><p> Android 的日志分为如下几个优先级（priority）：</p><ul><li>V —— Verbose（最低，输出得最多）  </li><li>D —— Debug I —— Info  </li><li>W —— Warning  </li><li>E —— Error  </li><li>F—— Fatal  </li><li><p>S —— Silent（最高，啥也不输出）  按某级别过滤日志则会将该级别及以上的日志输出。</p><p>比如，命令：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat *:W</span><br></pre></td></tr></table></figure><p> 会将 Warning、Error、Fatal 和 Silent 日志输出。</p><p> （注： 在 macOS 下需要给 _:W 这样以 _ 作为 tag 的参数加双引号，如 adb logcat “_:W”，不然会报错 no matches found: _:W。）</p><p> <strong>按 tag 和级别过滤日志</strong></p><p> <code>&lt;filter-spec&gt;</code>  可以由多个  <code>&lt;tag&gt;[:priority]</code>  组成。</p><p> 比如，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat ActivityManager:I MyApp:D *:S</span><br></pre></td></tr></table></figure><p> 表示输出 tag ActivityManager 的 Info 以上级别日志，输出 tag MyApp 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。</p><p> <strong>日志格式</strong></p><p> 可以用  <code>adb logcat -v &lt;format&gt;</code>  选项指定日志输出格式。</p><p> 日志支持按以下几种  <code>&lt;format&gt;</code> ：</p><ul><li><p>brief</p><p> 默认格式。格式为：</p></li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;</span><br></pre></td></tr></table></figure> 示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>process</p><p> 格式为：</p></li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt;</span><br></pre></td></tr></table></figure> 示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D( 1785) Disconnected process message: 10, size: 0  (HeadsetStateMachine)</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>tag</p><p> 格式为：</p></li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt;</span><br></pre></td></tr></table></figure> 示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D/HeadsetStateMachine: Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>raw</p><p> 格式为：</p></li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;message&gt;</span><br></pre></td></tr></table></figure> 示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>time</p><p> 格式为：</p></li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;</span><br></pre></td></tr></table></figure> 示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">08-28 22:39:39.974 D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>threadtime</p><p> 格式为：</p></li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt;</span><br></pre></td></tr></table></figure> 示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">08-28 22:39:39.974  1785  1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>long</p><p> 格式为：</p></li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ] &lt;message&gt;</span><br></pre></td></tr></table></figure> 示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 08-28 22:39:39.974  1785: 1832 D/HeadsetStateMachine ] Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure> 指定格式可与上面的过滤同时使用。比如：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat -v long ActivityManager:I *:S</span><br></pre></td></tr></table></figure><p> <strong>清空日志</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat -c</span><br></pre></td></tr></table></figure><h3 id="内核日志"><a href="#内核日志" class="headerlink" title="内核日志"></a>内核日志</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dmesg</span><br></pre></td></tr></table></figure><p> 输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs</span><br><span class="line">&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs</span><br><span class="line">&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs</span><br><span class="line">&lt;4&gt;[14201.755954] Restarting tasks ... done.</span><br><span class="line">&lt;6&gt;[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC</span><br><span class="line">&lt;6&gt;[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC</span><br><span class="line">&lt;6&gt;[14201.872498] PM: Syncing filesystems ... done.</span><br></pre></td></tr></table></figure><p> 中括号里的 [14201.684016] 代表内核开始启动后的时间，单位为秒。</p><p> 通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 Freeing init memory 那一行前面的时间就是。</p><h2 id="查看设备信息"><a href="#查看设备信息" class="headerlink" title="查看设备信息"></a>查看设备信息</h2><h3 id="型号"><a href="#型号" class="headerlink" title="型号"></a>型号</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop ro.product.model</span><br></pre></td></tr></table></figure><p> 输出示例：</p><p> Nexus 5</p><h3 id="电池状况"><a href="#电池状况" class="headerlink" title="电池状况"></a>电池状况</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys battery</span><br></pre></td></tr></table></figure><p> 输入示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Current Battery Service state:</span><br><span class="line">AC powered: false</span><br><span class="line">USB powered: true</span><br><span class="line">Wireless powered: false</span><br><span class="line">status: 2</span><br><span class="line">health: 2</span><br><span class="line">present: true</span><br><span class="line">level: 44</span><br><span class="line">scale: 100</span><br><span class="line">voltage: 3872</span><br><span class="line">temperature: 280</span><br><span class="line">technology: Li-poly</span><br></pre></td></tr></table></figure><p> 其中 scale 代表最大电量，level 代表当前电量。上面的输出表示还剩下 44% 的电量。</p><h3 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell wm size</span><br></pre></td></tr></table></figure><p> 输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Physical size: 1080x1920</span><br></pre></td></tr></table></figure><p> 该设备屏幕分辨率为 1080px * 1920px。</p><p> 如果使用命令修改过，那输出可能是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Physical size: 1080x1920</span><br><span class="line">Override size: 480x1024</span><br></pre></td></tr></table></figure><p> 表明设备的屏幕分辨率原本是 1080px <em> 1920px，当前被修改为 480px </em> 1024px。</p><h3 id="屏幕密度"><a href="#屏幕密度" class="headerlink" title="屏幕密度"></a>屏幕密度</h3><p> 命令：</p><p> adb shell wm density<br> 输出示例：</p><p> Physical density: 420<br> 该设备屏幕密度为 420dpi。</p><p> 如果使用命令修改过，那输出可能是：</p><p> Physical density: 480<br> Override density: 160<br> 表明设备的屏幕密度原来是 480dpi，当前被修改为 160dpi。</p><h3 id="显示屏参数"><a href="#显示屏参数" class="headerlink" title="显示屏参数"></a>显示屏参数</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys window displays</span><br></pre></td></tr></table></figure><p> 输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays)</span><br><span class="line">  Display: mDisplayId=0</span><br><span class="line">    init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731</span><br><span class="line">    deferred=false layoutNeeded=false</span><br></pre></td></tr></table></figure><p> 其中 mDisplayId 为 显示屏编号，init 是初始分辨率和屏幕密度，app 的高度比 init 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。</p><h3 id="android-id"><a href="#android-id" class="headerlink" title="android_id"></a>android_id</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings get secure android_id</span><br></pre></td></tr></table></figure><p> 输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">51b6be48bac8c569</span><br></pre></td></tr></table></figure><h3 id="IMEI"><a href="#IMEI" class="headerlink" title="IMEI"></a>IMEI</h3><p> 在 Android 4.4 及以下版本可通过如下命令获取 IMEI：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys iphonesubinfo</span><br></pre></td></tr></table></figure><p> 输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Phone Subscriber Info:</span><br><span class="line">  Phone Type = GSM</span><br><span class="line">  Device ID = 860955027785041</span><br><span class="line">其中的 Device ID 就是 IMEI。</span><br></pre></td></tr></table></figure><p> 而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">service call iphonesubinfo 1</span><br></pre></td></tr></table></figure><p> 输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Result: Parcel(</span><br><span class="line">  0x00000000: 00000000 0000000f 00360038 00390030 &apos;........8.6.0.9.&apos;</span><br><span class="line">  0x00000010: 00350035 00320030 00370037 00350038 &apos;5.5.0.2.7.7.8.5.&apos;</span><br><span class="line">  0x00000020: 00340030 00000031                   &apos;0.4.1...        &apos;)</span><br></pre></td></tr></table></figure><p> 把里面的有效内容提取出来就是 IMEI 了，比如这里的是 860955027785041。</p><p> 参考：adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop</p><h3 id="Android-系统版本"><a href="#Android-系统版本" class="headerlink" title="Android 系统版本"></a>Android 系统版本</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop ro.build.version.release</span><br></pre></td></tr></table></figure><p> 输出示例：</p><p> 5.0.2</p><h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p> 每次想知道设备的 IP 地址的时候都得「设置」-「关于手机」-「状态信息」-「IP地址」很烦对不对？通过 adb 可以方便地查看。</p><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell ifconfig | grep Mask</span><br></pre></td></tr></table></figure><p> 输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inet addr:10.130.245.230  Mask:255.255.255.252</span><br><span class="line">inet addr:127.0.0.1  Mask:255.0.0.0</span><br></pre></td></tr></table></figure><p> 那么 10.130.245.230 就是设备 IP 地址。</p><p> 在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 adb shell ifconfig wlan0例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wlan0: ip 10.129.160.99 mask 255.255.240.0 flags [up broadcast running multicast]</span><br></pre></td></tr></table></figure><p> 或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wlan0     Link encap:UNSPEC</span><br><span class="line">          inet addr:10.129.168.57  Bcast:10.129.175.255  Mask:255.255.240.0</span><br><span class="line">          inet6 addr: fe80::66cc:2eff:fe68:b6b6/64 Scope: Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:496520 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:68215 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:3000</span><br><span class="line">          RX bytes:116266821 TX bytes:8311736</span><br></pre></td></tr></table></figure><p> 如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell netcfg</span><br></pre></td></tr></table></figure><p> 输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">wlan0    UP                               10.129.160.99/20  0x00001043 f8:a9:d0:17:42:4d</span><br><span class="line">lo       UP                                   127.0.0.1/8   0x00000049 00:00:00:00:00:00</span><br><span class="line">p2p0     UP                                     0.0.0.0/0   0x00001003 fa:a9:d0:17:42:4d</span><br><span class="line">sit0     DOWN                                   0.0.0.0/0   0x00000080 00:00:00:00:00:00</span><br><span class="line">rmnet0   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet1   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet3   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet2   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet4   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet6   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet5   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet7   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rev_rmnet3 DOWN                                   0.0.0.0/0   0x00001002 4e:b7:e4:2e:17:58</span><br><span class="line">rev_rmnet2 DOWN                                   0.0.0.0/0   0x00001002 4e:f0:c8:bf:7a:cf</span><br><span class="line">rev_rmnet4 DOWN                                   0.0.0.0/0   0x00001002 a6:c0:3b:6b:c4:1f</span><br><span class="line">rev_rmnet6 DOWN                                   0.0.0.0/0   0x00001002 66:bb:5d:64:2e:e9</span><br><span class="line">rev_rmnet5 DOWN                                   0.0.0.0/0   0x00001002 0e:1b:eb:b9:23:a0</span><br><span class="line">rev_rmnet7 DOWN                                   0.0.0.0/0   0x00001002 7a:d9:f6:81:40:5a</span><br><span class="line">rev_rmnet8 DOWN                                   0.0.0.0/0   0x00001002 4e:e2:a9:bb:d0:1b</span><br><span class="line">rev_rmnet0 DOWN                                   0.0.0.0/0   0x00001002 fe:65:d0:ca:82:a9</span><br><span class="line">rev_rmnet1 DOWN                                   0.0.0.0/0   0x00001002 da:d8:e8:4f:2e:fe</span><br></pre></td></tr></table></figure><p> 可以看到网络连接名称、启用状态、IP 地址和 Mac 地址等信息。</p><h3 id="Mac-地址"><a href="#Mac-地址" class="headerlink" title="Mac 地址"></a>Mac 地址</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /sys/class/net/wlan0/address</span><br></pre></td></tr></table></figure><p> 输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f8:a9:d0:17:42:4d</span><br></pre></td></tr></table></figure><p> 这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 adb shell netcfg 命令来查看。</p><h3 id="CPU-信息"><a href="#CPU-信息" class="headerlink" title="CPU 信息"></a>CPU 信息</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /proc/cpuinfo</span><br></pre></td></tr></table></figure><p> 输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Processor       : ARMv7 Processor rev 0 (v7l)</span><br><span class="line">processor       : 0</span><br><span class="line">BogoMIPS        : 38.40</span><br><span class="line"></span><br><span class="line">processor       : 1</span><br><span class="line">BogoMIPS        : 38.40</span><br><span class="line"></span><br><span class="line">processor       : 2</span><br><span class="line">BogoMIPS        : 38.40</span><br><span class="line"></span><br><span class="line">processor       : 3</span><br><span class="line">BogoMIPS        : 38.40</span><br><span class="line"></span><br><span class="line">Features        : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt</span><br><span class="line">CPU implementer : 0x51</span><br><span class="line">CPU architecture: 7</span><br><span class="line">CPU variant     : 0x2</span><br><span class="line">CPU part        : 0x06f</span><br><span class="line">CPU revision    : 0</span><br><span class="line"></span><br><span class="line">Hardware        : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)</span><br><span class="line">Revision        : 000b</span><br><span class="line">Serial          : 0000000000000000</span><br></pre></td></tr></table></figure><p> 这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是 Qualcomm MSM 8974，processor 的编号是 0 到 3，所以它是四核的，采用的架构是 ARMv7 Processor rev 0 (v71)。</p><h3 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /proc/meminfo</span><br></pre></td></tr></table></figure><p> 输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">MemTotal:        1027424 kB</span><br><span class="line">MemFree:          486564 kB</span><br><span class="line">Buffers:           15224 kB</span><br><span class="line">Cached:            72464 kB</span><br><span class="line">SwapCached:        24152 kB</span><br><span class="line">Active:           110572 kB</span><br><span class="line">Inactive:         259060 kB</span><br><span class="line">Active(anon):      79176 kB</span><br><span class="line">Inactive(anon):   207736 kB</span><br><span class="line">Active(file):      31396 kB</span><br><span class="line">Inactive(file):    51324 kB</span><br><span class="line">Unevictable:        3948 kB</span><br><span class="line">Mlocked:               0 kB</span><br><span class="line">HighTotal:        409600 kB</span><br><span class="line">HighFree:         132612 kB</span><br><span class="line">LowTotal:         617824 kB</span><br><span class="line">LowFree:          353952 kB</span><br><span class="line">SwapTotal:        262140 kB</span><br><span class="line">SwapFree:         207572 kB</span><br><span class="line">Dirty:                 0 kB</span><br><span class="line">Writeback:             0 kB</span><br><span class="line">AnonPages:        265324 kB</span><br><span class="line">Mapped:            47072 kB</span><br><span class="line">Shmem:              1020 kB</span><br><span class="line">Slab:              57372 kB</span><br><span class="line">SReclaimable:       7692 kB</span><br><span class="line">SUnreclaim:        49680 kB</span><br><span class="line">KernelStack:        4512 kB</span><br><span class="line">PageTables:         5912 kB</span><br><span class="line">NFS_Unstable:          0 kB</span><br><span class="line">Bounce:                0 kB</span><br><span class="line">WritebackTmp:          0 kB</span><br><span class="line">CommitLimit:      775852 kB</span><br><span class="line">Committed_AS:   13520632 kB</span><br><span class="line">VmallocTotal:     385024 kB</span><br><span class="line">VmallocUsed:       61004 kB</span><br><span class="line">VmallocChunk:     209668 kB</span><br></pre></td></tr></table></figure><p> 其中，MemTotal 就是设备的总内存，MemFree 是当前空闲内存。</p><h3 id="更多硬件与系统属性"><a href="#更多硬件与系统属性" class="headerlink" title="更多硬件与系统属性"></a>更多硬件与系统属性</h3><p> 设备的更多硬件与系统属性可以通过如下命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /system/build.prop</span><br></pre></td></tr></table></figure><p> 这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。</p><p> 输出里还包括一些其它有用的信息，它们也可通过 adb shell getprop &lt;属性名&gt; 命令单独查看，列举一部分属性如下：</p><pre><code>属性名                             | 含义                 ------------------------------- | -------------------ro.build.version.sdk            | SDK 版本             ro.build.version.release        | Android 系统版本       ro.build.version.security_patch | Android 安全补丁程序级别   ro.product.model                | 型号                 ro.product.brand                | 品牌                 ro.product.name                 | 设备名                ro.product.board                | 处理器型号              ro.product.cpu.abilist          | CPU 支持的 abi 列表[节注一]persist.sys.isUsbOtgEnabled     | 是否支持 OTG           dalvik.vm.heapsize              | 每个应用程序的内存上限        ro.sf.lcd_density               | 屏幕密度               </code></pre><p> <strong>节注一：</strong></p><p> 一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 ro.product.cpu.abilist 属性名查找不到，可以这样试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /system/build.prop | grep ro.product.cpu.abi</span><br></pre></td></tr></table></figure><p> 示例输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ro.product.cpu.abi=armeabi-v7a</span><br><span class="line">ro.product.cpu.abi2=armeabi</span><br></pre></td></tr></table></figure><h2 id="修改设置"><a href="#修改设置" class="headerlink" title="修改设置"></a>修改设置</h2><p> <em>注： 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 adb reboot 重启设备，或手动重启。</em></p><p> 修改设置的原理主要是通过 settings 命令修改 /data/data/com.android.providers.settings/databases/settings.db 里存放的设置值。</p><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell wm size 480x1024</span><br></pre></td></tr></table></figure><p> 表示将分辨率修改为 480px * 1024px。</p><p> 恢复原分辨率命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell wm size reset</span><br></pre></td></tr></table></figure><h3 id="屏幕密度-1"><a href="#屏幕密度-1" class="headerlink" title="屏幕密度"></a>屏幕密度</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell wm density 160</span><br></pre></td></tr></table></figure><p> 表示将屏幕密度修改为 160dpi。</p><p> 恢复原屏幕密度命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell wm density reset</span><br></pre></td></tr></table></figure><h3 id="显示区域"><a href="#显示区域" class="headerlink" title="显示区域"></a>显示区域</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell wm overscan 0,0,0,200</span><br></pre></td></tr></table></figure><p> 四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。</p><p> 恢复原显示区域命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell wm overscan reset</span><br></pre></td></tr></table></figure><h3 id="关闭-USB-调试模式"><a href="#关闭-USB-调试模式" class="headerlink" title="关闭 USB 调试模式"></a>关闭 USB 调试模式</h3><p> 命令：</p><p> adb shell settings put global adb_enabled 0<br> 恢复：</p><p> 用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。</p><p> 去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。</p><h3 id="状态栏和导航栏的显示隐藏"><a href="#状态栏和导航栏的显示隐藏" class="headerlink" title="状态栏和导航栏的显示隐藏"></a>状态栏和导航栏的显示隐藏</h3><p> 本节所说的相关设置对应 Cyanogenmod 里的「扩展桌面」。</p><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings put global policy_control &lt;key-values&gt;</span><br></pre></td></tr></table></figure><p> <code>&lt;key-values&gt;</code>  可由如下几种键及其对应的值组成，格式为  <code>&lt;key1&gt;=&lt;value1&gt;:&lt;key2&gt;=&lt;value2&gt;</code> 。</p><pre><code>key                   | 含义   --------------------- | -----immersive.full        | 同时隐藏immersive.status      | 隐藏状态栏immersive.navigation  | 隐藏导航栏immersive.preconfirms | ?    </code></pre><p> 这些键对应的值可则如下值用逗号组合：</p><pre><code>value        | 含义    ------------ | ------apps         | 所有应用  *            | 所有界面  packagename  | 指定应用  -packagename | 排除指定应用</code></pre><p> 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings put global policy_control immersive.full=*</span><br></pre></td></tr></table></figure><p> 表示设置在所有界面下都同时隐藏状态栏和导航栏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3</span><br></pre></td></tr></table></figure><p> 表示设置在包名为 com.package1 和 com.package2 的应用里隐藏状态栏，在除了包名为 com.package3 的所有应用里隐藏导航栏。</p><h4 id="恢复正常模式"><a href="#恢复正常模式" class="headerlink" title="恢复正常模式"></a>恢复正常模式</h4><p> 不想全屏了咋办呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings put global policy_control null</span><br></pre></td></tr></table></figure><h2 id="实用功能"><a href="#实用功能" class="headerlink" title="实用功能"></a>实用功能</h2><h3 id="屏幕截图"><a href="#屏幕截图" class="headerlink" title="屏幕截图"></a>屏幕截图</h3><p> <strong>截图保存到电脑：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb exec-out screencap -p &gt; sc.png</span><br></pre></td></tr></table></figure><p> 如果 adb 版本较老，无法使用 exec-out 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法：</p><p> 先截图保存到设备里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell screencap -p /sdcard/sc.png</span><br></pre></td></tr></table></figure><p> 然后将 png 文件导出到电脑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /sdcard/sc.png</span><br></pre></td></tr></table></figure><p> 可以使用 adb shell screencap -h 查看 screencap 命令的帮助信息，下面是两个有意义的参数及含义：</p><pre><code>参数            | 含义                   ------------- | ----------------------p            | 指定保存文件为 png 格式       -d display-id | 指定截图的显示屏编号（有多显示屏的情况下）</code></pre><p> 实测如果指定文件名以 .png 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。</p><p> <strong>另外一种一行命令截图并保存到电脑的方法：</strong></p><p> Linux 和 Windows</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell screencap -p | sed &quot;s/\r$//&quot; &gt; sc.png</span><br></pre></td></tr></table></figure><p> Mac OS X</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell screencap -p | gsed &quot;s/\r$//&quot; &gt; sc.png</span><br></pre></td></tr></table></figure><p> 这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 sed for Windows 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。</p><p> 而在 Mac 下使用系统自带的 sed 命令会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed: RE error: illegal byte sequence</span><br></pre></td></tr></table></figure><p> 需要安装 gnu-sed，然后使用 gsed 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install gnu-sed</span><br></pre></td></tr></table></figure><h3 id="录制屏幕"><a href="#录制屏幕" class="headerlink" title="录制屏幕"></a>录制屏幕</h3><p> 录制屏幕以 mp4 格式保存到 /sdcard：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell screenrecord /sdcard/filename.mp4</span><br></pre></td></tr></table></figure><p> 需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。</p><p> 如果需要导出到电脑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /sdcard/filename.mp4</span><br></pre></td></tr></table></figure><p> 可以使用 adb shell screenrecord –help 查看 screenrecord 命令的帮助信息，下面是常见参数及含义：</p><pre><code>参数                 | 含义                         ------------------ | ---------------------------–size WIDTHxHEIGHT | 视频的尺寸，比如 1280x720，默认是屏幕分辨率。–bit-rate RATE     | 视频的比特率，默认是 4Mbps。          –time-limit TIME   | 录制时长，单位秒。                  –verbose           | 输出更多信息。                    </code></pre><p> <strong>重新挂载 system 分区为可写</strong></p><p> <em>注：需要 root 权限。</em></p><p> /system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 /system 进行写操作，所以需要重新挂载它为可读写。</p><p> 步骤：</p><p> 进入 shell 并切换到 root 用户权限。</p><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br></pre></td></tr></table></figure><p> 查看当前分区挂载情况。</p><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount</span><br></pre></td></tr></table></figure><p> 输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">rootfs / rootfs ro,relatime 0 0</span><br><span class="line">tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0</span><br><span class="line">devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0</span><br><span class="line">proc /proc proc rw,relatime 0 0</span><br><span class="line">sysfs /sys sysfs rw,seclabel,relatime 0 0</span><br><span class="line">selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0</span><br><span class="line">debugfs /sys/kernel/debug debugfs rw,relatime 0 0</span><br><span class="line">none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0</span><br><span class="line">none /acct cgroup rw,relatime,cpuacct 0 0</span><br><span class="line">none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0</span><br><span class="line">none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0</span><br><span class="line">tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0</span><br><span class="line">tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0</span><br><span class="line">none /dev/memcg cgroup rw,relatime,memory 0 0</span><br><span class="line">none /dev/cpuctl cgroup rw,relatime,cpu 0 0</span><br><span class="line">none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0</span><br><span class="line">none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0</span><br><span class="line">none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0</span><br><span class="line">/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0</span><br><span class="line">/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0</span><br></pre></td></tr></table></figure><p> 找到其中我们关注的带 /system 的那一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0</span><br></pre></td></tr></table></figure><h3 id="重新挂载。"><a href="#重新挂载。" class="headerlink" title="重新挂载。"></a>重新挂载。</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system</span><br></pre></td></tr></table></figure><p> 这里的 /dev/block/platform/msm_sdcc.1/by-name/system 就是我们从上一步的输出里得到的文件路径。</p><p> 如果输出没有提示错误的话，操作就成功了，可以对 /system 下的文件为所欲为了。</p><h3 id="查看连接过的-WiFi-密码"><a href="#查看连接过的-WiFi-密码" class="headerlink" title="查看连接过的 WiFi 密码"></a>查看连接过的 WiFi 密码</h3><p> <em>注：需要 root 权限。</em></p><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">cat /data/misc/wifi/*.conf</span><br></pre></td></tr></table></figure><p> 输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">network=&#123;</span><br><span class="line">    ssid=&quot;TP-LINK_9DFC&quot;</span><br><span class="line">    scan_ssid=1</span><br><span class="line">    psk=&quot;123456789&quot;</span><br><span class="line">    key_mgmt=WPA-PSK</span><br><span class="line">    group=CCMP TKIP</span><br><span class="line">    auth_alg=OPEN</span><br><span class="line">    sim_num=1</span><br><span class="line">    priority=13893</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">    ssid=&quot;TP-LINK_F11E&quot;</span><br><span class="line">    psk=&quot;987654321&quot;</span><br><span class="line">    key_mgmt=WPA-PSK</span><br><span class="line">    sim_num=1</span><br><span class="line">    priority=17293</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ssid 即为我们在 WLAN 设置里看到的名称，psk 为密码，key_mgmt 为安全加密方式。</p><h3 id="设置系统日期和时间"><a href="#设置系统日期和时间" class="headerlink" title="设置系统日期和时间"></a>设置系统日期和时间</h3><p> <em>注：需要 root 权限。</em></p><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">date -s 20160823.131500</span><br></pre></td></tr></table></figure><p> 表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。</p><h3 id="重启手机"><a href="#重启手机" class="headerlink" title="重启手机"></a>重启手机</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot</span><br></pre></td></tr></table></figure><h3 id="检测设备是否已-root"><a href="#检测设备是否已-root" class="headerlink" title="检测设备是否已 root"></a>检测设备是否已 root</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br></pre></td></tr></table></figure><p> 此时命令行提示符是 $ 则表示没有 root 权限，是 # 则表示已 root。</p><h3 id="使用-Monkey-进行压力测试"><a href="#使用-Monkey-进行压力测试" class="headerlink" title="使用 Monkey 进行压力测试"></a>使用 Monkey 进行压力测试</h3><p> Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。</p><p> 简单用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -p &lt;packagename&gt; -v 500</span><br></pre></td></tr></table></figure><p> 表示向  <code>&lt;packagename&gt;</code>  指定的应用程序发送 500 个伪随机事件。</p><p> Monkey 的详细用法参考 官方文档。</p><h3 id="开启-关闭-WiFi"><a href="#开启-关闭-WiFi" class="headerlink" title="开启/关闭 WiFi"></a>开启/关闭 WiFi</h3><p> 注：需要 root 权限。</p><p> 有时需要控制设备的 WiFi 状态，可以用以下指令完成。</p><p> 开启 WiFi：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell svc wifi enable</span><br></pre></td></tr></table></figure><p> 关闭 WiFi：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell svc wifi disable</span><br></pre></td></tr></table></figure><p> 若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 Killed。</p><h2 id="刷机相关命令"><a href="#刷机相关命令" class="headerlink" title="刷机相关命令"></a>刷机相关命令</h2><h3 id="重启到-Recovery-模式"><a href="#重启到-Recovery-模式" class="headerlink" title="重启到 Recovery 模式"></a>重启到 Recovery 模式</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot recovery</span><br></pre></td></tr></table></figure><h3 id="从-Recovery-重启到-Android"><a href="#从-Recovery-重启到-Android" class="headerlink" title="从 Recovery 重启到 Android"></a>从 Recovery 重启到 Android</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot</span><br></pre></td></tr></table></figure><h3 id="重启到-Fastboot-模式"><a href="#重启到-Fastboot-模式" class="headerlink" title="重启到 Fastboot 模式"></a>重启到 Fastboot 模式</h3><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure><h3 id="通过-sideload-更新系统"><a href="#通过-sideload-更新系统" class="headerlink" title="通过 sideload 更新系统"></a>通过 sideload 更新系统</h3><p> 如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。</p><p> 以 Recovery 模式下更新为例：</p><p> 重启到 Recovery 模式。</p><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot recovery</span><br></pre></td></tr></table></figure><p> 在设备的 Recovery 界面上操作进入 Apply update-Apply from ADB。</p><p> <em>注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 Apply update from ADB。</em></p><p> <strong>通过 adb 上传和更新系统。</strong></p><p> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb sideload &lt;path-to-update.zip&gt;</span><br></pre></td></tr></table></figure><h3 id="更多-adb-shell-命令"><a href="#更多-adb-shell-命令" class="headerlink" title="更多 adb shell 命令"></a>更多 adb shell 命令</h3><p> Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 adb shell 里可以调用。本文档前面的部分内容已经用到了 adb shell 命令。</p><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell ps</span><br></pre></td></tr></table></figure><p> 例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">USER     PID   PPID  VSIZE  RSS     WCHAN    PC        NAME</span><br><span class="line">root      1     0     8904   788   ffffffff 00000000 S /init</span><br><span class="line">root      2     0     0      0     ffffffff 00000000 S kthreadd</span><br><span class="line">...</span><br><span class="line">u0_a71    7779  5926  1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classic</span><br><span class="line">u0_a58    7963  5926  1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure</span><br><span class="line">...</span><br><span class="line">shell     8750  217   10640  740   00000000 b6f28340 R ps</span><br></pre></td></tr></table></figure><p> 各列含义：</p><pre><code>列名   | 含义    ---- | ------USER | 所属用户  PID  | 进程 IDPPID | 父进程 IDNAME | 进程名   </code></pre><h3 id="查看实时资源占用情况"><a href="#查看实时资源占用情况" class="headerlink" title="查看实时资源占用情况"></a>查看实时资源占用情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell top</span><br></pre></td></tr></table></figure><p> 例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">User 0%, System 6%, IOW 0%, IRQ 0%</span><br><span class="line">User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307</span><br><span class="line"></span><br><span class="line">  PID PR CPU% S  #THR     VSS     RSS PCY UID      Name</span><br><span class="line"> 8763  0   3% R     1  10640K   1064K  fg shell    top</span><br><span class="line">  131  0   3% S     1      0K      0K  fg root     dhd_dpc</span><br><span class="line"> 6144  0   0% S   115 1682004K 115916K  fg system   system_server</span><br><span class="line">  132  0   0% S     1      0K      0K  fg root     dhd_rxf</span><br><span class="line"> 1731  0   0% S     6  20288K    788K  fg root     /system/bin/mpdecision</span><br><span class="line">  217  0   0% S     6  18008K    356K  fg shell    /sbin/adbd</span><br><span class="line"> ...</span><br><span class="line"> 7779  2   0% S    19 1538748K  48896K  bg u0_a71   com.sohu.inputmethod.sogou:classic</span><br><span class="line"> 7963  0   0% S    18 1561916K  59568K  fg u0_a58   org.mazhuang.boottimemeasure</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p> 各列含义：</p><pre><code>列名   | 含义                                    ---- | --------------------------------------PID  | 进程 ID                                 PR   | 优先级                                   CPU% | 当前瞬间占用 CPU 百分比                        S    | 进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程）        #THR | 线程数                                   VSS  | Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）   RSS  | Resident Set Size 实际使用物理内存（包含共享库占用的内存）PCY  | 调度策略优先级，SP_BACKGROUND/SPFOREGROUND    UID  | 进程所有者的用户 ID                           NAME | 进程名                                   </code></pre><p> top 命令还支持一些命令行参数，详细用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ]</span><br><span class="line">    -m num  最多显示多少个进程</span><br><span class="line">    -n num  刷新多少次后退出</span><br><span class="line">    -d num  刷新时间间隔（单位秒，默认值 5）</span><br><span class="line">    -s col  按某列排序（可用 col 值：cpu, vss, rss, thr）</span><br><span class="line">    -t      显示线程信息</span><br><span class="line">    -h      显示帮助文档</span><br></pre></td></tr></table></figure><h3 id="查看进程-UID"><a href="#查看进程-UID" class="headerlink" title="查看进程 UID"></a>查看进程 UID</h3><p> 有两种方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys package &lt;packagename&gt; | grep userId=</span><br></pre></td></tr></table></figure><p> 如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell dumpsys package org.mazhuang.guanggoo | grep userId=</span><br><span class="line">   userId=10394</span><br></pre></td></tr></table></figure><p> 通过 ps 命令找到对应进程的 pid 之后  <code>adb shell cat /proc/&lt;pid&gt;/status | grep Uid</code></p><p> 如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell</span><br><span class="line">gemini:/ $ ps | grep org.mazhuang.guanggoo</span><br><span class="line">u0_a394   28635 770   1795812 78736 SyS_epoll_ 0000000000 S org.mazhuang.guanggoo</span><br><span class="line">gemini:/ $ cat /proc/28635/status | grep Uid</span><br><span class="line">Uid:    10394   10394   10394   10394</span><br><span class="line">gemini:/ $</span><br></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p> 如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明：</p><pre><code>命令    | 功能            ----- | --------------cat   | 显示文件内容        cd    | 切换目录          chmod | 改变文件的存取模式/访问权限df    | 查看磁盘空间使用情况    grep  | 过滤输出          kill  | 杀死指定 PID 的进程  ls    | 列举目录内容        mount | 挂载目录的查看和管理    mv    | 移动或重命名文件      ps    | 查看正在运行的进程     rm    | 删除文件          top   | 查看进程的资源占用情况   </code></pre><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="启动-adb-server-失败"><a href="#启动-adb-server-失败" class="headerlink" title="启动 adb server 失败"></a>启动 adb server 失败</h3><p> 出错提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: protocol fault (couldn&apos;t read status): No error</span><br></pre></td></tr></table></figure><p> 可能原因</p><p> adb server 进程想使用的 5037 端口被占用。</p><p> 解决方案</p><p> 找到占用 5037 端口的进程，然后终止它。以 Windows 下为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr LISTENING</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">TCP    0.0.0.0:5037           0.0.0.0:0              LISTENING       1548</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p> 这里 1548 即为进程 ID，用命令结束该进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /PID 1548</span><br></pre></td></tr></table></figure><p> 然后再启动 adb 就没问题了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;adb-命令大全&quot;&gt;&lt;a href=&quot;#adb-命令大全&quot; class=&quot;headerlink&quot; title=&quot;adb 命令大全&quot;&gt;&lt;/a&gt;adb 命令大全&lt;/h2&gt;&lt;p&gt;转自 &lt;a href=&quot;https://blog.csdn.net/zhonglunshun
      
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="adb" scheme="http://yoursite.com/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>dex学习和探究</title>
    <link href="http://yoursite.com/2018/12/25/dex%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%8E%A2%E7%A9%B6/"/>
    <id>http://yoursite.com/2018/12/25/dex学习和探究/</id>
    <published>2018-12-25T11:21:08.000Z</published>
    <updated>2018-12-25T12:54:29.327Z</updated>
    
    <content type="html"><![CDATA[<h3 id="dex学习和探究"><a href="#dex学习和探究" class="headerlink" title="dex学习和探究"></a>dex学习和探究</h3><p><strong>一．    Dex是什么</strong></p><p>Dex (Dalvik Executable Format)是java中存储类定义和相关联数据的一种数据格式，主要用于保存类定义及其关联的辅助数据</p><p>.dex结构分成三部分:<br><strong>文件头</strong>:表明了是dex文件，已经文件的大小等等数据<br><strong>索引头</strong>:如下图所示<br><strong>数据区</strong>：数据区,就像是jvm中的堆保存方法+变量。</p><p>下面是dex的数据格式：<br><img src="/blog/2018/12/25/dex学习和探究/data.jpg" alt="数据格式"></p><blockquote><p><strong>odex简介</strong><br>odex是OptimizedDEX的缩写,表示对dex的优化。系统预置应用经常会采用odex的方式加载，一般存放在/data/dalvik-cache目录下。</p><p>由于Android程序的apk文件为zip压缩包格式，Dalvik虚拟机每次加载它们时需要从apk中读取classes.dex文件，这样会耗费很多cpu时间，而采用odex方式优化的dex文件，已经包含了加载dex必须的依赖库文件列表，Dalvik虚拟机只需检测并加载所需的依赖库即可执行相应的dex文件，这大大缩短了读取dex文件所需的时间。</p><p>不过，这个优化过程会根据不同设备上Dalvik虚拟机的版本、Framework库的不同等因素而不同。在一台设备上被优化过的ODEX文件，拷贝到另一台设备上不一定能够运行。</p></blockquote><p><strong>二．    Dex的加载流程</strong></p><p>&emsp;&emsp; Android提供了一个专门验证与优化dex文件的工具dexopt。其源码位于Android系统源码的dalvik/dexopt目录下，Dalvik虚拟机在加载一个dex文件时，通过指定的验证与优化选项来调用dexopt进行相应的验证与优化操作。<a href="https://blog.csdn.net/jltxgcy/article/details/50552674" target="_blank" rel="noopener">具体加载流程参考</a></p><p><img src="/blog/2018/12/25/dex学习和探究/verify.jpg" alt="加载验证"></p><p>&emsp;&emsp; 简要总结下整个的加载流程，首先是对文件名的修正，后缀名置为”.dex”作为输出文件，然后生个一个DexPathList对象函数直接返回一个DexPathList对象，</p><p>&emsp;&emsp; 在DexPathList的构造函数中调用makeDexElements()函数，在makeDexElement()函数中调用loadDexFile()开始对.dex或者是.jar .zip .apk文件进行处理，跟入loadDexFile()函数中，会发现里面做的工作很简单，调用optimizedPathFor()函数对optimizedDiretcory路径进行修正。</p><p><img src="/blog/2018/12/25/dex学习和探究/load1.jpg" alt="加载验证"><br>&emsp;&emsp; 之后才真正通过DexFile.loadDex()开始加载文件中的数据，其中的加载也只是返回一个DexFile对象。</p><p>&emsp;&emsp; 在DexFile类的构造函数中，重点便放在了其调用的openDexFile()函数，在openDexFile()中调用了openDexFileNative()真正进入native层，在openDexFileNative()的真正实现中，对于后缀名为.dex的文件或者其他文件(.jar .apk .zip)分开进行处理：</p><p>&emsp;&emsp; .dex文件调用dvmRawDexFileOpen()；<br>&emsp;&emsp; 其他文件调用dvmJarFileOpen()。</p><p><img src="/blog/2018/12/25/dex学习和探究/load2.jpg" alt="加载dex"></p><p>&emsp;&emsp; 在dvmRawDexFileOpen()函数中，检验dex文件的标志，检验odex文件的缓存名称，之后将dex文件拷贝到odex文件中，并对odex进行优化。</p><p>&emsp;&emsp; 调用dvmDexFileOpenFromFd()对优化后的odex文件进行映射，通过mprotect置为”只读”属性并将映射的内存结构保存在DvmDex*结构中。</p><p>&emsp;&emsp; dvmJarFileOpen()先对文件进行映射，结构保存在ZipArchive中，然后再尝试以文件名作为dex文件名来“打开”文件，如果失败，则调用dexZipFindEntry在ZipArchive的名称hash表中找名为”class.dex”的文件,然后创建odex文件，下面就和dvmRawDexFileOpen()一样了，就是对dex文件进行优化和映射。</p><p>最关键的loadDexFile和optimizedPathFor方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private static DexFile loadDexFile(File file, File optimizedDirectory)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line">        if (optimizedDirectory == null) &#123;</span><br><span class="line">            return new DexFile(file);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String optimizedPath = optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">            return DexFile.loadDex(file.getPath(), optimizedPath, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//生成odex的目录</span><br><span class="line">private static String optimizedPathFor(File path,</span><br><span class="line">            File optimizedDirectory) &#123;</span><br><span class="line">        String fileName = path.getName();</span><br><span class="line">        if (!fileName.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">            int lastDot = fileName.lastIndexOf(&quot;.&quot;);</span><br><span class="line">            if (lastDot &lt; 0) &#123;</span><br><span class="line">                fileName += DEX_SUFFIX;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                StringBuilder sb = new StringBuilder(lastDot + 4);</span><br><span class="line">                sb.append(fileName, 0, lastDot);</span><br><span class="line">                sb.append(DEX_SUFFIX);</span><br><span class="line">                fileName = sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        File result = new File(optimizedDirectory, fileName);</span><br><span class="line">        return result.getPath();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp; optimizedPathFor 方法：就是将dex 优化形成optimizedDex文件。然后<br>通过DexFile的静态方法将.dex文件。或者apk，.jar加载成DexFile文件。DexFile 是C语言中的结构体，里面保存的都是一些指针。经过不断的校检，最后通过dvm里面的c代码处理，得到DexFile。</p><p><strong>三．    Dex的应用场景</strong><br>&emsp;&emsp;  结合dex的支持动态加载的特性，dex通常被用于以下场合：</p><ol><li><p><strong>MultiDex分包</strong>： 拆分dex，可以解决方法数超过65535导致的编译问题。也支持分包后再Application的onCreate()方法中调用 <strong>MultiDex.install(this)</strong>来加载不同的dex包。</p><blockquote><p>可以用于解决2.3上无法安装问题<br> INSTALL_FAILED_DEXOPT</p></blockquote><blockquote><p>可以解决方法数过多问题：<br> Conversion to Dalvik format failed:Unable to execute dex: method ID not in [0, 0xffff]: 65536</p></blockquote></li><li><p><strong>应用热更新</strong>： 参考腾讯的<a href="https://github.com/Tencent/tinker" target="_blank" rel="noopener">tinker</a>方案。tinker的核心思想是利用DexDiff算法对比差异生成Patch补丁包，全量合成新Dex进行整体替换。这里面就涉及到dex的具体加载过程中，很重要的一个特点，在DexPathList加载类时，会遍历dexElements数组，ClassLoader在加载到正确的类之后就会停止加载此类，基于这个原理，可以用来做应用的局部热更新。tinker是在这个基础上增加了差量包的定义，引入了自定义的 <a href="https://www.jianshu.com/p/af784b20cee5" target="_blank" rel="noopener">dexdiff算法</a>。</p></li><li><p><strong>插件化</strong>：动态加载模块，参见于广点通sdk方案。将包含dex的jar放到asset目录下，动态加载函数类，而不用安装独立的应用。该方案可以用于广告sdk，应用插件等开发，采用动态加载dex，通常会将dex文件下载放置于data目录而不是sd卡目录（sd卡不安全），并且采用加密算法进行dex的内部加密，支持动态下载更新dex文件，提升了代码破解难度，增加了apk的运维可能。</p><p><img src="/blog/2018/12/25/dex学习和探究/gdt.png" alt="广点通动态加载"></p></li></ol><ol start="4"><li><strong>应用加固和脱壳</strong>： 这方面没有过多涉猎，有空可以学习下<a href="https://blog.csdn.net/mergerly/article/details/62045535" target="_blank" rel="noopener">mergerly整理的加固脱壳方法</a></li></ol><p><strong>四．    Dex方案的优劣</strong></p><p>&emsp;&emsp;可能带来的问题：</p><ol><li><p>MultiDex分包可能增加进入耗时，dex文件不能过大，否则容易在进入加载dex时出现anr或异常。</p></li><li><p>可能引入一些加载异常：</p><blockquote><p>ClassNotFoundException: Didn’t find class “com.squareup.picasso.Picasso” on path: DexPathList[[zip file “/data/app/com.groupon.dexlazyload-1/base.apk”]</p></blockquote></li><li><p>增加了<a href="https://www.cnblogs.com/goodhacker/p/5152952.html" target="_blank" rel="noopener">代码注入和应用劫持的风险</a></p></li></ol><p>&emsp;&emsp;优点：</p><ol><li><p>支持热更新和热修复，避免整体apk更新带来的流量问题和迭代问题。</p></li><li><p>支持dex加固，一定程度上增加了apk被反编译破解带来的风险。</p></li><li><p>允许动态加载指定的dex内的函数。</p></li></ol><p><strong>五．    tqy dex加载分析</strong><br>&emsp;&emsp; tqy sdk的初始化中会调用initSdk，</p><p>&emsp;&emsp;校验文件：<br>  <img src="/blog/2018/12/25/dex学习和探究/tqy-1.png" alt="tqy加载"></p><p>  &emsp;&emsp;加载dex<br>  <img src="/blog/2018/12/25/dex学习和探究/tqy-2.png" alt="tqy加载"></p><p>  具体的dex文件被放置到： /data/user/0/com.tqy.sdk.ad/ 目录上：<br>  <img src="/blog/2018/12/25/dex学习和探究/tqy-3.png" alt="tqy加载"></p><p>  在通过dex文件的md5校验，之后加载类实例，覆盖原有的register方法，jar包中清晰可见在原有的基础上增加了adServiceLogic的实现。</p><p>  <img src="/blog/2018/12/25/dex学习和探究/tqy-4.png" alt="tqy加载"></p><p>  也意味着原有的方法只提供了基础的方法名称，在dex中才是方法的真正实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;dex学习和探究&quot;&gt;&lt;a href=&quot;#dex学习和探究&quot; class=&quot;headerlink&quot; title=&quot;dex学习和探究&quot;&gt;&lt;/a&gt;dex学习和探究&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;一．    Dex是什么&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dex (Dalv
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>UE16禁止显示切换</title>
    <link href="http://yoursite.com/2018/12/14/UE16%E7%A6%81%E6%AD%A2%E6%98%BE%E7%A4%BA%E5%88%87%E6%8D%A2/"/>
    <id>http://yoursite.com/2018/12/14/UE16禁止显示切换/</id>
    <published>2018-12-14T03:49:12.000Z</published>
    <updated>2018-12-14T03:50:53.714Z</updated>
    
    <content type="html"><![CDATA[<p>1) 按 ctrl+N ,新建一个文件<br>2) 输入一个空格<br>3）按ctrl + H,切换到十六进制查看模式，这是显示的是：<br>0000000h:20<br>4) 修改第一个 20为34，然后接着输入 44 45 44 45 44 46 34<br>5) 按ctrl + H,切换到普通查看模式，就可以看到字符显示<br>34 44 45 44 45 44 46 34 对应 4DEDEDF4</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1) 按 ctrl+N ,新建一个文件&lt;br&gt;2) 输入一个空格&lt;br&gt;3）按ctrl + H,切换到十六进制查看模式，这是显示的是：&lt;br&gt;0000000h:20&lt;br&gt;4) 修改第一个 20为34，然后接着输入 44 45 44 45 44 46 34&lt;br&gt;5) 按c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通过ttl 判断经过多少路由</title>
    <link href="http://yoursite.com/2018/08/24/%E9%80%9A%E8%BF%87ttl-%E5%88%A4%E6%96%AD%E7%BB%8F%E8%BF%87%E5%A4%9A%E5%B0%91%E8%B7%AF%E7%94%B1/"/>
    <id>http://yoursite.com/2018/08/24/通过ttl-判断经过多少路由/</id>
    <published>2018-08-24T11:30:35.000Z</published>
    <updated>2018-08-24T11:53:17.012Z</updated>
    
    <content type="html"><![CDATA[<p>当我们访问某个网络时，通过tracert命令，就能知道本机与目标主机之间经过多台主机，</p><p>即经过多少路由。</p><hr><p>eg:</p><p>C:\Users\acer&gt;tracert <a href="http://www.datang.com" target="_blank" rel="noopener">www.datang.com</a></p><p>通过最多 30 个跃点跟踪<br>到 <a href="http://www.datang.com" target="_blank" rel="noopener">www.datang.com</a> [219.141.223.5] 的路由:</p><p>  1     1 ms    &lt;1 毫秒   &lt;1 毫秒 221.206.0.220<br>  2     2 ms     1 ms     1 ms  221.206.1.41<br>  3     9 ms     6 ms     8 ms  60.14.244.45<br>  4    25 ms    27 ms    27 ms  219.158.19.41<br>  5    29 ms    27 ms    25 ms  219.158.101.114<br>  6     <em>        </em>        <em>     请求超时。<br>  7     </em>        <em>        </em>     请求超时。<br>  8     <em>        </em>        *     请求超时。<br>  9   133 ms   130 ms   129 ms  bj141-133-246.bjtelecom.net [219.141.133.246]<br> 10   131 ms   130 ms   131 ms  bj141-162-194.bjtelecom.net [219.141.162.194]<br> 11   141 ms   145 ms   131 ms  74.23.142.219.broad.bj.bj.dynamic.163data.com.cn<br> [219.142.23.74]<br> 12   140 ms   133 ms   132 ms  bj141-223-5.bjtelecom.net [219.141.223.5]</p><p>跟踪完成。</p><hr><p>我们访问<a href="http://www.datang.com主机（当然这里可以是IP地址），经过12次路由之后，就到达目标主机了。" target="_blank" rel="noopener">www.datang.com主机（当然这里可以是IP地址），经过12次路由之后，就到达目标主机了。</a></p><p>我们可以用ping命令来进行验证！eg:</p><p>C:\Users\acer&gt;ping <a href="http://www.datang.com" target="_blank" rel="noopener">www.datang.com</a> -i 11</p><p>正在 Ping <a href="http://www.datang.com" target="_blank" rel="noopener">www.datang.com</a> [219.141.223.5] 具有 32 字节的数据:<br>来自 219.142.23.74 的回复: TTL 传输中过期。<br>来自 219.142.23.74 的回复: TTL 传输中过期。<br>来自 219.142.23.74 的回复: TTL 传输中过期。<br>来自 219.142.23.74 的回复: TTL 传输中过期。</p><p>219.141.223.5 的 Ping 统计信息:<br>    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，</p><p>C:\Users\acer&gt;ping <a href="http://www.datang.com" target="_blank" rel="noopener">www.datang.com</a> -i 12</p><p>正在 Ping <a href="http://www.datang.com" target="_blank" rel="noopener">www.datang.com</a> [219.141.223.5] 具有 32 字节的数据:<br>来自 219.141.223.5 的回复: 字节=32 时间=131ms TTL=118<br>来自 219.141.223.5 的回复: 字节=32 时间=132ms TTL=118<br>来自 219.141.223.5 的回复: 字节=32 时间=131ms TTL=118<br>来自 219.141.223.5 的回复: 字节=32 时间=131ms TTL=118</p><p>219.141.223.5 的 Ping 统计信息:<br>    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，<br>往返行程的估计时间(以毫秒为单位):<br>    最短 = 131ms，最长 = 132ms，平均 = 131ms</p><p>注：</p><p>ping 命令的-i参数用于设置发出数据包的“生存时间”。<br>若设为n，则该数据包经过n个结点即停止传送。若两个地址之间实际节点数大于n(即包未送至目的地)，<br>则会显示【TTL expired in transit】(传送时过期)。tracert命令即此原理，分别发送i=1,2,3……,30(默认30)的包实现。</p><p>在上面，当我们设置“生存时间”为 11 时，数据包无法正常到达目标主机，</p><p>而设置为 12 时，就能正常到达，</p><p>通过 tracert 命令，可以看到到达目的主机时，最后一个IP为 219.141.223.5，</p><p>而通过ping 命令，也会看到是由219.141.223.5返回的数据，说明对应上了，即目的主机IP即为219.141.223.5，</p><p>这里也刚好验证了，数据包要经过12次路由才能到达目标主机！</p><p>那么默认主机的TTL值应该为118+12=130 （这个值可以由公司来改，不一定就是默认值）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们访问某个网络时，通过tracert命令，就能知道本机与目标主机之间经过多台主机，&lt;/p&gt;
&lt;p&gt;即经过多少路由。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;p&gt;C:\Users\acer&amp;gt;tracert &lt;a href=&quot;http://www.datang.co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>查看应用packagename和activity的几种方法</title>
    <link href="http://yoursite.com/2018/08/20/%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8packagename%E5%92%8Cactivity%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/08/20/查看应用packagename和activity的几种方法/</id>
    <published>2018-08-20T12:30:43.000Z</published>
    <updated>2018-08-20T13:06:03.026Z</updated>
    
    <content type="html"><![CDATA[<p>下载android SDK并配好环境变量时，可以通过多种方式获取当前activity名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aapt dump badging [yourapp.apk]</span><br></pre></td></tr></table></figure><p>如果只是想查看手机上应用的packageName，则输入命令：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages</span><br></pre></td></tr></table></figure></p><p>列出如下信息：</p><p>package:android</p><p>package:cn.ninegame.gamemanager</p><p>package:com.alipay.android.app</p><p>如果想知道应用对应的apk文件在手机上的安装位置则可以在上面的命令后加-f参数</p><p>adb shell pm list packages -f</p><p>查看Android应用包名、Activity的几个方法</p><p>一、有源码情况</p><p>直接打开AndroidManifest.xml文件，找到包含Android.intent.action.MAIN和android.intent.category.LAUNCHER对应的activity。</p><p>如下图中第三行package为com.cola.ui，第七行主Activity为com.cola.ui.ColaBox(.ColaBox为Activity简写方式)。</p><p>[html] view plain copy<br>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;  </p><manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.cola.ui" android:versioncode="1" android:versionname="1.0.0"><br>    <application android:icon="@drawable/icon" android:label="@string/app_name"><br>        <activity android:name=".ColaBox" android:label="@string/app_name"><br>            <intent-filter><br>                <action android:name="android.intent.action.MAIN"><br>                <category android:name="android.intent.category.LAUNCHER"><br>            </category></action></intent-filter><br>        </activity><br>    <activity android:name="Frm_Addbills"></activity><br>    <activity android:name="Frm_Editacctitem"></activity><br>    <activity android:name="Grid_bills"></activity><br>    <service android:name="LocalService" android:exported="true" android:enabled="true"><br><br>   </service></application><br> <uses-permission android:name="android.permission.READ_CONTACTS"><br><br><br></uses-permission></manifest>   <p>二、只有Apk的情况</p><p>（1）aapt</p><p>使用命令行aapt dump xmltree ColaBox.apk AndroidManifest.xml</p><p>（2）使用apktool</p><p>使用反编译工具apktool，反编译后打开AndroidManifest.xml文件，查找方式同“有源码情况”</p><p>（3）aapt</p><p>感谢“天地会珠海分舵”地址：<a href="http://blog.csdn.net/zhubaitian/article/details/38926679" target="_blank" rel="noopener">http://blog.csdn.net/zhubaitian/article/details/38926679</a></p><p>三、没有apk，应用已经安装到手机或虚拟机中</p><p>1.logcat</p><p>.清除logcat内容，使用命令adb logcat -c</p><p>.启动logcat，使用命令adb logcat ActivityManager:I *:s</p><p>.启动要查看的程序，</p><p>2.dumpsys</p><p>（1）启动要查看的程序；</p><p>（2）命令行输入：adb shell dumpsys window w |findstr \/ |findstr name=</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下载android SDK并配好环境变量时，可以通过多种方式获取当前activity名称：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>TEST_ONLY 导致apk无法安装问题解决</title>
    <link href="http://yoursite.com/2018/08/16/TEST-ONLY-%E5%AF%BC%E8%87%B4apk%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2018/08/16/TEST-ONLY-导致apk无法安装问题解决/</id>
    <published>2018-08-16T05:50:55.000Z</published>
    <updated>2018-08-16T08:13:54.170Z</updated>
    
    <content type="html"><![CDATA[<p>升级到7.0，android studio升级到3.0后经常出下如下异常，导致apk无法正常安装，放到手机sd卡中也无法完成安装，会提示安装失败：</p><p><img src="/blog/2018/08/16/TEST-ONLY-导致apk无法安装问题解决/adb.png" alt="adb命令行"></p><p>通过如下命令可以完成安装：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install -t *.APK</span><br></pre></td></tr></table></figure></p><h3 id="但是导致问题的原因在哪里呢？"><a href="#但是导致问题的原因在哪里呢？" class="headerlink" title="但是导致问题的原因在哪里呢？"></a>但是导致问题的原因在哪里呢？</h3><p>网上有说是manifest中配置了testOnly标签的：</p><p><img src="/blog/2018/08/16/TEST-ONLY-导致apk无法安装问题解决/testOnly.png" alt="网络上问题原因"></p><p>然而实际上，真正的原因是什么呢？<br>看看官方的说明吧：<br><a href="https://developer.android.com/studio/run/index.html" target="_blank" rel="noopener">https://developer.android.com/studio/run/index.html</a></p><blockquote><p>Note: The Run button builds an APK with testOnly=”true”, which means the APK can only be installed via adb (which Android Studio uses). If you want a debuggable APK that people can install without adb, select your debug variant and click Build &gt; Build APK(s).</p></blockquote><p><strong>大致意思就是说，只要在AndroidStudio3.0内，点击运行Run，跑出来的apk，一定是TEST_ONLY的，如果需要可以安装的apk，直接使用build apks或者assembleRelease即可。</strong></p><hr><p>以下转载自 <a href="http://blog.sina.com.cn/s/blog_6cbd24890102x0ki.html" target="_blank" rel="noopener">沈文昌同学的blog</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">之前有个问题涉及到生成apk无法安装。当时搜索到的结果是和gradle版本有关，实际上不是这样的。</span><br><span class="line"></span><br><span class="line">今天测试妹妹要一个apk，我直接run了一个给她，发现问题又出现了。</span><br><span class="line"></span><br><span class="line">我首先怀疑是不是Instant Run的配置，但这个配置我在settings里是关掉的，而Run功能（绿三角）的Configurations里，Android App-&gt;app中，右侧最下方Before launch，配置了一个Instant App Provision。我将这个配置直接删掉，问题依旧。</span><br><span class="line"></span><br><span class="line">看来不是Instant Run的锅。</span><br><span class="line"></span><br><span class="line">然后，开始怀疑是否是gradle版本不可为最新，尝试下载了升级AS3.0默认配的4.0-milestone-1，以及4.1，以及4.1-milestone-1，花费了很多时间，最后发现也不是gradle版本问题。</span><br><span class="line"></span><br><span class="line">最终，在一个曾经看过的帖子上，发现了另一个回答。</span><br><span class="line"></span><br><span class="line">https://stackoverflow.com/questions/25274296/adb-install-fails-with-install-failed-test-only</span><br><span class="line"></span><br><span class="line">往下翻，有个只有个位数支持率的回答，里面提到官方网站在beta7版本已经有了提示： https://developer.android.com/studio/run/index.html</span><br><span class="line"></span><br><span class="line">这个网站我是打不开的……好吧，这位好心人直接把主要内容粘贴了：</span><br><span class="line"></span><br><span class="line">Note: The Run button builds an APK with testOnly=&quot;true&quot;, which means the APK can only be installed via adb (which Android Studio uses). If you want a debuggable APK that people can install without adb, select your debug variant and click Build &gt; Build APK(s).</span><br><span class="line"></span><br><span class="line">也就是说，只要在AndroidStudio3.0内，点击绿三角运行Run，跑出来的apk，一定是TEST_ONLY的。</span><br><span class="line"></span><br><span class="line">问题解决，以后给测试妹妹出apk，不能直接用Run出来的了，必须跑一下Build Apks。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;升级到7.0，android studio升级到3.0后经常出下如下异常，导致apk无法正常安装，放到手机sd卡中也无法完成安装，会提示安装失败：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2018/08/16/TEST-ONLY-导致apk无法安装问题解决/adb.p
      
    
    </summary>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>markdown 语法</title>
    <link href="http://yoursite.com/2018/07/26/markdown-%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2018/07/26/markdown-语法/</id>
    <published>2018-07-26T13:04:08.000Z</published>
    <updated>2018-07-26T13:05:26.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown-文件"><a href="#Markdown-文件" class="headerlink" title="Markdown 文件"></a>Markdown 文件</h1><p><img src="https://markdown.tw/images/208x128.png" alt="Markdown"></p><p><strong>NOTE:</strong> This is Traditional Chinese Edition Document of<br>Markdown Syntax. If you are seeking for English Edition<br>Document. Please refer to <a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="noopener">Markdown: Syntax</a>.</p><h1 id="Markdown-Syntax"><a href="#Markdown-Syntax" class="headerlink" title="Markdown: Syntax"></a>Markdown: Syntax</h1><ul><li><a href="#overview">概述</a><ul><li><a href="#philosophy">哲学</a></li><li><a href="#html">行内 HTML</a></li><li><a href="#autoescape">特殊字符自动转换</a></li></ul></li><li><a href="#block">区块元素</a><ul><li><a href="#p">段落和换行</a></li><li><a href="#header">标题</a></li><li><a href="#blockquote">区块引言</a></li><li><a href="#list">清单</a></li><li><a href="#precode">程序代码区块</a></li><li><a href="#hr">分隔线</a></li></ul></li><li><a href="#span">区段元素</a><ul><li><a href="#link">连结</a></li><li><a href="#em">强调</a></li><li><a href="#code">程序代码</a></li><li><a href="#img">图片</a></li></ul></li><li><a href="#misc">其它</a><ul><li><a href="#backslash">跳脱字符</a></li><li><a href="#autolink">自动连结</a></li></ul></li><li><a href="#acknowledgement">感谢</a></li></ul><p><strong>注意：</strong>这份文件是用 Markdown 写的，你可以<a href="https://github.com/othree/markdown-syntax-zhtw/blob/master/syntax.md" target="_blank" rel="noopener">看看它的原始档</a> 。</p><hr><h2 id="overview">概述</h2><h3 id="philosophy">哲学</h3><p>Markdown 的目标是实现「易读易写」。</p><p>不过最需要强调的便是它的可读性。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多卷标或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="noopener">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="noopener">atx</a>、<a href="http://textism.com/tools/textile/" target="_blank" rel="noopener">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="noopener">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html" target="_blank" rel="noopener">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/" target="_blank" rel="noopener">EtText</a>，然而最大灵感来源其实是纯文本的电子邮件格式。</p><p>因此 Markdown 的语法全由标点符号所组成，并经过严谨慎选，是为了让它们看起来就像所要表达的意思。像是在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是清单。假如你有使用过电子邮件，区块引言看起来就真的像是引用一段文字。</p><h3 id="html">行内 HTML</h3><p>Markdown 的语法有个主要的目的：用来作为一种网络内容的<em>写作</em>用语言。</p><p>Markdown 不是要来取代 HTML，甚至也没有要和它相似，它的语法种类不多，只和 HTML 的一部分有关系，重点<em>不是</em>要创造一种更容易写作 HTML 文件的语法，我认为 HTML 已经很容易写了，Markdown 的重点在于，它能让文件更容易阅读、编写。HTML 是一种<em>发布</em>的格式，Markdown 是一种<em>编写</em>的格式，因此，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。</p><p>不在 Markdown 涵盖范围之外的标签，都可以直接在文件里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p><p>只有区块元素──比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行，以利与内容区隔。而且这些（元素）的开始与结尾标签，不可以用 tab 或是空白来缩排。Markdown 的产生器有智能型判断，可以避免在区块标签前后加上没有必要的 <code>&lt;p&gt;</code> 标签。</p><p>举例来说，在 Markdown 文件里加上一段 HTML 表格：</p><pre><code>This is a regular paragraph.&lt;table&gt;    &lt;tr&gt;        &lt;td&gt;Foo&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;This is another regular paragraph.</code></pre><p>请注意，Markdown 语法在 HTML 区块卷标中将不会被进行处理。例如，你无法在 HTML 区块内使用 Markdown 形式的<code>*强调*</code>。</p><p>HTML 的区段标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 则不受限制，可以在 Markdown 的段落、清单或是标题里任意使用。依照个人习惯，甚至可以不用Markdown 格式，而采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的  <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是影像标示语法。</p><p>HTML 区段卷标和区块卷标不同，在区段标签的范围内， Markdown 的语法是有效的。</p><h3 id="autoescape">特殊字符自动转换</h3><p>在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始卷标，<code>&amp;</code> 符号则用于标记 HTML 实体，如果你只是想要使用这些符号，你必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p><p><code>&amp;</code> 符号其实很容易让写作网络文件的人感到困扰，如果你要打「AT&amp;T」 ，你必须要写成「<code>AT&amp;amp;T</code>」 ，还得转换网址内的 <code>&amp;</code> 符号，如果你要链接到：</p><pre><code>http://images.google.com/images?num=30&amp;q=larry+bird</code></pre><p>你必须要把网址转成：</p><pre><code>http://images.google.com/images?num=30&amp;amp;q=larry+bird</code></pre><p>才能放到链接卷标的 <code>href</code> 属性里。不用说也知道这很容易忘记，这也可能是 HTML 标准检查所检查到的错误中，数量最多的。</p><p>Markdown 允许你直接使用这些符号，但是你要小心跳脱字符的使用，如果你是在HTML 实体中使用 <code>&amp;</code> 符号的话，它不会被转换，而在其它情形下，它则会被转换成 <code>&amp;amp;</code>。所以你如果要在文件中插入一个著作权的符号，你可以这样写：</p><pre><code>&amp;copy;</code></pre><p>Markdown 将不会对这段文字做修改，但是如果你这样写：</p><pre><code>AT&amp;T</code></pre><p>Markdown 就会将它转为：</p><pre><code>AT&amp;amp;T</code></pre><p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 支持 <a href="#html">行内 HTML</a> ，如果你是使用 <code>&lt;</code> 符号作为 HTML 卷标使用，那 Markdown 也不会对它做任何转换，但是如果你是写：</p><pre><code>4 &lt; 5</code></pre><p>Markdown 将会把它转换为：</p><pre><code>4 &amp;lt; 5</code></pre><p>不过需要注意的是，code 范围内，不论是行内还是区块， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都<em>一定</em>会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）</p><hr><h2 id="block">区块元素</h2><h3 id="p">段落和换行</h3><p>一个段落是由一个以上相连接的行句组成，而一个以上的空行则会切分出不同的段落（空行的定义是显示上看起来像是空行，便会被视为空行。比方说，若某一行只包含空白和 tab，则该行也会被视为空行），一般的段落不需要用空白或断行缩排。</p><p>「一个以上相连接的行句组成」这句话其实暗示了 Markdown 允许段落内的强迫断行，这个特性和其他大部分的 text-to-HTML 格式不一样（包括 MovableType 的「Convert Line Breaks」选项），其它的格式会把每个断行都转成 <code>&lt;br /&gt;</code> 标签。</p><p>如果你<em>真的</em>想要插入 <code>&lt;br /&gt;</code> 标签的话，在行尾加上两个以上的空白，然后按 enter。</p><p>是的，这确实需要花比较多功夫来插入 <code>&lt;br /&gt;</code> ，但是「每个换行都转换为 <code>&lt;br /&gt;</code>」的方法在 Markdown 中并不适合， Markdown 中 email 式的 <a href="#blockquote">区块引言</a> 和多段落的 <a href="#list">清单</a> 在使用换行来排版的时候，不但更好用，还更好阅读。</p><h3 id="header">标题</h3><p>Markdown 支持两种标题的语法，<a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="noopener">Setext</a> 和 <a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="noopener">atx</a> 形式。</p><p>Setext 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），例如：</p><pre><code>This is an H1=============This is an H2-------------</code></pre><p>任何数量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p><p>Atx 形式则是在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶，例如：</p><pre><code># This is an H1## This is an H2###### This is an H6</code></pre><p>你可以选择性地「关闭」atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 <code>#</code>，而行尾的 <code>#</code> 数量也不用和开头一样（行首的井字数量决定标题的阶数）：</p><pre><code># This is an H1 ### This is an H2 ##### This is an H3 ######</code></pre><h3 id="blockquote">Blockquotes</h3><p>Markdown 使用 email 形式的区块引言，如果你很熟悉如何在 email 信件中引言，你就知道怎么在 Markdown 文件中建立一个区块引言，那会看起来像是你强迫断行，然后在每行的最前面加上 <code>&gt;</code> ：</p><pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt;&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing.</code></pre><p>Markdown 也允许你只在整个段落的第一行最前面加上 <code>&gt;</code> ：</p><pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing.</code></pre><p>区块引言可以有阶层（例如：引言内的引言），只要根据层数加上不同数量的 <code>&gt;</code> ：</p><pre><code>&gt; This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level.</code></pre><p>引言的区块内也可以使用其他的 Markdown 语法，包括标题、列表、程序代码区块等：</p><pre><code>&gt; ## This is a header.&gt;&gt; 1.   This is the first list item.&gt; 2.   This is the second list item.&gt;&gt; Here&apos;s some example code:&gt;&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre><p>任何标准的文本编辑器都能简单地建立 email 样式的引言，例如 BBEdit ，你可以选取文字后然后从选单中选择<em>增加引言阶层</em>。</p><h3 id="list">清单</h3><p>Markdown 支持有序列表和无序列表。</p><p>无序清单使用星号、加号或是减号作为列表标记：</p><pre><code>*   Red*   Green*   Blue</code></pre><p>等同于：</p><pre><code>+   Red+   Green+   Blue</code></pre><p>也等同于：</p><pre><code>-   Red-   Green-   Blue</code></pre><p>有序列表则使用数字接着一个英文句点：</p><pre><code>1.  Bird2.  McHale3.  Parish</code></pre><p>很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：</p><pre><code>&lt;ol&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ol&gt;</code></pre><p>如果你的列表标记写成：</p><pre><code>1.  Bird1.  McHale1.  Parish</code></pre><p>或甚至是：</p><pre><code>3. Bird1. McHale8. Parish</code></pre><p>你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。</p><p>如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。</p><p>列表项目标记通常是放在最左边，但是其实也可以缩排，最多三个空白，项目标记后面则一定要接着至少一个空白或 tab。</p><p>要让清单看起来更漂亮，你可以把内容用固定的缩排整理好：</p><pre><code>*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,    viverra nec, fringilla in, laoreet vitae, risus.*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.    Suspendisse id sem consectetuer libero luctus adipiscing.</code></pre><p>但是如果你很懒，那也不一定需要：</p><pre><code>*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus.*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing.</code></pre><p>如果列表项目间用空行分开， Markdown 会把项目的内容在输出时用 <code>&lt;p&gt;</code><br>标签包起来，举例来说：</p><pre><code>*   Bird*   Magic</code></pre><p>会被转换为：</p><pre><code>&lt;ul&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;Magic&lt;/li&gt;&lt;/ul&gt;</code></pre><p>但是这个：</p><pre><code>*   Bird*   Magic</code></pre><p>会被转换为：</p><pre><code>&lt;ul&gt;&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><p>列表项目可以包含多个段落，每个项目下的段落都必须缩排 4 个空白或是一个 tab ：</p><pre><code>1.  This is a list item with two paragraphs. Lorem ipsum dolor    sit amet, consectetuer adipiscing elit. Aliquam hendrerit    mi posuere lectus.    Vestibulum enim wisi, viverra nec, fringilla in, laoreet    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum    sit amet velit.2.  Suspendisse id sem consectetuer libero luctus adipiscing.</code></pre><p>如果你每行都有缩排，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：</p><pre><code>*   This is a list item with two paragraphs.    This is the second paragraph in the list item. You&apos;reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit.*   Another item in the same list.</code></pre><p>如果要在列表项目内放进引言，那 <code>&gt;</code> 就需要缩排：</p><pre><code>*   A list item with a blockquote:    &gt; This is a blockquote    &gt; inside a list item.</code></pre><p>如果要放程序代码区块的话，该区块就需要缩排<em>两次</em>，也就是 8 个空白或是两个 tab：</p><pre><code>*   A list item with a code block:        &lt;code goes here&gt;</code></pre><p>当然，项目列表很可能会不小心产生，像是下面这样的写法：</p><pre><code>1986. What a great season.</code></pre><p>换句话说，也就是在行首出现<em>数字-句点-空白</em>，要避免这样的状况，你可以在句点前面加上反斜杠。</p><pre><code>1986\. What a great season.</code></pre><h3 id="precode">程序代码区块</h3><p>和程序相关的写作或是卷标语言原始码通常会有已经排版好的程序代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把程序代码区块包起来。</p><p>要在 Markdown 中建立程序代码区块很简单，只要简单地缩排 4 个空白或是 1 个 tab 就可以，例如，下面的输入：</p><pre><code>This is a normal paragraph:    This is a code block.</code></pre><p>Markdown 会转换成：</p><pre><code>&lt;p&gt;This is a normal paragraph:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;This is a code block.&lt;/code&gt;&lt;/pre&gt;</code></pre><p>这个每行一阶的缩排（4 个空白或是 1 个 tab），都会被移除，例如：</p><pre><code>Here is an example of AppleScript:    tell application &quot;Foo&quot;        beep    end tell</code></pre><p>会被转换为：</p><pre><code>&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot;    beepend tell&lt;/code&gt;&lt;/pre&gt;</code></pre><p>一个程序代码区块会一直持续到没有缩排的那一行（或是文件结尾）。</p><p>在程序代码区块里面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩排就可以了，剩下的 Markdown 都会帮你处理，例如：</p><pre><code>&lt;div class=&quot;footer&quot;&gt;    &amp;copy; 2004 Foo Corporation&lt;/div&gt;</code></pre><p>会被转换为：</p><pre><code>&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt;    &amp;amp;copy; 2004 Foo Corporation&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;</code></pre><p>程序代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。</p><h3 id="hr">分隔线</h3><p>你可以在一行中用三个或以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号中间插入空白。下面每种写法都可以建立分隔线：</p><pre><code>* * *********- - ----------------------------------------</code></pre><hr><h2 id="span">区段元素</h2><h3 id="link">连结</h3><p>Markdown 支持两种形式的链接语法： <em>行内</em>和<em>参考</em>两种形式。</p><p>不管是哪一种，链接的文字都是用 [方括号] 来标记。</p><p>要建立一个行内形式的连结，只要在方块括号后面马上接着括号并插入网址连结即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p><pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute.</code></pre><p>会产生：</p><pre><code>&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;an example&lt;/a&gt; inline link.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has notitle attribute.&lt;/p&gt;</code></pre><p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p><pre><code>See my [About](/about/) page for details.   </code></pre><p>参考形式的连结使用另外一个方括号接在链接文字的括号后面，而在第二个方括号里面要填入用以辨识链接的标签：</p><pre><code>This is [an example][id] reference-style link.</code></pre><p>你也可以选择性地在两个方括号中间加上空白：</p><pre><code>This is [an example] [id] reference-style link.</code></pre><p>接着，在文件的任意处，你可以把这个标签的链接内容定义出来：</p><pre><code>[id]: http://example.com/  &quot;Optional Title Here&quot;</code></pre><p>连结定义的形式为：</p><ul><li>方括号，里面输入链接的辨识用标签</li><li>接着一个冒号</li><li>接着一个以上的空白或 tab</li><li>接着连结的网址</li><li>选择性地接着 title 内容，可以用单引号、双引号或是括号包着</li></ul><p>下面这三种连结的定义都是相同：</p><pre><code>[foo]: http://example.com/  &quot;Optional Title Here&quot;[foo]: http://example.com/  &apos;Optional Title Here&apos;[foo]: http://example.com/  (Optional Title Here)</code></pre><p><strong>请注意：</strong>有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的连结 title。</p><p>连结网址也可以用方括号包起来：</p><pre><code>[id]: &lt;http://example.com/&gt;  &quot;Optional Title Here&quot;</code></pre><p>你也可以把 title 属性放到下一行，也可以加一些缩排，网址太长的话，这样会比较好看：</p><pre><code>[id]: http://example.com/longish/path/to/resource/here    &quot;Optional Title Here&quot;</code></pre><p>网址定义只有在产生连结的时候用到，并不会直接出现在文件之中。</p><p>链接辨识卷标可以有字母、数字、空白和标点符号，但是并<em>不</em>区分大小写，因此下面两个连结是一样的：</p><pre><code>[link text][a][link text][A]</code></pre><p><em>默认的链接卷标</em>功能让你可以省略指定链接标签，这种情形下，链接卷标和链接文字会视为相同，要用默认链接卷标只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 连结到 google.com，你可以简化成：</p><pre><code>[Google][]</code></pre><p>然后定义连结内容：</p><pre><code>[Google]: http://google.com/</code></pre><p>由于链接文字可能包含空白，所以这种简化的标签内也可以包含多个文字：</p><pre><code>Visit [Daring Fireball][] for more information.</code></pre><p>然后接着定义连结：</p><pre><code>[Daring Fireball]: http://daringfireball.net/</code></pre><p>连结的定义可以放在文件中的任何一个地方，我比较偏好直接放在连结出现段落的后面，你也可以把它放在文件最后面，就像是批注一样。</p><p>下面是一个参考式链接的范例：</p><pre><code>I get 10 times more traffic from [Google] [1] than from[Yahoo] [2] or [MSN] [3].  [1]: http://google.com/        &quot;Google&quot;  [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;  [3]: http://search.msn.com/    &quot;MSN Search&quot;</code></pre><p>如果改成用连结名称的方式写：</p><pre><code>I get 10 times more traffic from [Google][] than from[Yahoo][] or [MSN][].  [google]: http://google.com/        &quot;Google&quot;  [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;  [msn]:    http://search.msn.com/    &quot;MSN Search&quot;</code></pre><p>上面两种写法都会产生下面的 HTML。</p><pre><code>&lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot;title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from&lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt;or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt;</code></pre><p>下面是用行内形式写的同样一段内容的 Markdown 文件，提供作为比较之用：</p><pre><code>I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or[MSN](http://search.msn.com/ &quot;MSN Search&quot;).</code></pre><p>参考式的连结其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的连结却会增加到 176 个字符，如果是用纯 HTML 格式来写，会有 234 个字符，在 HTML 格式中，卷标比文字还要多。</p><p>使用 Markdown 的参考式连结，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的信息移到段落文字之外，你就可以增加连结而不让文章的阅读感觉被打断。</p><h3 id="em">强调</h3><p>Markdown 使用星号（<code>*</code>）和底线（<code>_</code>）作为标记强调字词的符号，被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 <code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code>，例如：</p><pre><code>*single asterisks*_single underscores_**double asterisks**__double underscores__</code></pre><p>会转成：</p><pre><code>&lt;em&gt;single asterisks&lt;/em&gt;&lt;em&gt;single underscores&lt;/em&gt;&lt;strong&gt;double asterisks&lt;/strong&gt;&lt;strong&gt;double underscores&lt;/strong&gt;</code></pre><p>你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启卷标，就要用什么符号结束。</p><p>强调也可以直接插在文字中间：</p><pre><code>un*frigging*believable</code></pre><p>但是如果你的 <code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通的符号。</p><p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜杠：</p><pre><code>\*this text is surrounded by literal asterisks\*</code></pre><h3 id="code">程序代码</h3><p>如果要标记一小段行内程序代码，你可以用反引号把它包起来（<code>`</code>），例如：</p><pre><code>Use the `printf()` function.</code></pre><p>会产生：</p><pre><code>&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt;</code></pre><p>如果要在程序代码区段内插入反引号，你可以用多个反引号来开启和结束程序代码区段：</p><pre><code>``There is a literal backtick (`) here.``</code></pre><p>这段语法会产生：</p><pre><code>&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt;</code></pre><p>程序代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：</p><pre><code>A single backtick in a code span: `` ` ``A backtick-delimited string in a code span: `` `foo` ``</code></pre><p>会产生：</p><pre><code>&lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;</code></pre><p>在程序代码区段内，<code>&amp;</code> 和方括号都会被转成 HTML 实体，这样会比较容易插入 HTML 原始码，Markdown 会把下面这段：</p><pre><code>Please don&apos;t use any `&lt;blink&gt;` tags.</code></pre><p>转为：</p><pre><code>&lt;p&gt;Please don&apos;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;</code></pre><p>你也可以这样写：</p><pre><code>`&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`.</code></pre><p>以产生：</p><pre><code>&lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encodedequivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt;</code></pre><h3 id="img">图片</h3><p>很明显地，要在纯文本应用中设计一个 「自然」的语法来插入图片是有一定难度的。</p><p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： <em>行内</em>和<em>参考</em>。</p><p>行内图片的语法看起来像是：</p><pre><code>![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</code></pre><p>详细叙述如下：</p><ul><li>一个惊叹号 <code>!</code></li><li>接着一对方括号，里面放上图片的替换文字</li><li>接着一对普通括号，里面放上图片的网址，最后还可以用引号包住并加上<br>选择性的 ‘title’ 文字。</li></ul><p>参考式的图片语法则长得像这样：</p><pre><code>![Alt text][id]</code></pre><p>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p><pre><code>[id]: url/to/image  &quot;Optional title attribute&quot;</code></pre><p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p><hr><h2 id="misc">其它</h2><h3 id="autolink">自动连结</h3><p>Markdown 支持比较简短的自动连结形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接，链接的文字就和链接位置一样，例如：</p><pre><code>&lt;http://example.com/&gt;</code></pre><p>Markdown 会转为：</p><pre><code>&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;</code></pre><p>自动的邮件连结也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以混淆一些不好的信箱地址收集机器人，例如：</p><pre><code>&lt;address@example.com&gt;</code></pre><p>Markdown 会转成：</p><pre><code>&lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;</code></pre><p>在浏览器里面，这段字符串会变成一个可以点击的「<a href="mailto:address@example.com" target="_blank" rel="noopener">address@example.com</a>」连结。</p><p>（这种作法虽然可以混淆不少的机器人，但并无法全部挡下来，不过这样也比什么都不做好些。无论如何，公开你的信箱终究会引来广告信件的。）</p><h3 id="backslash">跳脱字符</h3><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <code>&lt;em&gt;</code> 标签），你可以在星号的前面加上反斜杠：</p><pre><code>\*literal asterisks\*</code></pre><p>Markdown 支持在下面这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code>\   反斜杠`   反引号*   星号_   底线{}  大括号[]  方括号()  括号#   井字号+    加号-    减号.   英文句点!   惊叹号</code></pre><h2 id="acknowledgement">感谢</h2><p>感谢 <a href="https://twitter.com/#!/leafy7382" target="_blank" rel="noopener">leafy7382</a> 协助翻译，<a href="http://iamhlb.com/" target="_blank" rel="noopener">hlb</a>、<a href="http://twitter.com/randylien" target="_blank" rel="noopener">Randylien</a> 帮忙润稿，<a href="https://twitter.com/#!/ethantw" target="_blank" rel="noopener">ethantw</a> 的<a href="http://ethantw.net/projects/han/" target="_blank" rel="noopener">汉字标准格式・CSS Reset</a>， <a href="http://kidwm.net/" target="_blank" rel="noopener">WM</a> 回报文字错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown-文件&quot;&gt;&lt;a href=&quot;#Markdown-文件&quot; class=&quot;headerlink&quot; title=&quot;Markdown 文件&quot;&gt;&lt;/a&gt;Markdown 文件&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://markdown.tw/imag
      
    
    </summary>
    
      <category term="markdown" scheme="http://yoursite.com/categories/markdown/"/>
    
    
  </entry>
  
  <entry>
    <title>ListView footer dividers</title>
    <link href="http://yoursite.com/2018/07/26/ListView-footer-dividers/"/>
    <id>http://yoursite.com/2018/07/26/ListView-footer-dividers/</id>
    <published>2018-07-26T05:59:57.000Z</published>
    <updated>2018-07-26T12:57:21.407Z</updated>
    
    <content type="html"><![CDATA[<p>ListView的顶部和底部怎么增加分隔线</p><hr><p>首先，我们先来了解ListView的两个属性以及它们的API解析</p><blockquote><p>android:headerDividersEnabled:  When set to false, the ListView will not draw the divider after each header view. [boolean]</p></blockquote><blockquote><p>android:footerDividersEnabled:   When set to false, the ListView will not draw the divider before each footer view. [boolean]</p></blockquote><p>可见，这里两个属性都只对HeaderView和FooterView有效，如果你没有在ListView加入HeaderView或者FooterView，无论设置什么值，都是没有作用的。</p><p><img src="/blog/2018/07/26/ListView-footer-dividers/footer.jpg" alt="footer"></p><p>那么，如何为listview设置顶部和底部的间隔线呢，是不是要为listiew的每一个item在布局中设置分割线呢？</p><p>这里列举一种比较简单的办法：</p><p>在xml中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:headerDividersEnabled=<span class="string">"true"</span></span><br><span class="line">android:footerDividersEnabled=<span class="string">"true"</span></span><br></pre></td></tr></table></figure></p><p>在代码中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listView.addHeaderView(<span class="keyword">new</span> View(<span class="keyword">this</span>));</span><br><span class="line">listView.addFooterView(<span class="keyword">new</span> View(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ListView的顶部和底部怎么增加分隔线&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;首先，我们先来了解ListView的两个属性以及它们的API解析&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;android:headerDividersEnabled:  When set to false,
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="ListView" scheme="http://yoursite.com/tags/ListView/"/>
    
  </entry>
  
  <entry>
    <title>Android 进程状态整理和常驻service实践</title>
    <link href="http://yoursite.com/2018/07/21/Android-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%95%B4%E7%90%86%E5%92%8C%E5%B8%B8%E9%A9%BBservice%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/07/21/Android-进程状态整理和常驻service实践/</id>
    <published>2018-07-21T07:49:41.000Z</published>
    <updated>2018-07-26T13:31:15.638Z</updated>
    
    <content type="html"><![CDATA[<p>lowmeorykiller中进程的分类以及各类进程的adj值</p><pre><code>在Android的lowmemroykiller机制中，会对于所有进程进行分类，对于每一类别的进程会有其oom_adj值的取值范围，oom_adj值越高则代表进程越不重要，在系统执行低杀操作时，会从oom_adj值越高的开始杀。系统lowmemeorykiller机制下对于进程的级别的以变量的形式定义在framework/base/core/java/com/android/server/am/ProcessList.java类中，可总结成下表：</code></pre><p><img src="/blog/2018/07/21/Android-进程状态整理和常驻service实践/process.png" alt="进程图"></p><p>再补充介绍一下：</p><p>1.AMS角度对于进程的分级       </p><p>上表带分级只是从lowmemroykiller角度来分的，时用于lowmemeorykiller执行杀进程操作，但是从android的系统管理角度看，即是从AMS执行相关逻辑时，又有一套自己的分级机制，当然这两套机制也有着很多互通的点。AMS角度的级别划分以变量的形式定义在framework/base/core/java/android/app/ActivityManager.java类中，以PROCESS_STATE开头的变量。</p><p>2.没有stopService其内含activity的后台进程</p><pre><code>这类进程从lowmemorykiller角度是划分为cached，因为如果这类进程往往占有较大的内存，这类含有activity的后台进程往往占有较大内存，所以即使这类进程包含了Service，lowmemorykiller的机制也会更加倾向于优先杀死这类进程。但是一般启动了服务的进程往往是希望服务在后台能够执行某些任务，这样看是不希望这些服务因为进程被杀而过早的被终止的，那如何调和这种矛盾呢？正确的做法是，对于期望较长时间留在后台的服务，应该将服务运行在单独的进程里，即是UI进程与Servie进程分离，这样期望长时间留在后台的Serivce会存在与一个被lmk分类为Service 进程的服务而获得较小的Adj值，而占有大量内存的UI进程则会分类为Cached进程，能够在需要的时候更快地被回收。还有一点，这类进程虽然被lmk划分为cached进程，但是从ams角度是被划分为PROCESS_STATE_SERVICE这个类别的，即视为服务进程，在ams相关流程中也是以服务进程来执行相关逻辑的，此外在使用dumpsys meminfo查看所有进程时，这类进程也是被列在B service这个类别的。</code></pre><p>3.A-Service与B-Service的划分</p><pre><code>所有启动了服务的进程，且该服务所在的进程没有显示过UI，且该服务未执行startForeground（执行后会变为perveptible服务）动作，那该进程则为A-Service与B-Service中的一种。然后根据这类服务进程所处于Lru进程表中的位置，前1/3点服务为A-Service，其余的则为B-Service。</code></pre><p>4.perceptible的标准</p><pre><code>perceptible名为可感知的进程，但并不是说能够感知到进程就一定表示该进程属于perveptible进程，比如播放音乐的进程活着状态栏上有通知的进程，虽然能够感知到进程的存在，但是不代表进程一定时perceptible类别的进程。决定该进程是否属于perceptible进程并未进程的可感知性，而是该进程的服务是否执行了startForeground动作。</code></pre><p>使用命令可以打出进程所属service的状态信息：</p><p>以今日头条为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpsys activity services com.ss.android.article.news</span><br></pre></td></tr></table></figure><p><img src="/blog/2018/07/21/Android-进程状态整理和常驻service实践/2018-07-26_161152.png" alt="服务图"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">ps | grep com.ss.android.article.news</span><br><span class="line">cat proc/<span class="number">9839</span>/oom_adj</span><br></pre></td></tr></table></figure><p><img src="/blog/2018/07/21/Android-进程状态整理和常驻service实践/2018-07-26_161744.png" alt="进程adj图"></p><p>对于常驻Service，通常使用绑定托盘的方式使之成为前台service，这样的adj值会从5或者8变为2，一般是不会清理掉的。</p><p>常驻Service方案除了基本的sticky之外，可以参考github上<a href="https://github.com/D-clock/AndroidDaemonService" target="_blank" rel="noopener">优雅的常驻service</a>.原理是通过设置相同的notification ID 设置前台service，stopInnerService后，原service会被认定为前台service，并且不会弹出通知栏。</p><blockquote><p>注意： 该方案在Android 7.1 及以上版本会弹出通知栏，这个其实是goolge里的漏洞，在Android 7.1上已经修复。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;lowmeorykiller中进程的分类以及各类进程的adj值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在Android的lowmemroykiller机制中，会对于所有进程进行分类，对于每一类别的进程会有其oom_adj值的取值范围，oom_adj值越高则代表进程越不重要，在系统执
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>各平台离线日志开关</title>
    <link href="http://yoursite.com/2018/07/21/%E5%90%84%E5%B9%B3%E5%8F%B0%E7%A6%BB%E7%BA%BF%E6%97%A5%E5%BF%97%E5%BC%80%E5%85%B3/"/>
    <id>http://yoursite.com/2018/07/21/各平台离线日志开关/</id>
    <published>2018-07-21T02:20:06.000Z</published>
    <updated>2018-07-24T09:45:03.077Z</updated>
    
    <content type="html"><![CDATA[<p>以下是部分手机抓取日志方法</p><h3 id="360手机"><a href="#360手机" class="headerlink" title="360手机"></a>360手机</h3><hr><p>1） 在桌面的【其他应用】文件夹找到【用户反馈】，或通过搜索找到【用户反馈】<br>2 )  点击系统问题反馈<br>3 )  等复现问题，让问题出现2～3次<br>4 )  问题复现之后，直接到文件管理、本地存储，找到根目录下的“log或者mtklog”文件，将文件压缩后发送给工作人员</p><h3 id="MIUI："><a href="#MIUI：" class="headerlink" title="MIUI："></a>MIUI：</h3><hr><p>1） 在拨号键输入 *#*#284#*#* 来抓日志（不包括前后空格），过程可能要 1 分钟左右，成功后通知栏会提示；<br>2）等复现问题<br>3） 日志存放在 MIUI/debug_log 目录里，一个类似 bugreport-0227-14564.zip 的压缩包，将其发给我们</p><h3 id="魅族"><a href="#魅族" class="headerlink" title="魅族"></a>魅族</h3><hr><p>1） 去魅族应用市场下载一个叫“Log Report\ 的软件<br>2） 然后用它抓取LOG<br>3） 等问题复现后将log发给我们</p><h3 id="OPPO"><a href="#OPPO" class="headerlink" title="OPPO"></a>OPPO</h3><hr><p>1）在拨号键盘输入*#800# ，在弹出的界面选择第一项“Oppo Logkit”，再选取第一项“常规log日志信息抓取”，点击最下面一排按钮最左右的“保存log”，返回到上一界面<br>2）选择QXDM log抓取，选择打开Device_Log，运行一段时间后选择关闭Device_Log<br>3）问题出现后在进入“常规log日志信息抓取”点击暂停log，再点击转存log，<br>4）进入文件管理把文件夹OPPOlog里面最新的log和文件夹diag_logs里面的最新文件压缩后发送给相关的工作人员</p><h3 id="vivo"><a href="#vivo" class="headerlink" title="vivo"></a>vivo</h3><hr><p>在拨号键盘输入  *#*#112#*#*   进入bbklog<br>我们机型抓log的方法根据处理器的平台不同方法也不同，分高通处理器平台以及MTK处理器平台<br>mtk开启LOG方法：拔号界面输入*#*#112#*#* —&gt;MTKLogger,点最下方红色小键头,然后点返回键到主菜单，问题出现后，输入：*#*#112#*#*—&gt;MTKLogger，点红色的方框停止，log路径：文件管理根目录下的mtklog文件夹，将整个文件夹压缩后发给相关的工作人员<br>高通平台抓log的步骤：在拨号盘输入*#*#112#*#*即可进入Bbklog界面，ADBLog开关是总开关，开启后退出该界面。然后运行问题出现的软件或者打开问题出现的路径，log路径：文件管理根目录下的bbk_log文件夹，将整个文件夹压缩后发给相关的工作人员</p><h3 id="Nubia-UI："><a href="#Nubia-UI：" class="headerlink" title="Nubia UI："></a>Nubia UI：</h3><hr><p>拨号输入 *#62564#（旧版 ROM 为 *#983564#）进入自带的抓日志工具 Woodpecker</p><ol><li>软件报错、闪退相关问题：<br> a) 开启 MobileLog、NetworkLog 两项，并点击最下方开始箭头按钮<br> b) 退出工具界面，操作手机，使问题复现后，记下时间点，再次进入工具点击停止按钮<br> c) 在 内置存储/nubialog 文件夹里，将刚生成的 log 文件夹压缩，提交给工作人员并告知时间点</li><li>功耗问题：<br> a) 保证手机没有连接电脑、关闭 ModemLog 的情况下，重启手机，然后再开启 MobileLog 、NetworkLog、功耗Log 三项，记下当前电量，并点击最下方开始箭头按钮<br> b) 正常使用手机，观察耗电情况（至少30分钟）；若发现异常，记录时间点、当前电量、使用了什么软件，做了什么操作，并进入 Log 工具点击停止按钮<br> c) 在 内置存储/nubialog 文件夹里，将刚生成的 log 文件夹压缩，提交给工作人员并告知时间点</li></ol><h3 id="三星"><a href="#三星" class="headerlink" title="三星"></a>三星</h3><hr><ol><li>在系统拨号盘输入  *#9900#  进入sys Dump菜单</li><li>Delete dumpstate/logcat</li><li>Set Silent log : On to default</li><li>测试复现问题</li><li>*#9900#进入sys Dump菜单</li><li>Press Run dumpstate/logcat/modem log</li><li>press copy to SDcard(include CP Ramdump)</li><li>然后将内存根目录下的log文件夹压缩后发给工作人员</li></ol><h3 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h3><hr><ol><li>拨号键输入*#*#2846579#*#*，进入工程菜单</li><li>选择后台设置–Log设置-&gt;Log开关</li><li>点击页面最下方中间的播放按钮开始抓log，之后按钮会变成暂停图标，<br>点击后可以停止抓log，一旦选择了start，每次开机，log都会自动打开</li><li>复现问题后，需要先选择stop，这样log能完全保存下来；</li><li>打开LOG，正常使用手机，观察问题是否出现；</li><li>如果问题出现，请记录一下时间点，最好能截个问题现象的截图；在问题出现后过10分钟再停止LOG，确保整个过程的LOG都抓到；<br>（如果长时间不复现，考虑到LOG可能占满手机空间，造成LOG覆盖的情况，请定时清除一下LOG）</li><li>清除LOG方法为：首先将LOG停止；然后点击又下角的*桶图标，进入后选择“clear all”，然后选择确定，则手机存储中的LOG将会被全部清除；之后再打开LOG继续进行抓取；</li><li>停止LOG后将LOG导出压缩发送；<br>Log的保存路径是：手机内部存储或者SD卡存储根目录下会有一个“mtklog”的文件夹；请将此文件夹从手机中拖出后压缩发送给相关工作人员</li></ol><h3 id="联想（含Moto-z-z-play-M-国行）"><a href="#联想（含Moto-z-z-play-M-国行）" class="headerlink" title="联想（含Moto z/z play/M 国行）"></a>联想（含Moto z/z play/M 国行）</h3><hr><h3 id="3333-模式（MTK平台）"><a href="#3333-模式（MTK平台）" class="headerlink" title="####3333#模式（MTK平台）"></a>####3333#模式（MTK平台）</h3><ol><li>打开拨号界面，输入####3333#，打开工程模式</li><li>点击SystemLog后点击右上角设置按钮，进入设置界面，将三个log模式均点上，其他的暂时不要点<br>3.点击返回键，后点击屏幕下方中间的三角按钮，显示等待开始录取log，你会看到时间在动，这个时候退出，再通知栏也可以看到录取模式再运行<br>4.按照之前出现问题的操作方式再次进行操作，直至问题再次出现（即问题复现）<br>5.点击通知栏的log录取按钮，再次进入log录取界面，点击下方中间的方块按钮停止log录制<br>6.找到mtklog这个文件夹，将里面的内容拷出后压缩打包发给工程师<br>7.反馈完毕后为了避免log占用大量内存，按照步骤1进入工程模式后点击右下角的清除按钮（垃圾桶），然后选择需要清除的log，一般选择全部清除即可，然后返回退出即可。</li></ol><h3 id="8888-模式（高通平台）"><a href="#8888-模式（高通平台）" class="headerlink" title="####8888#模式（高通平台）"></a>####8888#模式（高通平台）</h3><ol><li>在拨号界面输入####8888#，进入工程模式</li><li>点选所有日志（或者根据问题类型选择）<br>3.点home键，然后按照之前的操作步骤复现问题<br>4.问题复现后再次按照步骤1进入工程模式点击保存日志<br>5.找到log这个文件夹，把里面的log拷出后打包发给工程师就ok了</li></ol><h3 id="金立"><a href="#金立" class="headerlink" title="金立"></a>金立</h3><hr><h3 id="高通平台"><a href="#高通平台" class="headerlink" title="高通平台"></a>高通平台</h3><ol><li>开机后，进入拨号界面，在拨号界面输入指令*#446633#</li><li>进入金立的log日志选项界面了，看到英文很头疼？放心，很简单的！下面我来介绍。</li><li>默认情况下，最上面两项Mobile Log和Kernel Log是打开的。遇到报错或者为了验证特殊问题时，如果是日常使用场景，不涉及到使用网络（WiFi、数据网络），打开它们就够了。</li><li>如果你反馈的问题与网络连接有关，那么一定要打开后面两项Modem Log和Net Log。（否则你做了无用功，工程师收到无效log也会感到心好累的= =！）modem log开启后会占用一定内存，这一点请注意，传完log记得及时清理，腾出存储空间。</li><li>接着看下面的Log Path选项，这个是log文件存储的位置选项，默认的就是Internal Storage（内置存储），所以这一项我们不用管。</li><li>大家注意到了吗，有一行小字，Start Automatically when Reboot，勾选这个选项后便于开机直接启动log记录器，而不需要每次都进拨号盘输入命令启动，尤其是验证死机重启的问题时它很有用。</li><li>最后也是最重要的一点，打开上面的所有选项后，一定记得点击绿色的“START”按钮。这时就会变成下面的界面了，log记录就开始了，我们就可以按返回键退出这个界面，执行各种操作，从而复现问题了。</li><li>最后的最后，复现了问题步骤以后，记得连接电脑，复制存储目录下的GNLogs文件夹（因机型与平台的不同，有些为diag_logs文件夹），最好压缩后发给工作人员</li></ol><h3 id="MTK平台"><a href="#MTK平台" class="headerlink" title="MTK平台"></a>MTK平台</h3><p>1、到手机的拨号界面，输入*#446633#，会进入工程模式的界面。如下图所示，然后手指向左侧滑动，进入Log and Debugging子项下的MTKLogger选项，点击进入<br>2、 默认界面如下，正常情况下直接开启即可。开启方法就是点击正下方的红色小三角，类似于播放器的图标一样。开启后会有一个等待动画，几秒钟后开始计时，就表明你已经开始记录log了。这时候就可以退出此界面去复现你遇到的问题了。（也就是操作一遍你遇到问题的过程）<br>PS：如果你对于log占用的空间比较在意，并且所反馈的问题确认与网络无关，可以在开启log之前，点击右上角的设置按钮，进入下方右侧图片中的界面，关闭ModemLog。这样记录下来的log体积会大大减少。<br>但如果你的问题跟网络有关（无论数据流量还是WiFi相关），请务必保持ModemLog在开启的状态，否则记录的log是没用的！<br>3、复现问题后，下拉状态栏，进入log抓取界面，然后点击按钮关闭log开关。进入文件管理器，找到mtklog文件夹，压缩后发给工作人员<br>4、 log抓取部分的教程到此就结束了。Log传完以后，手机里的log文件仍然占用着空间，你可以直接在文件管理器删除整个mtklog文件夹进行清理，也可以进入抓log界面，点击右下角的垃圾桶，进入后选择右下角的Clear All，即可完成清理</p><h3 id="一加"><a href="#一加" class="headerlink" title="一加"></a>一加</h3><hr><p>氢OS系统日志抓取步骤：</p><ol><li>打开拨号键盘输入*#800#——点击oneplus logkit；</li><li>勾选“保存log”；</li><li>点击“QXDM log抓取”；</li><li>点击“打开device log”；</li><li>返回操作使BUG复现；</li><li>问题复现后记录问题出现时间，等待几分钟；</li><li>将文件管理中“oem_log”文件夹拷出；</li><li>为了不占用更多手机容量，在LOG已经提取后，可以再次打开“常规log日志信息抓取”与“QXDM log抓取”，关闭log抓取以后点击“删除历史log”。<br>然后把提取的文件压缩后发我就可以了  </li></ol><h3 id="乐视"><a href="#乐视" class="headerlink" title="乐视"></a>乐视</h3><hr><ol><li>打开拨号页面，输入*#*#8888#*#* （或者打开问题反馈app，连续按5次左上角在线反馈后，会自动打开Log抓取设置页面）</li><li>进入抓取页面后，把所有log选项都打开</li><li>点击开始记录离线日志，点击后软件会在回后台运行记录日志</li><li>复现你所发现的bug或问题后，按照上面的方法再次进入Log抓取页，点击停止记录，选择复现了，保存日志。</li><li>保存日志后会自动打开在线反馈页面，请直接点返回键，放弃在线提交。(切记不要点提交!)</li><li>返回桌面，找到文件管理app打开。依次点击：手机储存→logs→ArchivedLogs。这时可以看到抓取的log日志就保存在ArchivedLogs文件夹下</li><li>把抓取的log日志压缩后可以发送给工程师们咯</li></ol><h3 id="酷派"><a href="#酷派" class="headerlink" title="酷派"></a>酷派</h3><hr><h3 id="MTK平台："><a href="#MTK平台：" class="headerlink" title="MTK平台："></a>MTK平台：</h3><p>一、 如何抓取日志？</p><ol><li>进入拨号盘，输入*20121220#进入工程模式，选择【MTK_Engineermode】。</li><li>左划到【Log and Debugging】下并点选【MTKLogger】。</li><li>点击图标抓取日志。<br>日志抓取是可home键挂后台并会在托盘显示日志正在运行提示，下拉托盘点击即可进入日志抓取界面。<br>注意：日志开启后，操作出现异常日志方有效，提供日志时同时提供问题发生时间点，以便定位问题。</li></ol><p>二、如何调整日志输出等级？<br>1、进入工程模式中后，进入日志输出等级，就是下面的截图<br>2、分别将Java log level和Cand C++ log level的日志等级调整为LOGV：<br>3、将Kernel log level的输出等级调整为最后的KERN_DEBUG：<br>三、如何保存日志？</p><ol><li>在日志抓取界面，点击结束图标，停止日志抓取。日志会自动保存到/storage/emulated/0/mtklog目录下。</li><li>进入文件管理器，在/storage/emulated/0/mtklog目录下，将【mdlog】、【mobilelog】、【netlog】三个文件夹一起压缩打包即可。<br>四、如何清除日志文件？</li><li>在日志抓取界面，点击删除图标，选择【CLEAR ALL】清除日志文件。<br>注意：长时间开启日志抓取会占用存储空间，建议及时清除日志文件。</li></ol><h3 id="高通平台："><a href="#高通平台：" class="headerlink" title="高通平台："></a>高通平台：</h3><p>方法如下：<br>1 、从拨号盘输入*20121220#进入到工程模式<br>2 、进入 日志输出等级<br>3、 按照如下的说明设置一下日志级别<br>       java log level 选择 LOGV (即第一项)<br>       c and c++ log level 选择  LOGV (即第一项)<br>       kernel log level 选择 KERN_DEBUG (即最后一项)<br>按照上面的设置之后，返回上一级<br>4、 进入 离线日志设置 进行如下的操作:<br>      (1)取消 离线日志开关  的钩钩,  然后依次点击菜单最后两行是 删除以前所有的日志 和 清除日志缓冲区。<br>      (2)进入 日志缓冲区类型，请勾选除最后一项“Elog日志转储”之外的所有选项，即勾选Main缓冲区，Radio缓 冲区，Events缓冲区，system缓冲区，网络日志转储，内核日志转储，QXDM日志转储。然后按  确定 ，请务必保证  QXDM日志转储  勾选上。<br>     (3)日志转储设为NO<br>     (4)完成上面的操作之后 ，重新将 离线日志开关 勾选上。<br>     (5)重启机器，按照你的操作步骤操作。<br>     (6)从/sdcard/log中把日志压缩发给我们，谢谢！</p><p>使用ADB抓取系统log<br>一、配置环境变量<br>电脑桌面上右击 计算机–&gt;属性–&gt;高级系统配置–&gt;环境变量，在 系统变量 中找到path（没有可以新建一个）。点击path后再变量值的开头加上你的路径“d:adb;”，切记路径最后还要带个分号。点击确定–&gt;确定，如此就完成了环境变量的配置。<br>二、抓log<br>将手机与电脑用数据线相连。<br>打开命令行（开始–&gt;附件–&gt;命令提示符），然后进行一下步骤：</p><ol><li>显示现在连接的手机设备：输入 adb devices  + 回车</li><li>抓log：输入 adb logcat + 回车</li><li>停止抓log：使用ctrl + c</li><li>将log导出：adb logcat &gt; d：1.txt（将log导出到d：/1.txt文件中<br>ADB工具下载地址：<a href="https://yunpan.cn/cWkyshMeDeKDf" target="_blank" rel="noopener">https://yunpan.cn/cWkyshMeDeKDf</a>  访问密码 8a91</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是部分手机抓取日志方法&lt;/p&gt;
&lt;h3 id=&quot;360手机&quot;&gt;&lt;a href=&quot;#360手机&quot; class=&quot;headerlink&quot; title=&quot;360手机&quot;&gt;&lt;/a&gt;360手机&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;1） 在桌面的【其他应用】文件夹找到【用户反馈】，或通过搜索找到
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>开发工具整理(转)</title>
    <link href="http://yoursite.com/2018/07/14/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/14/开发工具整理/</id>
    <published>2018-07-14T09:03:39.000Z</published>
    <updated>2018-07-14T09:21:11.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="辅助开发工具"><a href="#辅助开发工具" class="headerlink" title="辅助开发工具"></a>辅助开发工具</h2><p>转自： <a href="https://github.com/389273716/android-skill-summary" target="_blank" rel="noopener">https://github.com/389273716/android-skill-summary</a></p><ol><li><a href="http://tool.lu/json/" title="Title" target="_blank" rel="noopener">json格式化 - 在线工具</a></li><li><a href="http://www.th7.cn/Program/Android/201501/344556.shtml" title="Title" target="_blank" rel="noopener">android 不透明度16进制值</a></li><li><a href="http://tool.oschina.net/codeformat/json" title="Title" target="_blank" rel="noopener">在线代码格式化</a></li><li><a href="https://docs.bugtags.com/zh/start/integrate/android/manually.html" title="Title" target="_blank" rel="noopener">手动集成 | Bugtags 是移动时代首选 Bug 管理系统，针对不同的使用场景，Bugtags 具有以下强大特性： - 移动时代首选 Bug 管理系统 | 简单·高效·智能·云端管理</a></li><li><a href="https://mockingbot.com/workspace#apps/p88946F55BA1457319844154/templates" title="Title" target="_blank" rel="noopener">墨刀 - 猿理</a></li><li><a href="http://wowubuntu.com/markdown/" title="Title" target="_blank" rel="noopener">Markdown 语法说明(简体中文版)</a></li><li><a href="https://duotai.org/dashboard" title="Title" target="_blank" rel="noopener">多态-vpn</a></li><li><a href="https://github.com/getlantern/lantern" title="Title" target="_blank" rel="noopener">getlantern/lantern: Open Internet for everyone. Lantern is a free application that delivers fast, reliable and secure access to the open Internet for users in censored regions. It uses a variety of techniques to stay unblocked, including domain fronting, p2p, and pluggable transports.</a></li><li><a href="http://blog.csdn.net/forlong401/article/details/45102119" title="Title" target="_blank" rel="noopener">facebook的Android调试工具Stetho介绍 - forlong401的专栏–有问题上：http://www.androidren.com - 博客频道 - CSDN.NET</a></li><li><a href="http://www.jianshu.com/p/62bcbb2a5833" title="Title" target="_blank" rel="noopener">一些浏览器插件，比如同步手机屏幕到pc</a></li><li><a href="https://www.codota.com/" title="Title" target="_blank" rel="noopener">代码搜索</a></li><li><a href="http://ju.outofmemory.cn/entry/22854" title="Title" target="_blank" rel="noopener">使用Fiddler调试手机页面请求 - 为程序员服务</a></li><li><a href="https://searchcode.com/" title="Title" target="_blank" rel="noopener">searchcode搜索代码</a></li><li><a href="https://github.com/kiruto/debug-bottle" title="Title" target="_blank" rel="noopener">debug插件 debug-bottle</a></li><li><a href="http://www.cnplugins.com/" title="Title" target="_blank" rel="noopener">Chrome插件,Chrome商店,谷歌浏览器插件下载 - Chrome插件网</a></li><li><a href="https://github.com/skyhacker2/SQLiteOnWeb-Android" title="Title" target="_blank" rel="noopener">skyhacker2/SQLiteOnWeb-Android: Manage you Sqlite Database in browser</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650237619&amp;idx=1&amp;sn=ccfc790d4e203549b8c9d83d641207fd&amp;chksm=88639bdcbf1412ca91d6ae9b8c3ef9bc1596e956fd04f1d5a1d157d836436ad10483fc7f4817&amp;scene=0#wechat_redirect" title="Title" target="_blank" rel="noopener">利用Jenkins玩转Android自动打包发包</a></li><li><a href="https://github.com/xitu/gold-miner/blob/master/TODO/exploring-firebase-on-android-ios-analytics.md" title="Title" target="_blank" rel="noopener">探索 Firebase 在 Android 和 iOS 的使用: 分析</a></li><li><a href="http://droidyue.com/blog/2014/08/03/great-web-tools-for-android-development/" title="Title" target="_blank" rel="noopener">快速提高Android开发效率的Web工具</a></li><li><a href="http://droidyue.com/blog/2016/05/22/use-checkstyle-for-better-code-style/" title="Title" target="_blank" rel="noopener">Android代码规范利器： Checkstyle</a></li><li><a href="https://gold.xitu.io/entry/57ae98217db2a2005416394d" title="Title" target="_blank" rel="noopener">Android Studio ＋Vim</a></li><li><a href="https://zhuanlan.zhihu.com/p/21250613" title="Title" target="_blank" rel="noopener">一招鲜，吃遍天！这是一篇专供收藏的 Chrome 插件推荐</a></li><li><a href="https://tech.meituan.com/android_custom_lint.html#" title="Title" target="_blank" rel="noopener">Android自定义Lint实践</a></li><li><a href="https://github.com/amitshekhariitbhu/Android-Debug-Database" title="Title" target="_blank" rel="noopener">Android Debug Database数据库debug工具</a></li><li><a href="https://segmentfault.com/p/1210000009108620/read" title="Title" target="_blank" rel="noopener">如何在Windows下像Mac一样优雅开发?</a></li><li><a href="https://zhuanlan.zhihu.com/p/26101114?utm_source=com.ideashower.readitlater.pro&amp;utm_medium=social" title="Title" target="_blank" rel="noopener">告诉你三个我用的高效软件工具</a></li><li><a href="https://juejin.im/entry/58c65e3aa22b9d0058b36be7" title="Title" target="_blank" rel="noopener">震惊！如此多的 Android 开发技巧！</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;辅助开发工具&quot;&gt;&lt;a href=&quot;#辅助开发工具&quot; class=&quot;headerlink&quot; title=&quot;辅助开发工具&quot;&gt;&lt;/a&gt;辅助开发工具&lt;/h2&gt;&lt;p&gt;转自： &lt;a href=&quot;https://github.com/389273716/android-skil
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android debug 神器</title>
    <link href="http://yoursite.com/2018/07/12/Android-debug-%E7%A5%9E%E5%99%A8/"/>
    <id>http://yoursite.com/2018/07/12/Android-debug-神器/</id>
    <published>2018-07-12T06:07:44.000Z</published>
    <updated>2018-07-12T07:09:43.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🍼Debug-Bottle"><a href="#🍼Debug-Bottle" class="headerlink" title="🍼Debug Bottle"></a>🍼Debug Bottle</h1><ul><li><a href="#Http监听">简易的HTTP请求嗅探</a><br>转自 <a href="https://github.com/kiruto/debug-bottle" target="_blank" rel="noopener">https://github.com/kiruto/debug-bottle</a></li></ul><hr><p>Android Java / Kotlin 程序员开发调试工具。Debug Bottle的所有功能均建立在App的debug版本中，不会对release版本产生任何影响。Debug Bottle旨在提高开发效率，把控App质量。</p><ul><li><a href="docs/zh-CN/README.md">开发文档</a></li><li><a href="CHANGELOG.md">CHANGELOG</a></li><li><a href="TODO.md">TODO</a></li></ul><p>Demo App可在Google Play中下载:</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li><a href="#Http监听">简易的HTTP请求嗅探</a></li><li><a href="#3D化视图">3D化Activity视图</a></li><li><a href="#shared-preferences编辑器">Shared Preferences编辑器</a></li><li><a href="#使用strict-mode">使用Strict mode调试软件</a></li><li><a href="#崩溃日志">截获App崩溃，收集崩溃日志</a></li><li><a href="#使用leak-canary">轻松找到可能出现的内存泄漏代码</a></li><li><a href="#使用block-canary">找到可能出现的UI卡顿代码</a></li><li><a href="#进入一切activity并注入参数">简易创造Activity入口，及测试Runnable</a></li></ul><h4 id="Http监听"><a href="#Http监听" class="headerlink" title="Http监听"></a>Http监听</h4><p>通过OkHttp的拦截器监听通过App的Http请求，并记录在Debug Bottle的日志中。记录过的日志可以通过分享按钮分享给其他开发者。</p><h4 id="3D化视图"><a href="#3D化视图" class="headerlink" title="3D化视图"></a>3D化视图</h4><p>通过设置打开“3D”功能，可以更直观地看到当前Activity的layout结构。<br>本功能支持单点手势旋转，双点手势缩放和位移。</p><h4 id="Shared-Preferences编辑器"><a href="#Shared-Preferences编辑器" class="headerlink" title="Shared Preferences编辑器"></a>Shared Preferences编辑器</h4><p>通过Debug Bottle可以简单地编辑App用到的所有Shared Preferences。</p><h4 id="使用Strict-Mode"><a href="#使用Strict-Mode" class="headerlink" title="使用Strict Mode"></a>使用Strict Mode</h4><p>Debug Bottle可以在运行时启用或禁用Strict Mode。StrictMode最常用来捕捉应用程序的主线程，它将报告与线程及虚拟机相关的策略违例。一旦检测到策略违例（policy violation），你将获得警告，其包含了一个栈trace显示你的应用在何处发生违例。除了主线程，我们还可以在Handler，AsyncTask，AsyncQueryHandler，IntentService等API中使用StrictMode。更多使用方法介绍，参见<a href="https://developer.android.com/reference/android/os/StrictMode.html" target="_blank" rel="noopener">官方开发者文档</a>。</p><h4 id="崩溃日志"><a href="#崩溃日志" class="headerlink" title="崩溃日志"></a>崩溃日志</h4><p>收集所有崩溃的信息，存储成日志文件。</p><h4 id="使用Leak-Canary"><a href="#使用Leak-Canary" class="headerlink" title="使用Leak Canary"></a>使用Leak Canary</h4><p>Debug Bottle中编译进了Leak Canary，所有Leak Canary的功能都可以使用了，并且可以通过Debug Bottle来控制开关。Leak Canary的使用方法请参考<a href="https://github.com/square/leakcanary/wiki/FAQ" target="_blank" rel="noopener">官方Wiki</a>。</p><h4 id="使用Block-Canary"><a href="#使用Block-Canary" class="headerlink" title="使用Block Canary"></a>使用Block Canary</h4><p>加入了支持Kotlin的Block Canary，可以监控UI线程卡死。</p><h4 id="进入一切Activity并注入参数"><a href="#进入一切Activity并注入参数" class="headerlink" title="进入一切Activity并注入参数"></a>进入一切Activity并注入参数</h4><p>简单的Activity／Runnable入口。可以随心所欲进入任何一个Activity，使用任何参数，甚至可以向App中注入想要测试的Intent。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>安装嵌入Debug Bottle的App后，你将看到初你App外的新图标🍼。点击进入Debug面板。</p><h2 id="搭建方法"><a href="#搭建方法" class="headerlink" title="搭建方法"></a>搭建方法</h2><h4 id="1-加入Gradle依赖"><a href="#1-加入Gradle依赖" class="headerlink" title="1. 加入Gradle依赖"></a>1. 加入Gradle依赖</h4><p>首先在工程Gradle文件中添加snapshot源：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">"https://oss.sonatype.org/content/repositories/snapshots"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在主模块中（Application类所在模块）加入依赖：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    debugCompile <span class="string">'com.exyui.android:debug-bottle-runtime:1.1.1'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果你的工程是Java工程,使用此依赖</span></span><br><span class="line">    releaseCompile <span class="string">'com.exyui.android:debug-bottle-noop-java:1.1.1'</span></span><br><span class="line">    testCompile <span class="string">'com.exyui.android:debug-bottle-noop-java:1.1.1'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果你的工程是Kotlin工程,使用此依赖</span></span><br><span class="line">    releaseCompile <span class="string">'com.exyui.android:debug-bottle-noop-kotlin:1.1.1'</span></span><br><span class="line">    testCompile <span class="string">'com.exyui.android:debug-bottle-noop-kotlin:1.1.1'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:23.2.0+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Debug Bottle不仅支持API 23+，还可以支持API 22. 若想使用API 22，请按照下面方式加入依赖：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    debugCompile <span class="string">'com.exyui.android:debug-bottle-runtime:1.0.6-support22'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果你的工程是Java工程,使用此依赖</span></span><br><span class="line">    releaseCompile <span class="string">'com.exyui.android:debug-bottle-noop-java:1.0.6-support22'</span></span><br><span class="line">    testCompile <span class="string">'com.exyui.android:debug-bottle-noop-java:1.0.6-support22'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果你的工程是Kotlin工程,使用此依赖</span></span><br><span class="line">    releaseCompile <span class="string">'com.exyui.android:debug-bottle-noop-kotlin:1.0.6-support22'</span></span><br><span class="line">    testCompile <span class="string">'com.exyui.android:debug-bottle-noop-kotlin:1.0.6-support22'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:22+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若只需支持API23，请按照下面方式加入依赖:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    debugCompile <span class="string">'com.exyui.android:debug-bottle-runtime:1.0.6-support23'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果你的工程是Java工程,使用此依赖</span></span><br><span class="line">    releaseCompile <span class="string">'com.exyui.android:debug-bottle-noop-java:1.0.6-support23'</span></span><br><span class="line">    testCompile <span class="string">'com.exyui.android:debug-bottle-noop-java:1.0.6-support23'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果你的工程是Kotlin工程,使用此依赖</span></span><br><span class="line">    releaseCompile <span class="string">'com.exyui.android:debug-bottle-noop-kotlin:1.0.6-support23'</span></span><br><span class="line">    testCompile <span class="string">'com.exyui.android:debug-bottle-noop-kotlin:1.0.6-support23'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:23+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-编辑Manifest"><a href="#2-编辑Manifest" class="headerlink" title="2. 编辑Manifest"></a>2. 编辑Manifest</h4><p>加入Debug Bottle的主Activity：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.exyui.android.debugbottle.components.DTDrawerActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@style/Theme.AppCompat.Light"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"调试工具"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>“调试工具”是Debug Bottle在Android launch pad中显示的名称, 可以随意命名。</p><h4 id="3-在Application中插入Debug-Bottle代码"><a href="#3-在Application中插入Debug-Bottle代码" class="headerlink" title="3. 在Application中插入Debug Bottle代码"></a>3. 在Application中插入Debug Bottle代码</h4><p>首先实现Block Canary运行必要的上下文类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppBlockCanaryContext</span> <span class="keyword">extends</span> <span class="title">BlockCanaryContext</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p><p>然后在Application的onCreate中插入代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        DTInstaller.install(<span class="keyword">this</span>)</span><br><span class="line">            .setBlockCanary(<span class="keyword">new</span> AppBlockCanaryContext(<span class="keyword">this</span>))</span><br><span class="line">            .setOkHttpClient(httpClient)</span><br><span class="line">            .setInjector(<span class="string">"your.package.injector.ContentInjector"</span>)</span><br><span class="line">            .setPackageName(<span class="string">"your.package"</span>)</span><br><span class="line">            .enable()</span><br><span class="line">            .run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者如果你的工程是Kotlin,你还可以这样写:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span>: <span class="type">Application</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        DTInstaller.install(<span class="keyword">this</span>)</span><br><span class="line">            .setBlockCanary(AppBlockCanaryContext(<span class="keyword">this</span>))</span><br><span class="line">            .setOkHttpClient(httpClient)</span><br><span class="line">            .setInjector(<span class="string">"your.package.injector.ContentInjector"</span>)</span><br><span class="line">            .setPackageName(<span class="string">"your.package"</span>)</span><br><span class="line">            .enable()</span><br><span class="line">            .run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>收工。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">Leak Canary</a></li><li><a href="https://github.com/markzhai/AndroidPerformanceMonitor" target="_blank" rel="noopener">Android Performance Monitor</a></li><li><a href="https://github.com/JakeWharton/scalpel" target="_blank" rel="noopener">Scalpel</a></li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Debug Bottle</span><br><span class="line"></span><br><span class="line">Copyright 2016 Yuriel (http://exyui.com).</span><br><span class="line"></span><br><span class="line">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line">you may not use this file except in compliance with the License.</span><br><span class="line">You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">   http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">Unless required by applicable law or agreed to in writing, software</span><br><span class="line">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">See the License for the specific language governing permissions and</span><br><span class="line">limitations under the License.</span><br></pre></td></tr></table></figure><p>Debug Bottle 功能实现是基于以下项目的派生:</p><ul><li>Apache License 2.0<ul><li><a href="https://raw.githubusercontent.com/markzhai/AndroidPerformanceMonitor/master/LICENSE" target="_blank" rel="noopener">Android Performance Monitor</a></li><li><a href="https://raw.githubusercontent.com/square/leakcanary/master/LICENSE.txt" target="_blank" rel="noopener">Leak Canary</a></li><li><a href="https://raw.githubusercontent.com/JakeWharton/scalpel/master/LICENSE.txt" target="_blank" rel="noopener">Scalpel</a></li><li><a href="https://raw.githubusercontent.com/txusballesteros/bubbles-for-android/master/LICENSE" target="_blank" rel="noopener">Bubbles for Android</a></li><li><a href="https://raw.githubusercontent.com/wasabeef/Takt/master/LICENSE" target="_blank" rel="noopener">Takt</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;🍼Debug-Bottle&quot;&gt;&lt;a href=&quot;#🍼Debug-Bottle&quot; class=&quot;headerlink&quot; title=&quot;🍼Debug Bottle&quot;&gt;&lt;/a&gt;🍼Debug Bottle&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#Http监听
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 反射机制</title>
    <link href="http://yoursite.com/2018/07/11/Java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/07/11/Java-反射机制/</id>
    <published>2018-07-11T08:22:04.000Z</published>
    <updated>2018-07-11T08:22:24.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第-16-章-反射（Reflection）"><a href="#第-16-章-反射（Reflection）" class="headerlink" title="第 16 章 反射（Reflection）"></a>第 16 章 反射（Reflection）</h1><p>2016-09-29 转自：<a href="https://github.com/JustinSDK/JavaSE6Tutorial/blob/master/docs/CH16.md" target="_blank" rel="noopener">https://github.com/JustinSDK/JavaSE6Tutorial/blob/master/docs/CH16.md</a></p><p>Java 提供的反射机制允许您于执行时期动态加载类别、检视类别信息、生成对象或操作生成的对象，要举反射机制的一个应用实例，就是在集成开发环境中所提供的方法提示或是类别检视工具，另外像 JSP 中的 JavaBean 自动收集请求信息也使用到反射，而一些软件开发框架（Framework）也常见到反射机制的使用，以达到动态加载用户自定义类别的目的。</p><p>即使您暂时用不到反射机制，也建议您花时间看看这个章节，藉由对反射机制的认识，您可以了解 Java 中是如何加载类别的，而且了解到每个被载入的类别在 JVM 中，都以 Class 类别的一个实例存在的事实。</p><hr><h2 id="16-1-类别载入与检视"><a href="#16-1-类别载入与检视" class="headerlink" title="16.1 类别载入与检视"></a>16.1 类别载入与检视</h2><p>即使您拿到一个类别并对它一无所知，但其实它本身就包括了许多信息，Java 在需要使用到某个类别时才会将类别加载，并在 JVM 中以一个 java.lang.Class 的实例存在，从 Class 实例开始，您可以获得类别的许多讯息。</p><h3 id="16-1-1-简介-Class-与类别载入"><a href="#16-1-1-简介-Class-与类别载入" class="headerlink" title="16.1.1 简介 Class 与类别载入"></a>16.1.1 简介 Class 与类别载入</h3><p>Java 在真正需要使用一个类别时才会加以加载，而不是在程序启动时就加载所有的类别，因为大多数的使用者都只使用到应用程序的部份资源，在需要某些功能时才加载某些资源，可以让系统的资源运用更有效率（Java 本来就是为了资源有限的小型设备而设计的，这样的考虑是必然的）。</p><p>一个 java.lang.Class 对象代表了 Java 应用程序在运行时所加载的类别或接口实例，也用来表达 enum（属于类别的一种）、 annotation（属于接口的一种）、数组、原生型态（Primitive type）、void；Class 类别没有公开的（public）建构方法，Class 对象是由 JVM 自动产生，每当一个类别被加载时，JVM 就自动为其生成一个 Class 对象。</p><p>您可以透过 Object 的 getClass() 方法来取得每一个对象对应的 Class 对象，或者是透过 “class” 常量（Class literal），在取得 Class 对象之后，您就可以操作 Class 对象上的一些公开方法来取得类别的基本信息，范例 16.1 简单的使用 getClass() 方法来取得 String 类别的 Class 实例，并从中得到 String 的一些基本信息。</p><h4 id="范例-16-1-ClassDemo-java"><a href="#范例-16-1-ClassDemo-java" class="headerlink" title="范例 16.1  ClassDemo.java"></a><strong>范例 16.1  ClassDemo.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">"caterpillar"</span>;</span><br><span class="line">        Class stringClass = name.getClass();</span><br><span class="line">        System.out.println(<span class="string">"类别名称："</span> +</span><br><span class="line">                    stringClass.getName());</span><br><span class="line">        System.out.println(<span class="string">"是否为接口："</span> +</span><br><span class="line">                    stringClass.isInterface());</span><br><span class="line">        System.out.println(<span class="string">"是否为基本型态："</span> +</span><br><span class="line">                    stringClass.isPrimitive());</span><br><span class="line">        System.out.println(<span class="string">"是否为数组对象："</span> +</span><br><span class="line">                    stringClass.isArray());</span><br><span class="line">        System.out.println(<span class="string">"父类别名称："</span> +</span><br><span class="line">                    stringClass.getSuperclass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><pre><code>类别名称：java.lang.String是否为接口：false是否为基本型态：false是否为数组对象：false父类别名称：java.lang.Object</code></pre><p>您也可以直接使用以下的方式来取得 String 类别的 Class 对象：</p><pre><code>Class stringClass = String.class;</code></pre><p>Java 在真正需要类别时才会加载类别，所谓「真正需要」通常指的是要使用指定的类别生成对象时（或是用户指定要加载类别时，例如使用 Class.forName() 加载类别，或是使用 ClassLoader 的 loadClass() 加载类别，稍后都会说明）。使用类别名称来宣告参考名称并不会导致类别的加载，可以设计一个测试类别的印证这个说法。</p><h4 id="范例-16-2-TestClass-java"><a href="#范例-16-2-TestClass-java" class="headerlink" title="范例 16.2  TestClass.java"></a><strong>范例 16.2  TestClass.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"类别被载入"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在范例中定义了一个静态区块，「默认」在类别第一次被加载时会执行静态区块（说默认的原因，是因为可以设定加载类别时不执行静态区块，使用 Class 生成对象时才执行静态区块，稍后会介绍），藉由在文本模式下显示讯息，您可以了解类别何时被加载，可以使用范例 16.3 来测试类别加载时机。</p><h4 id="范例-16-3-LoadClassTest-java"><a href="#范例-16-3-LoadClassTest-java" class="headerlink" title="范例 16.3  LoadClassTest.java"></a><strong>范例 16.3  LoadClassTest.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestClass test = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"宣告TestClass参考名称"</span>);</span><br><span class="line">        test = <span class="keyword">new</span> TestClass();</span><br><span class="line">        System.out.println(<span class="string">"生成TestClass实例"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><pre><code>宣告TestClass参考名称类别被载入生成TestClass实例</code></pre><p>从执行结果中可以看出，宣告参考名称并不导致 TestClass 类别被加载，而是在使用 “new” 生成对象时才会加载类别。</p><p>Class 的讯息是在编译时期就被加入至 .class 档案中，这是 Java 支持执行时期型别辨识（RTTI，Run-Time Type Information或Run-Time Type Identification）的一种方式，在编译时期编译程序会先检查对应的 .class 档案，而执行时期JVM在使用某类别时，会先检查对应的 Class 对象是否已经加载，如果没有加载，则会寻找对应的 .class 档案并载入，一个类别在 JVM 中只会有一个 Class 实例，每个类别的实例都会记得自己是由哪个 Class 实例所生成，您可以使用 getClass() 或 .class 来取得 Class 实例。</p><p><img src="/blog/2018/07/11/Java-反射机制/images/img16-01.png" alt="每个对象会记得生成它的 Class 实例"></p><p>图 16.1 每个对象会记得生成它的 Class 实例</p><p>在 Java 中，数组也是一个对象，也有其对应的 Class 实例，这个对象是由具相同元素与维度的数组所共享，而基本型态像是 boolean, byte, char, short, int, long, float, double 以及关键词 void，也都有对应的 Class 对象，您可以用类别常量（Class literal）来取得这些对象。</p><h4 id="范例-16-4-ClassDemo2-java"><a href="#范例-16-4-ClassDemo2-java" class="headerlink" title="范例 16.4  ClassDemo2.java"></a><strong>范例 16.4  ClassDemo2.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">boolean</span>.class);</span><br><span class="line">        System.out.println(<span class="keyword">void</span>.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] iarr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        System.out.println(iarr.getClass().toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[] darr = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">10</span>];</span><br><span class="line">        System.out.println(darr.getClass().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><pre><code>booleanvoidclass [Iclass [D</code></pre><p>在 Java 中数组确实是以对象的形式存在，其对应的类别是由 JVM 自动生成，当您使用 toString() 来显示数组对象的描述时，[表示为数组型态，并加上一个型态代表字，范例中I表示是一个 int 数组，而 D 表示是一个 double 数组，16.2.4 还会对数组对象加以讨论。</p><h3 id="16-1-2-使用-Class-forName-载入类别"><a href="#16-1-2-使用-Class-forName-载入类别" class="headerlink" title="16.1.2 使用 Class.forName() 载入类别"></a>16.1.2 使用 Class.forName() 载入类别</h3><p>在一些应用中，您无法事先知道使用者将加载什么类别，而必须让使用者指定类别名称以加载类别，您可以使用 Class 的静态 forName() 方法实现动态加载类别，范例 16.5 是个简单示范，可以让您可以指定类别名称来获得类别的相关信息。</p><h4 id="范例-16-5-ForNameDemo-java"><a href="#范例-16-5-ForNameDemo-java" class="headerlink" title="范例 16.5  ForNameDemo.java"></a><strong>范例 16.5  ForNameDemo.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForNameDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">            System.out.println(<span class="string">"类别名称："</span> +</span><br><span class="line">                          c.getName());</span><br><span class="line">            System.out.println(<span class="string">"是否为接口："</span> +</span><br><span class="line">                             c.isInterface());</span><br><span class="line">            System.out.println(<span class="string">"是否为基本型态："</span> +</span><br><span class="line">                             c.isPrimitive());</span><br><span class="line">            System.out.println(<span class="string">"是否为数组："</span> + c.isArray());</span><br><span class="line">            System.out.println(<span class="string">"父类别："</span> +</span><br><span class="line">                             c.getSuperclass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有指定类别名称"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到指定的类别"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在指定类别给 forName() 方法后，如果找不到指定的类别，会丢出 ClassNotFoundException 例外，一个的执行结果如下：</p><pre><code>java onlyfun.caterpillar.ForNameDemo java.util.Scanner类别名称：java.util.Scanner是否为接口：false是否为基本型态：false是否为数组：false父类别：java.lang.Object</code></pre><p>Class 的静态 forName() 方法有两个版本，范例16.5所示范的是只指定类别名称的版本，而另一个版本可以让您指定类别名称、加载类别时是否执行静态区块、指定类别加载器（Class loader）：</p><pre><code>static Class forName(String name, boolean initialize, ClassLoader loader)</code></pre><p>之前曾经说过，预设上在加载类别的时候，如果类别中有定义静态区块则会执行它，您可以使用 forName() 的第二个版本，将 initialize 设定为 false，如此在加载类别时并不会马上执行静态区块，而会在使用类别建立对象时才执行静态区块，为了印证，您可以先设计一个测试类别。</p><h4 id="范例-16-6-TestClass2-java"><a href="#范例-16-6-TestClass2-java" class="headerlink" title="范例 16.6  TestClass2.java"></a><strong>范例 16.6  TestClass2.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"[执行静态区块]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>范例 16.6 中只定义了静态区块显示一段讯息，以观察静态区块何时被执行，您可以设计范例 16.7 使用第一个版本的 forName() 方法。</p><h4 id="范例-16-7-ForNameDemoV1-java"><a href="#范例-16-7-ForNameDemoV1-java" class="headerlink" title="范例 16.7  ForNameDemoV1.java"></a><strong>范例 16.7  ForNameDemoV1.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForNameDemoV1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"载入TestClass2"</span>);</span><br><span class="line">            Class c = Class.forName(<span class="string">"onlyfun.caterpillar.TestClass2"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"使用TestClass2宣告参考名称"</span>);</span><br><span class="line">            TestClass2 test = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"使用TestClass2建立对象"</span>);                        </span><br><span class="line">            test = <span class="keyword">new</span> TestClass2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到指定的类别"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><pre><code>载入TestClass2[执行静态区块]使用TestClass2宣告参考名称使用TestClass2建立对象</code></pre><p>从执行结果中可以看到，第一个版本的 forName() 方法在加载类别之后，默认会马上执行静态区块，来看看范例 16.8 中使用第二个版本的 forName() 方法会是如何。</p><h4 id="范例-16-8-ForNameDemoV2-java"><a href="#范例-16-8-ForNameDemoV2-java" class="headerlink" title="范例 16.8  ForNameDemoV2.java"></a><strong>范例 16.8  ForNameDemoV2.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForNameDemoV2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"载入TestClass2"</span>);</span><br><span class="line">            Class c = Class.forName(</span><br><span class="line">                         <span class="string">"onlyfun.caterpillar.TestClass2"</span>,</span><br><span class="line">                         <span class="keyword">false</span>, <span class="comment">// 加载类别时不执行静态方法</span></span><br><span class="line">                         Thread.currentThread().getContextClassLoader());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"使用TestClass2宣告参考名称"</span>);</span><br><span class="line">            TestClass2 test = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"使用TestClass2建立对象"</span>);                        </span><br><span class="line">            test = <span class="keyword">new</span> TestClass2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到指定的类别"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><pre><code>载入TestClass2使用TestClass2宣告参考名称使用TestClass2建立对象[执行静态区块]</code></pre><p>由于使用第二个版本的 forName() 方法时，设定 initialize 为 false，所以加载类别时并不会马上执行静态区块，而会在使用类别建立对象时才去执行静态区块，第二个版本的 forName() 方法会需要一个类别加载器（Class loader），范例中所使用的是主线程的类别加载器，16.1.4 还会详细介绍 Java 中的类别加载器机制。</p><h3 id="16-1-3-从-Class-中获取信息"><a href="#16-1-3-从-Class-中获取信息" class="headerlink" title="16.1.3 从 Class 中获取信息"></a>16.1.3 从 Class 中获取信息</h3><p>Class 对象表示所加载的类别，取得 Class 对象之后，您就可以取得与类别相关联的信息，像是套件（package）（别忘了 package 也是类别名称的一部份）、建构方法、方法成员、数据成员等的讯息，而每一个讯息，也会有相应的类别型态，例如套件的对应型态是 java.lang.Package，建构方法的对应型态是 java.lang.reflect.Constructor，方法成员的对应型态是 java.lang.reflect.Method，数据成员的对应型态是 java.lang.reflect.Field 等。</p><p>来看个简单的示范，范例 16.9 可以让您取得所指定类别上的套件名称。</p><h4 id="范例-16-9-ClassInfoDemo-java"><a href="#范例-16-9-ClassInfoDemo-java" class="headerlink" title="范例 16.9  ClassInfoDemo.java"></a><strong>范例 16.9  ClassInfoDemo.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInfoDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">            Package p = c.getPackage();</span><br><span class="line">            System.out.println(p.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有指定类别"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到指定类别"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><pre><code>java onlyfun.caterpillar.ClassInfoDemo java.util.ArrayListjava.util</code></pre><p>您可以分别取回 Field、Constructor、Method等对象，分别代表数据成员、建构方法与方法成员，范例16.10 简单的实作了取得类别基本信息的程序。</p><h4 id="范例-16-10-SimpleClassViewer-java"><a href="#范例-16-10-SimpleClassViewer-java" class="headerlink" title="范例 16.10  SimpleClassViewer.java"></a><strong>范例 16.10  SimpleClassViewer.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClassViewer</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 取得套件代表对象</span></span><br><span class="line">            Package p = c.getPackage();</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">"package %s;%n"</span>, p.getName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取得型态修饰，像是class、interface</span></span><br><span class="line">            <span class="keyword">int</span> m = c.getModifiers();</span><br><span class="line"></span><br><span class="line">            System.out.print(Modifier.toString(m) + <span class="string">" "</span>);</span><br><span class="line">            <span class="comment">// 如果是接口</span></span><br><span class="line">            <span class="keyword">if</span>(Modifier.isInterface(m)) &#123;</span><br><span class="line">                System.out.print(<span class="string">"interface "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">"class "</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(c.getName() + <span class="string">" &#123;"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取得宣告的数据成员代表对象</span></span><br><span class="line">            Field[] fields = c.getDeclaredFields();</span><br><span class="line">            <span class="keyword">for</span>(Field field : fields) &#123;</span><br><span class="line">                <span class="comment">// 显示权限修饰，像是public、protected、private</span></span><br><span class="line">                System.out.print(<span class="string">"\t"</span> +</span><br><span class="line">                    Modifier.toString(field.getModifiers()));</span><br><span class="line">                <span class="comment">// 显示型态名称</span></span><br><span class="line">                System.out.print(<span class="string">" "</span> +</span><br><span class="line">                    field.getType().getName() + <span class="string">" "</span>);</span><br><span class="line">                <span class="comment">// 显示数据成员名称</span></span><br><span class="line">                System.out.println(field.getName() + <span class="string">";"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取得宣告的建构方法代表对象            </span></span><br><span class="line">            Constructor[] constructors =</span><br><span class="line">                            c.getDeclaredConstructors();</span><br><span class="line">            <span class="keyword">for</span>(Constructor constructor : constructors) &#123;</span><br><span class="line">                <span class="comment">// 显示权限修饰，像是public、protected、private</span></span><br><span class="line">                System.out.print(<span class="string">"\t"</span> +</span><br><span class="line">                     Modifier.toString(</span><br><span class="line">                       constructor.getModifiers()));</span><br><span class="line">                <span class="comment">// 显示建构方法名称</span></span><br><span class="line">                System.out.println(<span class="string">" "</span> +</span><br><span class="line">                      constructor.getName() + <span class="string">"();"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 取得宣告的方法成员代表对象             </span></span><br><span class="line">            Method[] methods = c.getDeclaredMethods();</span><br><span class="line">            <span class="keyword">for</span>(Method method : methods) &#123;</span><br><span class="line">                <span class="comment">// 显示权限修饰，像是public、protected、private</span></span><br><span class="line">                System.out.print(<span class="string">"\t"</span> +</span><br><span class="line">                     Modifier.toString(</span><br><span class="line">                              method.getModifiers()));</span><br><span class="line">                <span class="comment">// 显示返回值型态名称</span></span><br><span class="line">                System.out.print(<span class="string">" "</span> +</span><br><span class="line">                     method.getReturnType().getName() + <span class="string">" "</span>);</span><br><span class="line">                <span class="comment">// 显示方法名称</span></span><br><span class="line">                System.out.println(method.getName() + <span class="string">"();"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"&#125;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有指定类别"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到指定类别"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><pre><code>package java.util;public class java.util.ArrayList {        private static final long serialVersionUID;        private transient [Ljava.lang.Object; elementData;        private int size;        public java.util.ArrayList();        public java.util.ArrayList();        public java.util.ArrayList();        public boolean add();        public void add();        public java.lang.Object clone();        public void clear();        public boolean contains();        public int indexOf();        略...}</code></pre><p>一些类别查看器的实作原理基本上就是范例 16.10 所示范的，当然还可以取得更多的信息，您可以参考 Class 的在线 API 文件得到更多的讯息。</p><h3 id="16-1-4-简介类别加载器"><a href="#16-1-4-简介类别加载器" class="headerlink" title="16.1.4 简介类别加载器"></a>16.1.4 简介类别加载器</h3><p>Java 在需要使用类别的时候，才会将类别加载，Java 的类别载入是由类别加载器（Class loader）来达到的。</p><p>当您在文本模式下执行 java XXX 指令后，java 执行程序会尝试找到 JRE 安装的所在目录，然后寻找 jvm.dll（默认是在JRE目录下bin\client目录中），接着启动 JVM 并进行初始化动作，接着产生 Bootstrap Loader，Bootstrap Loader 会加载 Extended Loader，并设定 Extended Loader 的 parent 为 Bootstrap Loader，接着 Bootstrap Loader 会加载 System Loader，并将 System Loader 的 parent 设定为 Extended Loader。</p><p>Bootstrap Loader 通常由 C 撰写而成；Extended Loader 是由 Java 所撰写而成，实际是对应于 sun.misc.Launcher\$ExtClassLoader（Launcher 中的内部类别）；System Loader 是由 Java 撰写而成，实际对应于sun.misc. Launcher\$AppClassLoader（Launcher 中的内部类别）。</p><p>图 16.2 是 java 程序启动与加载类别的顺序图，也就是所谓的「类别加载器阶层架构」。</p><p><img src="/blog/2018/07/11/Java-反射机制/images/img16-02.png" alt="Java 类别加载器阶层架构"></p><p>图 16.2 Java 类别加载器阶层架构</p><p>Bootstrap Loader 会搜寻系统参数 sun.boot.class.path 中指定位置的类别，默认是 JRE  classes 下之  档案，或 lib 目录下 .jar 档案中（例如 rt.jar）的类别并加载，您可以使用 System.getProperty(“sun.boot.class.path”) 陈述来显示 sun.boot.class.path 中指定的路径，例如在我的计算机中显示的是以下的路径：</p><pre><code>C:\Program Files\Java\jre1.5.0_03\lib\rt.jar;C:\Program Files\Java\jre1.5.0_03\lib\i18n.jar;C:\Program Files\Java\jre1.5.0_03\lib\sunrsasign.jar;C:\Program Files\Java\jre1.5.0_03\lib\jsse.jar;C:\Program Files\Java\jre1.5.0_03\lib\jce.jar;C:\Program Files\Java\jre1.5.0_03\lib\charsets.jar;C:\Program Files\Java\jre1.5.0_03\classes</code></pre><p>Extended Loader（sun.misc.Launcher$ExtClassLoader）是由 Java 撰写而成，会搜寻系统参数 java.ext.dirs 中指定位置的类别，默认是 JRE 目录下的 lib\ext\classes 目录下的 .class 档案，或 lib\ext 目录下的 .jar 档案中（例如 rt.jar）的类别并加载，您可以使用 System.getProperty(“java.ext.dirs”) 陈述来显示  中指定的路径，例如在我的计算机中显示的是以下的路径：</p><pre><code>C:\Program Files\Java\jre1.5.0_03\lib\ext</code></pre><p>System Loader（sun.misc.Launcher$AppClassLoader）是由 Java 撰写而成，会搜寻系统参数 java.class.path 中指定位置的类别，也就是 Classpath 所指定的路径，默认是目前工作路径下的 .class 档案，您可以使用 System.getProperty(“java.class.path”) 陈述来显示 java.class.path 中指定的路径，在使用 java 执行程序时，您也可以加上 -cp 来覆盖原有的 Classpath 设定，例如：</p><pre><code>java –cp ./classes SomeClass</code></pre><p>Bootstrap Loader 会在 JVM 启动之后产生，之后它会加载 Extended Loader 并将其 parent 设为 Bootstrap Loader，然后 Bootstrap Loader 再加载 System Loader 并将其 parent 设定为 ExtClassLoader，接着 System Loader 开始加载您指定的类别，在加载类别时，每个类别加载器会先将加载类别的任务交由其 parent，如果 parent 找不到，才由自己负责加载，所以在加载类别时，会以 Bootstrap Loader→Extended Loader→System Loader 的顺序来寻找类别，如果都找不到，就会丢出 NoClassDefFoundError。</p><p>类别加载器在 Java 中是以 java.lang.ClassLoader 型态存在，每一个类别被载入后，都会有一个 Class 的实例来代表，而每个 Class 的实例都会记得自己是由哪个 ClassLoader 加载的，可以由 Class 的 getClassLoader() 取得加载该类别的 ClassLoader，而从 ClassLoader 的 getParent() 方法可以取得自己的 parent，图 16.3 显示了一个自定义的 SomeClass 实例与 Class、ClassLoader 及各 parent 的关系。</p><p><img src="/blog/2018/07/11/Java-反射机制/images/img16-03.png" alt="对象、Class、ClassLoader 与 parent 的关系"></p><p>图 16.3 对象、Class、ClassLoader 与 parent 的关系</p><p>范例 16.11 示范了图 16.3 的一个实际例子。</p><h4 id="范例-16-11-SomeClass-java"><a href="#范例-16-11-SomeClass-java" class="headerlink" title="范例 16.11  SomeClass.java"></a><strong>范例 16.11  SomeClass.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 建立SomeClass实例</span></span><br><span class="line">        SomeClass some = <span class="keyword">new</span> SomeClass();</span><br><span class="line">        <span class="comment">// 取得SomeClass的Class实例</span></span><br><span class="line">        Class c = some.getClass();</span><br><span class="line">        <span class="comment">// 取得ClassLoader</span></span><br><span class="line">        ClassLoader loader = c.getClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        <span class="comment">// 取得父ClassLoader</span></span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">        <span class="comment">// 再取得父ClassLoader</span></span><br><span class="line">        System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><pre><code>sun.misc.Launcher$AppClassLoader@82ba41sun.misc.Launcher$ExtClassLoader@923e30null</code></pre><p>onlyfun.caterpillar.SomeClass 是个自定义类别，您在目前的工作目录下执行程序，首先 AppClassLoader 会将加载类别的任务交给 ExtClassLoader，而 ExtClassLoader 会将加载类别的任务交给 Bootstrap Loader，由于 Bootstrap Loader 在它的路径设定（sun.boot.class.path）下找不到类别，所以由 ExtClassLoader 来试着寻找，而 ExtClassLoader 在它的路径设定（java.ext.dirs）下也找不到类别，所以由 AppClassLoader 来试着寻找，AppClassLoader 最后在 Classpath（java.class.path）设定下找到指定的类别并加载。</p><p>在执行结果中可以看到，加载 SomeClass 的 ClassLoader 是 AppClassLoader，而 AppClassLoader 的 parent 是 ExtClassLoader，而 ExtClassLoader 的 parent 是 null，null 并不是表示 ExtClassLoader 没有设定 parent，而是因为 Bootstrap Loader 通常由 C 所撰写而成，在 Java 中并没有一个实际的类别来表示它，所以才会显示为 null。</p><p>如果把 SomeClass 的 .class 档案移至 JRE 目录下的 lib\ext\classes下（由于设定了套件，所以实际上 SomeClass.class 要放置在 JRE 目录下的 lib\ext\classes\onlyfun\caterpillar下），并重新（于任何目录下）执行程序，您会看到以下的讯息：</p><pre><code>sun.misc.Launcher$ExtClassLoader@923e30nullException in thread &quot;main&quot; java.lang.NullPointerException        at onlyfun.caterpillar.SomeClass.main(SomeClass.java:15)</code></pre><p>由于 SomeClass 这次可以在 ExtClassLoader 的设定路径下找到，所以会由 ExtClassLoader 来加载 SomeClass 类别，而 ExtClassLoader 的 parent 显示为 null，指的是它的 parent 是由 C 撰写而成的 Bootstrap Loader，因为没有实际的 Java 类别而表示为 null，所以再由 null 上尝试呼叫 getParent() 方法就会丢出 NullPointerException 例外。</p><p>如果再把 SomeClass 的 .class 档案移至 JRE 目录下的 classes 目录下（由于设定了套件，所以实际上 SomeClass.class 要放置在 JRE 目录下的 classes/onlyfun/caterpillar下），并重新（于任何目录下）执行程序，您会看到以下的讯息：</p><pre><code>nullException in thread &quot;main&quot; java.lang.NullPointerException        at onlyfun.caterpillar.SomeClass.main(SomeClass.java:13)</code></pre><p>由于 SomeClass 这次可以在 Bootstrap Loader 的设定路径下找到，所以会由 Bootstrap Loader 来加载 SomeClass 类别，Bootstrap Loader 通常由 C 撰写而成，在 Java 中没有一个实际的类别来表示，所以显示为 null，因为表示为 null，所以再 由 null 上尝试呼叫 getParent() 方法就会丢出 NullPointerException 例外。</p><p>取得 ClassLoader 的实例之后，您可以使用它的 loadClass() 方法来加载类别，使用 loadClass() 方法加载别时，不会执行静态区块，静态区块的执行会等到真正使用类别来建立实例时，例如您可以改写范例 16.7 为范例 16.12。</p><h4 id="范例-16-12-ForNameDemoV3-java"><a href="#范例-16-12-ForNameDemoV3-java" class="headerlink" title="范例 16.12  ForNameDemoV3.java"></a><strong>范例 16.12  ForNameDemoV3.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForNameDemoV3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"载入TestClass2"</span>);</span><br><span class="line">            ClassLoader loader = ForNameDemoV3.class.getClassLoader();</span><br><span class="line">            Class c = loader.loadClass(<span class="string">"onlyfun.caterpillar.TestClass2"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"使用TestClass2宣告参考名称"</span>);</span><br><span class="line">            TestClass2 test = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"使用TestClass2建立对象"</span>);</span><br><span class="line">            test = <span class="keyword">new</span> TestClass2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到指定的类别"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从执行结果中可以看到，loadClass() 不会在加载类别时执行静态区块，而会在使用类别新建对象时才执行静态区块，结果如下所示：</p><pre><code>载入TestClass2使用TestClass2宣告参考名称使用TestClass2建立对象[执行静态区块]</code></pre><h3 id="16-1-5-使用自己的-ClassLoader"><a href="#16-1-5-使用自己的-ClassLoader" class="headerlink" title="16.1.5 使用自己的 ClassLoader"></a>16.1.5 使用自己的 ClassLoader</h3><p>ExtClassLoader 与 AppClassLoader 都是 java.net.URLClassLoader 的子类别，您可以在使用 java 启动程序时，使用以下的指令来指定 ExtClassLoader 的搜寻路径：</p><pre><code>java -Djava.ext.dirs=c:\workspace\ YourClass</code></pre><p>可以在使用 java 启动程序时，使用 -classpath 或 -cp 来指定 AppClassLoader 的搜寻路径，也就是设定 Classpath：</p><pre><code>java -classpath c:\workspace\ YourClass</code></pre><p>ExtClassLoader 与 AppClassLoader 在程序启动后会在虚拟机中存在一份，您在程序运行过程中就无法再改变它的搜寻路径，如果在程序运行过程中，打算动态决定从其它的路径加载类别，就要产生新的类别加载器。</p><p>您可以使用 URLClassLoader 来产生新的类别加载器，它需要 java.net.URL 作为其参数来指定类别加载的搜寻路径，例如：</p><pre><code>URL url = new URL(&quot;file:/d:/workspace/&quot;);ClassLoader urlClassLoader =                    new URLClassLoader(new URL[] {url});Class c = urlClassLoader.loadClass(&quot;SomeClass&quot;);</code></pre><p>由于 ClassLoader 是 Java SE 的标准API之一，可以在 rt.jar 中找到，因而会由 Bootstrap Loader 来载入 ClassLoader 类别，在新增了 ClassLoader 实例后，您可以使用它的 loadClass() 方法来指定要加载的类别名称，在新增 ClassLoader 时，会自动将新建的 ClassLoader 的 parent 设定为 AppClassLoader，并在每次加载类别时，先委托 parent 代为搜寻，所以上例中搜寻 SomeClass 类别时，会一路往上委托至 Bootstrap Loader 先开始搜寻，接着是 ExtClassLoader、AppClassLoader，如果都找不到，才使用新建的 ClassLoader 搜寻。</p><p>Java 的类别加载器阶层架构除了可以达到动态加载类别目的之外，还有着安全上的考虑，首先，因为每次寻找类别时都是委托 parent 开始寻找，所以除非有人可以侵入您的计算机，置换掉标准 Java SE API 与您自己安装的延伸套件，否则是不可能藉由撰写自己的类别加载器来载入恶意类别，以置换掉标准 Java SE API与您自己安装的延伸套件。</p><p>由于每次的类别载入是由子 ClassLoader 委托父 ClassLoader 先尝试加载，但父 lassLoader 看不到子 ClassLoader，所以同一阶层的子 ClassLoader 不会被误用，从而避免了加载错误类别的可能性，例如在图 16.4 中，您想从 YourClassLoader 来加载类别的话，类别加载器阶层不会看到 MaliciousClassLoader。</p><p><img src="/blog/2018/07/11/Java-反射机制/images/img16-04.png" alt="类别加载器阶层的安全设计"></p><p>图 16.4 类别加载器阶层的安全设计</p><p>由同一个 ClassLoader 加载的类别档案，会只有一份Class实例，如果同一个类别档案是由两个不同的ClassLoader 载入，则会有两份不同的 Class 实例。注意这个说法，如果有两个不同的 ClassLoader 搜寻同一个类别，而在 parent 的 AppClassLoader 搜寻路径中就可以找到指定类别的话，则 Class 实例就只会有一个，因为两个不同的 ClassLoader 都是在委托父 ClassLoader 时找到该类别的，如果父 ClassLoader 找不到，而是由各自的 ClassLoader 搜寻到，则 Class 的实例会有两份。</p><p>范例 16.13 是个简单的示范，可用来测试加载路径与Class实例是否为同一对象。</p><h4 id="范例-16-13-ClassLoaderDemo-java"><a href="#范例-16-13-ClassLoaderDemo-java" class="headerlink" title="范例 16.13  ClassLoaderDemo.java"></a><strong>范例 16.13  ClassLoaderDemo.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 测试路径</span></span><br><span class="line">            String classPath = args[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 测试类别</span></span><br><span class="line">            String className = args[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            URL url1 = <span class="keyword">new</span> URL(classPath);</span><br><span class="line">            <span class="comment">// 建立ClassLoader</span></span><br><span class="line">            ClassLoader loader1 =</span><br><span class="line">                      <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[] &#123;url1&#125;);</span><br><span class="line">            <span class="comment">// 加载指定类别</span></span><br><span class="line">            Class c1 = loader1.loadClass(className);</span><br><span class="line">            <span class="comment">// 显示类别描述</span></span><br><span class="line">            System.out.println(c1);</span><br><span class="line"></span><br><span class="line">            URL url2 = <span class="keyword">new</span> URL(classPath);</span><br><span class="line">            ClassLoader loader2 =</span><br><span class="line">                      <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[] &#123;url2&#125;);</span><br><span class="line">            Class c2 = loader2.loadClass(className);</span><br><span class="line"></span><br><span class="line">            System.out.println(c2);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"c1 与 c1 为同一实例？"</span></span><br><span class="line">                                     + (c1 == c2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有指定类别加载路径与名称"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(MalformedURLException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"加载路径错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到指定的类别"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以任意设计一个类别，例如 TestClass，其中 classPath 可以输入不为 ExtClassLoader 或 AppClassLoader 的搜寻路径，例如 file:/d:/workspace/，这样同一个类别会分由两个 ClassLoader 载入，结果会有两份 Class 实例，则测试 c1 与 c2 是否为同一实例时，则结果会显示 false，一个执行结果如下：</p><pre><code>java onlyfun.caterpillar.ClassLoaderDemo file:/d:/workspace/ TestClassclass TestClassclass TestClassc1 与 c1 为同一实例？false</code></pre><p>如果您在执行程序时，以 -cp 将 file:/d:/workspace/ 加入为 Classpath 的一部份，由于两个 ClassLoader 的 parent 都是 AppClassLoader，而 AppClassLoader 会在 Classpath 中找到指定的类别，所以最后会只有一个指定的类别之 Class 实例，则测试 c1 与 c2 是否为同一实例时，结果会显示 true，一个执行结果如下：</p><pre><code>java -cp .;d:\workspace onlyfun.caterpillar.ClassLoaderDemo file:/d:/workspace/ TestClassclass TestClassclass TestClassc1 与 c1 为同一实例？true</code></pre><p>使用 -cp 指定 Classpath 时，会覆盖原有的 Classpath 定义，也就是连现行工作目录的路径也覆盖了，由于我的 ClassLoaderDemo 类别是在现行工作目录下，所以使用 -cp 时，也包括了现行工作目录，记得组合多个 Classpath 路径时，可以使用「;」。</p><h2 id="16-2-使用反射生成与操作对象"><a href="#16-2-使用反射生成与操作对象" class="headerlink" title="16.2 使用反射生成与操作对象"></a>16.2 使用反射生成与操作对象</h2><p>使用反射机制，您可以于执行时期动态加载类别并生成对象，操作对象上的方法、改变类别成员的值，甚至连私用（private）成员的值也可以改变。</p><h3 id="16-2-1-生成物件"><a href="#16-2-1-生成物件" class="headerlink" title="16.2.1 生成物件"></a>16.2.1 生成物件</h3><p>您可以使用 Class 的 newInstance() 方法来实例化一个对象，实例化的对象是以 Object 型态传回，例如：</p><pre><code>Class c = Class.forName(className);Object obj = c.newInstance();</code></pre><p>范例 16.14 是个简单的示范，您可以动态加载实现了 List 接口的类别。</p><h4 id="范例-16-14-NewInstanceDemo-java"><a href="#范例-16-14-NewInstanceDemo-java" class="headerlink" title="范例 16.14  NewInstanceDemo.java"></a><strong>范例 16.14  NewInstanceDemo.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewInstanceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">            List list = (List) c.newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                list.add(<span class="string">"element "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(Object o: list.toArray()) &#123;</span><br><span class="line">                System.out.println(o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到指定的类别"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><pre><code>java onlyfun.caterpillar.NewInstanceDemo java.util.ArrayListelement 0element 1element 2element 3element 4</code></pre><p>实际上如果想要使用反射来动态加载类别，通常是对对象的接口或类型都一无所知，也就无法像范例 16.14 中对 newInstance() 传回的对象进行接口转换动作，稍后会介绍如何以反射来呼叫方法以操作 newInstance() 所传回的对象。</p><p>如果加载的类别中具备无参数的建构方法，则可以无参数的 newInstance() 来建构一个不指定初始自变量的对象，如果您要在动态加载及生成对象时指定对象的初始化自变量，则要先指定参数型态、取得 Constructor 对象、使用 Constructor 的 newInstance() 并指定参数的接受值。</p><p>以一个例子来说明，首先定义一个 Student 类。</p><h4 id="范例-16-15-Student-java"><a href="#范例-16-15-Student-java" class="headerlink" title="范例 16.15  Student.java"></a><strong>范例 16.15  Student.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name = <span class="string">"N/A"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">":"</span> + score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以用 Class.forName() 来加载 Student 类别，并使用第二个有参数的建构方法来建构 Student 实例，如范例 16.16 所示。</p><h4 id="范例-16-16-NewInstanceDemo2-java"><a href="#范例-16-16-NewInstanceDemo2-java" class="headerlink" title="范例 16.16  NewInstanceDemo2.java"></a><strong>范例 16.16  NewInstanceDemo2.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewInstanceDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指定参数型态</span></span><br><span class="line">            Class[] params = <span class="keyword">new</span> Class[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">// 第一个参数是String</span></span><br><span class="line">            params[<span class="number">0</span>] = String.class;</span><br><span class="line">            <span class="comment">// 第二个参数是int</span></span><br><span class="line">            params[<span class="number">1</span>] = Integer.TYPE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取得对应参数列的建构方法            </span></span><br><span class="line">            Constructor constructor =</span><br><span class="line">                             c.getConstructor(params);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指定自变量内容</span></span><br><span class="line">            Object[] argObjs = <span class="keyword">new</span> Object[<span class="number">2</span>];</span><br><span class="line">            argObjs[<span class="number">0</span>] = <span class="string">"caterpillar"</span>;</span><br><span class="line">            argObjs[<span class="number">1</span>] = <span class="keyword">new</span> Integer(<span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 给定自变量并实例化</span></span><br><span class="line">            Object obj = constructor.newInstance(argObjs);</span><br><span class="line">            <span class="comment">// 呼叫toString()来观看描述</span></span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到类别"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有所指定的方法"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在指定基本型态时，要使用对应的包裹类别（Wrapper）并使用 .TYPE，例如指定 int 型态时，则使用 Integer.TYPE，如果要指定 Integer 型态的参数的话，才是使用 Integer.class，范例 16.16 会根据指定的自变量呼叫对应的建构方法，加载 onlyfun.caterpillar.Student 的执行结果如下：</p><pre><code>java onlyfun.caterpillar.NewInstanceDemo2 onlyfun.caterpillar.Studentcaterpillar:90</code></pre><h3 id="16-2-2-呼叫方法"><a href="#16-2-2-呼叫方法" class="headerlink" title="16.2.2 呼叫方法"></a>16.2.2 呼叫方法</h3><p>使用反射可以取回类别上方法的对象代表，方法的对象代表是 java.lang.reflect.Method 的实例，您可以使用它的 invoke() 方法来动态呼叫指定的方法，例如呼叫范例 16.15 的 Student 类别上之 setName() 等方法，这边直接以范例 16.17 作为示范。</p><h4 id="范例-16-17-InvokeMethodDemo-java"><a href="#范例-16-17-InvokeMethodDemo-java" class="headerlink" title="范例 16.17  InvokeMethodDemo.java"></a><strong>范例 16.17  InvokeMethodDemo.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 使用无参数建构方法建立对象</span></span><br><span class="line">            Object targetObj = c.newInstance();</span><br><span class="line">            <span class="comment">// 设定参数型态</span></span><br><span class="line">            Class[] param1 = &#123;String.class&#125;;</span><br><span class="line">            <span class="comment">// 根据参数型态取回方法对象</span></span><br><span class="line">            Method setNameMethod = c.getMethod(<span class="string">"setName"</span>, param1);</span><br><span class="line">            <span class="comment">// 设定自变量值</span></span><br><span class="line">            Object[] argObjs1 = &#123;<span class="string">"caterpillar"</span>&#125;;</span><br><span class="line">            <span class="comment">// 给定自变量呼叫指定对象之方法</span></span><br><span class="line">            setNameMethod.invoke(targetObj, argObjs1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Class[] param2 = &#123;Integer.TYPE&#125;;</span><br><span class="line">            Method setScoreMethod =</span><br><span class="line">                     c.getMethod(<span class="string">"setScore"</span>, param2);</span><br><span class="line"></span><br><span class="line">            Object[] argObjs2 = &#123;<span class="keyword">new</span> Integer(<span class="number">90</span>)&#125;;</span><br><span class="line">            setScoreMethod.invoke(targetObj, argObjs2);</span><br><span class="line">            <span class="comment">// 显示对象描述</span></span><br><span class="line">            System.out.println(targetObj);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到类别"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有这个方法"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>范例 16.17 可以指定加载 Student 类别并生成实例，接着可以动态呼叫 setName() 与 setScore() 方法，范例中参数型态与自变量值的设定与范例 16.16 是类似的，由于呼叫 setName() 与 setScore() 所给定的自变量是 “caterpillar” 与 90，所以执行的结果与范例 16.16 是相同的。</p><p>在很少的情况下，您会需要突破 Java 的存取限制来呼叫受保护的（protected）或私有（private）的方法（例如您拿到一个组件（Component），但您没法修改它的原始码来改变某个私有方法的权限，而您又一定要呼叫某个私有方法），这时候您可以使用反射机制来达到您的目的，一个存取私有方法的例子如下：</p><pre><code>Method privateMethod =            c.getDeclaredMethod(&quot;somePrivateMethod&quot;, new Class[0]);privateMethod.setAccessible(true);privateMethod.invoke(targetObj, argObjs);</code></pre><p>使用反射来动态呼叫方法的实际例子之一是在 JavaBean 的设定，例如在 JSP/Servlet 中，可以根据使用者的请求名称与 JavaBean 的属性名称自动比对，将字符串请求值设定至指定的 JavaBean 上，并自动根据参数型态作型态转换（详细说明请见本章后网络索引）。范例 16.18 是个简单的示范，您可以给 CommandUtil 工具类别一个 Map 对象与类别名称，然后取得一个更新了值的实例，其中参数 Map 对象的「键」（Key）为要呼叫的 setter 方法名称（不包括set开头的名称，例如 setName() 方法的话，只要给定键为 name 即可），而「值」（Value）为要设定给 setter 的自变量。</p><h4 id="范例-16-18-CommandUtil-java"><a href="#范例-16-18-CommandUtil-java" class="headerlink" title="范例 16.18  CommandUtil.java"></a><strong>范例 16.18  CommandUtil.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给定Map对象及要产生的Bean类别名称</span></span><br><span class="line">    <span class="comment">// 可以取回已经设定完成的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getCommand</span><span class="params">(Map requestMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    String commandClass)</span></span></span><br><span class="line"><span class="function">                                      <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class c = Class.forName(commandClass);</span><br><span class="line">        Object o = c.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> updateCommand(requestMap, o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用reflection自动找出要更新的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">updateCommand</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                           Map requestMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Object command)</span></span></span><br><span class="line"><span class="function">                              <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Method[] methods =</span><br><span class="line">                   command.getClass().getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 略过private、protected成员</span></span><br><span class="line">            <span class="comment">// 且找出必须是set开头的方法名称</span></span><br><span class="line">            <span class="keyword">if</span>(!Modifier.isPrivate(methods[i].getModifiers()) &amp;&amp;</span><br><span class="line">               !Modifier.isProtected(methods[i].getModifiers()) &amp;&amp;  </span><br><span class="line">               methods[i].getName().startsWith(<span class="string">"set"</span>)) &#123;</span><br><span class="line">                <span class="comment">// 取得不包括set的名称</span></span><br><span class="line">                String name = methods[i].getName()</span><br><span class="line">                                        .substring(<span class="number">3</span>)</span><br><span class="line">                                        .toLowerCase();</span><br><span class="line">                <span class="comment">// 如果setter名称与键值相同</span></span><br><span class="line">                <span class="comment">// 呼叫对应的setter并设定值</span></span><br><span class="line">                <span class="keyword">if</span>(requestMap.containsKey(name)) &#123;</span><br><span class="line">                    String param = (String) requestMap.get(name);</span><br><span class="line">                    Object[] values = findOutParamValues(</span><br><span class="line">                                        param, methods[i]);</span><br><span class="line">                    methods[i].invoke(command, values);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> command;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为对应型态的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object[] findOutParamValues(</span><br><span class="line">                     String param, Method method) &#123;</span><br><span class="line">        Class[] params = method.getParameterTypes();</span><br><span class="line">        Object[] objs = <span class="keyword">new</span> Object[params.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(params[i] == String.class) &#123;</span><br><span class="line">                objs[i] = param;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(params[i] == Short.TYPE) &#123;</span><br><span class="line">                <span class="keyword">short</span> number = Short.parseShort(param);</span><br><span class="line">                objs[i] = <span class="keyword">new</span> Short(number);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(params[i] == Integer.TYPE) &#123;</span><br><span class="line">                <span class="keyword">int</span> number = Integer.parseInt(param);</span><br><span class="line">                objs[i] = <span class="keyword">new</span> Integer(number);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(params[i] == Long.TYPE) &#123;</span><br><span class="line">                <span class="keyword">long</span> number = Long.parseLong(param);</span><br><span class="line">                objs[i] = <span class="keyword">new</span> Long(number);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(params[i] == Float.TYPE) &#123;</span><br><span class="line">                <span class="keyword">float</span> number = Float.parseFloat(param);</span><br><span class="line">                objs[i] = <span class="keyword">new</span> Float(number);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(params[i] == Double.TYPE) &#123;</span><br><span class="line">                <span class="keyword">double</span> number = Double.parseDouble(param);</span><br><span class="line">                objs[i] = <span class="keyword">new</span> Double(number);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(params[i] == Boolean.TYPE) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> bool = Boolean.parseBoolean(param);</span><br><span class="line">                objs[i] = <span class="keyword">new</span> Boolean(bool);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> objs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CommandUtil 可以自动根据方法上的参数型态，将 Map 对象中的「值」对象转换为属性上的对应型态，目前它可以转换基本型态与 String 型态的属性，一个使用 CommandUtil 类别的例子如范例 16.19 所示。</p><h4 id="范例-16-19-CommandUtilDemo-java"><a href="#范例-16-19-CommandUtilDemo-java" class="headerlink" title="范例 16.19  CommandUtilDemo.java"></a><strong>范例 16.19  CommandUtilDemo.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandUtilDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; request =</span><br><span class="line">                  <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        request.put(<span class="string">"name"</span>, <span class="string">"caterpillar"</span>);</span><br><span class="line">        request.put(<span class="string">"score"</span>, <span class="string">"90"</span>);</span><br><span class="line">        Object obj = CommandUtil.getCommand(request, args[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以使用范例 16.19 来加载 Student 类别，使用 CommandUtil.getCommand() 方法可以返回一个设定好值的 Student 实例，虽然您设定给 request 的「值」是字符串型态，但 CommandUtil 会使用反射机制来自动转换为属性上的对应型态，一个执行的范例如下所示：</p><pre><code>java onlyfun.caterpillar.CommandUtilDemo onlyfun.caterpillar.Studentcaterpillar:90</code></pre><blockquote><p><strong>良葛格的话匣子</strong> 不知道方法的名称如何呼叫？其实范例 16.17 就给出了答案，透过规范方法的命名方式，之后就可以透用反射机制加上方法名称的比对，以正确呼叫对应的方法。</p></blockquote><h3 id="16-2-3-修改成员值"><a href="#16-2-3-修改成员值" class="headerlink" title="16.2.3 修改成员值"></a>16.2.3 修改成员值</h3><p>尽管直接存取类别的数据成员（Field）是不被鼓励的，但您仍是可以直接存取公开的（public）数据成员，而您甚至也可以透过反射机制来存取私用数据成员，以一个实例来说明，首先撰写个 TestedField 类别。</p><h4 id="范例-16-20-TestField-java"><a href="#范例-16-20-TestField-java" class="headerlink" title="范例 16.20  TestField.java"></a><strong>范例 16.20  TestField.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestField</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> testInt;</span><br><span class="line">    <span class="keyword">public</span> String testString;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testInt + <span class="string">":"</span> + testString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>范例 16.21 则利用反射机制动态加载类别来存取数据成员。</p><h4 id="范例-16-21-AssignFieldDemo-java"><a href="#范例-16-21-AssignFieldDemo-java" class="headerlink" title="范例 16.21  AssignFieldDemo.java"></a><strong>范例 16.21  AssignFieldDemo.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssignFieldDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">            Object targetObj = c.newInstance();</span><br><span class="line"></span><br><span class="line">            Field testInt = c.getField(<span class="string">"testInt"</span>);</span><br><span class="line">            testInt.setInt(targetObj, <span class="number">99</span>);</span><br><span class="line"></span><br><span class="line">            Field testString = c.getField(<span class="string">"testString"</span>);</span><br><span class="line">            testString.set(targetObj, <span class="string">"caterpillar"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(targetObj);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有指定类别"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到指定的类别"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到指定的数据成员"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以加载 TestField 类别来看看执行的结果，如下所示：</p><pre><code>java onlyfun.caterpillar.AssignFieldDemo onlyfun.caterpillar.TestField99:caterpillar</code></pre><p>如果有必要的话，您也可以透过反射机制来存取私有的数据成员，例如：</p><pre><code>Field privateField = c.getDeclaredField(&quot;privateField&quot;);privateField.setAccessible(true);privateField.setInt(targetObj, 99);</code></pre><h3 id="16-2-4-再看数组对象"><a href="#16-2-4-再看数组对象" class="headerlink" title="16.2.4 再看数组对象"></a>16.2.4 再看数组对象</h3><p>在 Java 中数组也是一个对象，也会有一个 Class 实例来表示它，范例 16.22 显示几个基本型态以及 String 数组的类别名称描述。</p><h2 id="范例-16-22-ArrayDemo-java"><a href="#范例-16-22-ArrayDemo-java" class="headerlink" title="范例 16.22  ArrayDemo.java"></a><strong>范例 16.22  ArrayDemo.java</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">short</span>[] sArr = <span class="keyword">new</span> <span class="keyword">short</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span>[] iArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">long</span>[] lArr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">float</span>[] fArr = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">double</span>[] dArr = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] bArr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[] zArr = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">5</span>];</span><br><span class="line">        String[] strArr = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"short 数组类别："</span> + sArr.getClass());</span><br><span class="line">        System.out.println(<span class="string">"int 数组类别："</span> + iArr.getClass());</span><br><span class="line">        System.out.println(<span class="string">"long 数组类别："</span> + lArr.getClass());</span><br><span class="line">        System.out.println(<span class="string">"float 数组类别："</span> + fArr.getClass());</span><br><span class="line">        System.out.println(<span class="string">"double 数组类别："</span> + dArr.getClass());</span><br><span class="line">        System.out.println(<span class="string">"byte 数组类别："</span> + bArr.getClass());</span><br><span class="line">        System.out.println(<span class="string">"boolean 数组类别："</span> + zArr.getClass());</span><br><span class="line">        System.out.println(<span class="string">"String 数组类别："</span> + strArr.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 toString() 来显示数组对象的类别名称描述时，会以 “class [“ 作为开始，之后跟随着一个型态表示字符，执行结果如下所示：</p><pre><code>short 数组类别：class [Sint 数组类别：class [Ilong 数组类别：class [Jfloat 数组类别：class [Fdouble 数组类别：class [Dbyte 数组类别：class [Bboolean 数组类别：class [ZString 数组类别：class [Ljava.lang.String;</code></pre><p>要使用反射机制动态生成数组的话，可以使用 java.lang.reflect.Array 来协助，范例 16.23 简单的示范了如何生成 String 数组。</p><h4 id="范例-16-23-NewArrayDemo-java"><a href="#范例-16-23-NewArrayDemo-java" class="headerlink" title="范例 16.23  NewArrayDemo.java"></a><strong>范例 16.23  NewArrayDemo.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c = String.class;</span><br><span class="line">        Object objArr = Array.newInstance(c, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Array.set(objArr, i, i+<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.print(Array.get(objArr, i) + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        String[] strs = (String[]) objArr;</span><br><span class="line">        <span class="keyword">for</span>(String s : strs) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Array.newInstance() 的第一个参数是指定元素型态，而第二个参数是用来指定数组长度，执行结果如下：</p><pre><code>0 1 2 3 40 1 2 3 4</code></pre><p>Array.newInstance() 还有另一个版本，可用于建立二维数组，只要用一个表示二维数组的两个维度长度的 int 数组，传递给第二个参数，范例 16.24 是个简单示范。</p><h4 id="范例-16-24-NewArrayDemo2-java"><a href="#范例-16-24-NewArrayDemo2-java" class="headerlink" title="范例 16.24  NewArrayDemo2.java"></a><strong>范例 16.24  NewArrayDemo2.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewArrayDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c = String.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打算建立一个3*4数组</span></span><br><span class="line">        <span class="keyword">int</span>[] dim = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        Object objArr = Array.newInstance(c, dim);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Object row = Array.get(objArr, i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                Array.set(row, j, <span class="string">""</span> + (i+<span class="number">1</span>)*(j+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Object row = Array.get(objArr, i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                System.out.print(Array.get(row, j) + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><pre><code>1 2 3 42 4 6 83 6 9 12</code></pre><p>如果想要得知数组元素的型态，可以在取得数组的 Class 实例之后，使用 Class 实例的 getComponentType() 方法，所取回的是元素的 Class 实例，例如：</p><pre><code>int[] iArr = new int[5];System.out.println(iArr.getClass().getComponentType());</code></pre><h3 id="16-2-5-Proxy-类别"><a href="#16-2-5-Proxy-类别" class="headerlink" title="16.2.5 Proxy 类别"></a>16.2.5 Proxy 类别</h3><p>Java 在 J2SE 1.3 之后加入 java.lang.reflect.Proxy 类别，可协助您实现动态代理功能，举个实际应用的例子，假设今天您打算开发一个 HelloSpeaker 类别，当中有一个 hello() 方法，而您想要在这个 hello() 呼叫前后加上记录（log）的功能，但又不想将记录的功能写到 HelloSpeaker 类别中，这时您可以使用 Proxy 类别来实现动态代理。<br>要实现动态代理，首先要定义所要代理的接口，范例 16.25 为定义了有 hello() 方法的 IHello 接口。</p><h4 id="范例-16-25-IHello-java"><a href="#范例-16-25-IHello-java" class="headerlink" title="范例 16.25 IHello.java"></a><strong>范例 16.25 IHello.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您的 HelloSpeaker 类别实现了 IHello 接口，如范例 16.26 所示。</p><h4 id="范例-16-26-HelloSpeaker-java"><a href="#范例-16-26-HelloSpeaker-java" class="headerlink" title="范例 16.26  HelloSpeaker.java"></a><strong>范例 16.26  HelloSpeaker.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSpeaker</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以实作一个处理记录（log）的处理者（Handler），让处理者在呼叫 hello() 方法的前后进行记录的动作，一个处理者必须实现 java.lang.reflect.InvocationHandler 接口，InvocationHandler 有一个 invoke() 方法必须实现，范例 16.27 是个简单的实现。</p><h4 id="范例-16-27-LogHandler-java"><a href="#范例-16-27-LogHandler-java" class="headerlink" title="范例 16.27  LogHandler.java"></a><strong>范例 16.27  LogHandler.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.logging.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger =</span><br><span class="line">               Logger.getLogger(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">    <span class="keyword">private</span> Object delegate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定要代理的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">        <span class="comment">// 建立并传回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                 delegate.getClass().getClassLoader(),</span><br><span class="line">                 <span class="comment">// 要被代理的接口</span></span><br><span class="line">                 delegate.getClass().getInterfaces(),</span><br><span class="line">                 <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理要呼叫的方法，并在其前后增加行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.log(Level.INFO,</span><br><span class="line">                         <span class="string">"method starts..."</span> + method.getName());</span><br><span class="line">            result = method.invoke(delegate, args);</span><br><span class="line">            logger.log(Level.INFO,</span><br><span class="line">                         <span class="string">"method ends..."</span> + method.getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            logger.log(Level.INFO, e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的概念是使用 Proxy.newProxyInstance() 方法建立一个代理对象，建立代理对象时必须告知所要代理的操作接口，之后您可以操作所建立的代理对象，在每次操作时会呼叫 InvocationHandler 的 invoke() 方法，invoke() 方法会传入被代理对象的方法名称与执行自变量，实际上要执行的方法交由 method.invoke()，您在 method.invoke() 前后加上记录动作，method.invoke() 传回的对象是实际方法执行过后的回传结果，先从范例 16.28 来看看一个执行的例子。</p><h4 id="范例-16-28-ProxyDemo-java"><a href="#范例-16-28-ProxyDemo-java" class="headerlink" title="范例 16.28  ProxyDemo.java"></a><strong>范例 16.28  ProxyDemo.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LogHandler handler  = <span class="keyword">new</span> LogHandler();</span><br><span class="line">        IHello speaker = <span class="keyword">new</span> HelloSpeaker();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代理speaker的对象</span></span><br><span class="line">        IHello speakerProxy =</span><br><span class="line">                 (IHello) handler.bind(speaker);</span><br><span class="line"></span><br><span class="line">        speakerProxy.hello(<span class="string">"Justin"</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><pre><code>2005/6/4 上午 09:39:11 onlyfun.caterpillar.LogHandler invoke信息: method starts...helloHello, Justin2005/6/4 上午 09:39:11 onlyfun.caterpillar.LogHandler invoke信息: method ends...hello</code></pre><p>透过代理机制，在不将记录动作写入为 HelloSpeaker 类别程序代码的情况下，您可以为其加入记录的功能，这并不是什么魔法，只不过是在 hello() 方法前后由代理对象 speakerProxy 先执行记录功能而已，而真正执行 hello() 方法时才使用 speaker 对象。</p><blockquote><p><strong>良葛格的话匣子</strong> 这边的例子是「Proxy 模式」的实现，您可以进一步参考：</p><ul><li><a href="http://openhome.cc/Gossip/DesignPattern/ProxyPattern.htm" target="_blank" rel="noopener">Proxy 模式（一）</a></li><li><a href="http://openhome.cc/Gossip/DesignPattern/ProxyPattern2.htm" target="_blank" rel="noopener">Proxy 模式（二）</a></li></ul></blockquote><h2 id="16-3-接下来的主题"><a href="#16-3-接下来的主题" class="headerlink" title="16.3 接下来的主题"></a>16.3 接下来的主题</h2><p>每一个章节的内容由浅至深，初学者该掌握的深度要到哪呢？在这个章节中，对于初学者我建议至少掌握以下几点内容：</p><ul><li>了解 Class 实例与类别的关系</li><li>会使用 Class.forName() 加载类别并获得类别信息</li><li>会使用 Class 建立实例</li><li>会使用反射机制呼叫对象上的方法</li></ul><p>下一个章节要来介绍 J2SE 5.0 中新增的 Annotation 功能，Annotation 是 J2SE 5.0 对 metadata 的支持，metadata 简单的说就是「数据的数据」（Data about data），您可以使用 Annotation 对程序代码作出一些说明，以利一些程序代码分析工具来使用这些信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第-16-章-反射（Reflection）&quot;&gt;&lt;a href=&quot;#第-16-章-反射（Reflection）&quot; class=&quot;headerlink&quot; title=&quot;第 16 章 反射（Reflection）&quot;&gt;&lt;/a&gt;第 16 章 反射（Reflection）&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android 插件化开发</title>
    <link href="http://yoursite.com/2018/07/11/Android-%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2018/07/11/Android-插件化开发/</id>
    <published>2018-07-11T08:20:59.000Z</published>
    <updated>2018-07-11T12:53:32.156Z</updated>
    
    <content type="html"><![CDATA[<p><body></body></p><section class="content"><br><ul class="items"><br>    <li style="background: #FFFFFF"><br>    <h1><a href="#" title="title">Android博客周刊专题之＃插件化开发＃</a></h1><br>本期专栏目讨论插件化开发。插件化涉及的东西很多，所以我们需要多个维度去学习。大概分为5个部分：预备知识、入门、进阶、系列、类库。一步一步深入了解插件的原理。本专栏会不定时更新相关内容，请留意更新的消息。<br>    <footer>转自：<a href="http://www.androidblog.cn/index.php/Index/detail/id/16#" target="_blank" rel="noopener">http://www.androidblog.cn/index.php/Index/detail/id/16#</a></footer> </li><br></ul><br><br><b>基础</b><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/" target="_blank">1.Java 类加载器</a><br>类加载器（class loader）是 Java™中的一个很重要的概念。类加载器负责加载 Java 类的字节代码到 Java 虚拟机中。本文首先详细介绍了 Java 类加载器的基本概念，包括代理模式、加载类的具体过程和线程上下文类加载器等，接着介绍如何开发自己的类加载器，最后介绍了类加载器在 Web 容器和 OSGi™中的应用。<br><a href="https://github.com/JustinSDK/JavaSE6Tutorial/blob/master/docs/CH16.md" target="_blank">2.反射原理</a><br><br>Java 提供的反射機制允許您於執行時期動態載入類別、檢視類別資訊、生成物件或操作生成的物件，要舉反射機制的一個應用實例，就是在整合式開發環境中所提供的方法提示或是類別檢視工具，另外像 JSP 中的 JavaBean 自動收集請求資訊也使用到反射，而一些軟體開發框架（Framework）也常見到反射機制的使用，以達到動態載入使用者自訂類別的目的。<br><a href="http://www.jianshu.com/p/6f6bb2f0ece9" target="_blank">3.代理模式及Java实现动态代理</a><br>定义：给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。<br><b>入门</b><br><br><a href="http://blog.csdn.net/u013478336/article/details/50734108" target="_blank">1.Android动态加载dex技术初探</a><br><br><br>  Android使用Dalvik虚拟机加载可执行程序，所以不能直接加载基于class的jar，而是需要将class转化为dex字节码，从而执行代码。优化后的字节码文件可以存在一个<em>.jar中，只要其内部存放的是</em>.dex即可使用。<a href="http://104.236.134.90/2016/02/02/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%9F%BA%E7%A1%80/" target="_blank">2.Android插件化入门</a><br><br>开发者将插件代码封装成Jar或者APK。宿主下载或者从本地加载Jar或者APK到宿主中。将宿主调用插件中的算法或者Android特定的Class（如Activity）<a href="http://blog.csdn.net/u010687392/article/details/47121729?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io" target="_blank">3.插件化开发—动态加载技术加载已安装和未安装的apk</a><br><br>动态加载技术就是使用类加载器加载相应的apk、dex、jar（必须含有dex文件），再通过反射获得该apk、dex、jar内部的资源（class、图片、color等等）进而供宿主app使用。<a href="https://blog.tingyun.com/web/article/detail/166" target="_blank">4.Android动态加载技术三个关键问题详解</a><br><br>动态加载技术（也叫插件化技术）在技术驱动型的公司中扮演着相当重要的角色，当项目越来越庞大的时候，需要通过插件化来减轻应用的内存和CPU占用，还可以实现热插拔，即在不发布新版本的情况下更新某些模块。<br><b>进阶</b><br><a href="http://mp.weixin.qq.com/s?__biz=MzAwMTcwNTE0NA==&mid=400217391&idx=1&sn=86181541ce0164156dfab135ed99bb5c&scene=0&key=b410d3164f5f798e61a5d4afb759fa38371c8b119384c6163a30c28163b4d4d5f59399f2400800ec842f1d0e0ffb84af&ascene=0&uin=MjExMjQ&pass_ticket=Nt5Jaa28jjFxcQO9o%2BvQiXX%2B0iXG5DlZlHNW97Fk1Ew%3D" target="_blank">1.携程Android App插件化和动态加载实践</a><br><br>携程Android App的插件化和动态加载框架已上线半年，经历了初期的探索和持续的打磨优化，新框架和工程配置经受住了生产实践的考验。本文将详细介绍Android平台插件式开发和动态加载技术的原理和实现细节，回顾携程Android App的架构演化过程，期望我们的经验能帮助到更多的Android工程师。<a href="http://blog.csdn.net/hkxxx/article/details/42194387" target="_blank">2.动态加载APK原理分享</a><br><br> 被加载的apk称之为插件，因为机制类似于生物学的”寄生”，加载了插件的应用也被称为宿主。<br>往往不是所有的apk都可作为插件被加载，往往需要遵循一定的”开发规范”，还需要插件项目引入某种api类库，业界通常都是这么做的。<a href="http://www.cnblogs.com/coding-way/p/4669591.html" target="_blank">3.Android插件化的一种实现</a><br><br>Android的插件化已经是老生常谈的话题了，插件化的好处有很多：解除代码耦合，插件支持热插拔，静默升级，从根本上解决65K属性和方法的bug等等。下面给大家介绍一下我们正在用的差价化框架。本片主要以类图的方式向大家介绍插件话框架的实现。<a href="http://mogu.io/117-117" target="_blank">4.蘑菇街 App 的组件化之路</a><br><br><br><br>随着我街业务的蓬勃发展，产品和运营随时上新功能新活动的需求越来越强烈，经常可以听到“有个功能我想周x上，行不行”。行么？当然是不行啦，上新功能得发新版本啊，到时候费时费力打乱开发节奏不说，覆盖率也是个问题。<a href="http://www.codekk.com/open-source-project-analysis/detail/Android/FFish/DynamicLoadApk%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io" target="_blank">5.DynamicLoadApk 源码解析</a><br><br><br><br>DynamicLoadApk 是一个开源的 Android 插件化框架。插件化的优点包括：(1) 模块解耦，(2) 动态升级，(3) 高效并行开发(编译速度更快) (4) 按需加载，内存占用更低等等DynamicLoadApk 提供了 3 种开发方式，让开发者在无需理解其工作原理的情况下快速的集成插件化功能。<a href="http://blog.csdn.net/singwhatiwanna/article/details/22597587" target="_blank">6.Android apk动态加载机制的研究</a><br><br><br><br>问题是这样的：我们知道，apk必须安装才能运行，如果不安装要是也能运行该多好啊，事实上，这不是完全不可能的，尽管它比较难实现。在理论层面上，我们可以通过一个宿主程序来运行一些未安装的apk，当然，实践层面上也能实现，不过这对未安装的apk有要求。我们的想法是这样的，首先要明白apk未安装是不能被直接调起来.<a href="http://tech.meituan.com/mt-android-auto-split-dex.html" target="_blank">7.美团Android DEX自动拆包及动态加载简介</a><br><br><br><br>作为一个android开发者，在开发应用时，随着业务规模发展到一定程度，不断地加入新功能、添加新的类库，代码在急剧的膨胀，相应的apk包的大小也急剧增加， 那么终有一天，你会不幸遇到这个错误.<br><a href="http://mp.weixin.qq.com/s?__biz=MzAwOTE0ODEwMQ==&mid=401731625&idx=1&sn=9bf2bacfbba43ba9dc7b2e854b64e66c&scene=23&srcid=1231ni0s2Y0OMfYSoNhkkJ47#rd&ADUIN=289832127&ADSESSION=1451551778&ADTAG=CLIENT.QQ.5425_.0&ADPUBNO=26509" target="_blank">8.途牛原创|途牛Android App的插件实现</a><br><br><br><br>途牛的插件化是基于dynamic-load-apk（github）实现的。定义了宿主和插件的通信方式，使得两者能够互起对方的页面，调用彼此的功能。同时对activity的启动方式singletask等进行了模式实现，并增加了对Service的支持等。总之使得插件开发最大限度的保持着原有的Android开发习惯。<a href="http://blog.csdn.net/singwhatiwanna/article/details/23387079" target="_blank">9. Android apk资源加载和activity生命周期管理</a><br><br><br><br>博主分析了Android中apk的动态加载机制，并在文章的最后指出需要解决的两个复杂问题：资源的访问和activity生命周期的管理，而本文将会分析这两个复杂问题的解决方法。<a href="http://blog.csdn.net/singwhatiwanna/article/details/39937639" target="_blank">10.APK动态加载框架（DL）解析</a><br><br><br><br>首先要说的是动态加载技术（或者说插件化）在技术驱动型的公司中扮演这相当重要的角色，当项目越来越庞大的时候，需要通过插件化来减轻应用的内存和cpu占用，还可以实现热插拔，即在不发布新版本的情况下更新某些模块。<br><br><b>系列</b><br><br><a href="https://segmentfault.com/a/1190000004062866" target="_blank">1.Kaedea—Android动态加载技术 简单易懂的介绍</a><br><br><br><br>我们很早开始就在Android项目中采用了动态加载技术，主要目的是为了达到让用户不用重新安装APK就能升级应用的功能（特别是 SDK项目），这样一来不但可以大大提高应用新版本的覆盖率，也减少了服务器对旧版本接口兼容的压力，同时如果也可以快速修复一些线上的BUG。<a href="https://segmentfault.com/a/1190000004062880" target="_blank">2.Kaedea—Android动态加载基础 ClassLoader的工作机制</a><br><br><br><br>早期使用过Eclipse等Java编写的软件的同学可能比较熟悉，Eclipse可以加载许多第三方的插件（或者叫扩展），这就是动态加载。这些插件大多是一些Jar包，而使用插件其实就是动态加载Jar包里的Class进行工作。<a href="https://segmentfault.com/a/1190000004062899" target="_blank">3.Kaedea—Android动态加载补充 加载SD卡的SO库</a><br><br><br><br>Android中JNI的使用其实就包含了动态加载，APP运行时动态加载.so库并通过JNI调用其封装好的方法。后者一般是使用NDK工具从C/C++代码编译而成，运行在Native层，效率会比执行在虚拟机的Java代码高很多，所以Android中经常通过动态加载.so库来完成一些对性能比较有需求的工作（比如T9搜索、或者Bitmap的解码、图片高斯模糊处理等）。<a href="https://segmentfault.com/a/1190000004062952" target="_blank">4.Kaedea—Android动态加载入门 简单加载模式</a><br><br><br><br>Java程序中，JVM虚拟机是通过类加载器ClassLoader加载.jar文件里面的类的。Android也类似，不过Android用的是Dalvik/ART虚拟机，不是JVM，也不能直接加载.jar文件，而是加载dex文件。<a href="https://segmentfault.com/a/1190000004062972" target="_blank">5.Kaedea—Android动态加载进阶 代理Activity模式</a><br><br><br><br>简单模式中，使用ClassLoader加载外部的Dex或Apk文件，可以加载一些本地APP不存在的类，从而执行一些新的代码逻辑。但是使用这种方法却不能直接启动插件里的Activity。<a href="https://segmentfault.com/a/1190000004077469" target="_blank">6.Kaedea—Android动态加载黑科技 动态创建Activity模式</a><br><br><br><br>还记得我们在代理Activity模式里谈到启动插件APK里的Activity的两个难题吗，由于插件里的Activity没在主项目的Manifest里面注册，所以无法经历系统Framework层级的一系列初始化过程，最终导致获得的Activity实例并没有生命周期和无法使用res资源。<a href="http://blog.csdn.net/jiangwei0910410003/article/details/17679823" target="_blank">7.尼古拉斯—插件开发基础篇：动态加载技术解读</a><br><br><br><br>在目前的软硬件环境下，Native App与Web App在用户体验上有着明显的优势，但在实际项目中有些会因为业务的频繁变更而频繁的升级客户端，造成较差的用户体验，而这也恰恰是Web App的优势。本文对网上Android动态加载jar的资料进行梳理和实践在这里与大家一起分享，试图改善频繁升级这一弊病。<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41384667" target="_blank">8.尼古拉斯—插件开发开篇：类加载器分析</a><br><br><br><br>这篇文章主要介绍了Android中主要的两个类加载器：PathClassLoader和DexClassLoader,他们的区别，联系，用法等问题，以及我们在制作插件的过程中会遇到哪些常见的问题。这篇文章也是后续两篇文章的基础，因为如果不了解这两个类的话，我们将无法进行后续的操作。<a href="http://blog.csdn.net/jiangwei0910410003/article/details/47679843" target="_blank">9.尼古拉斯—插件开发中篇：资源加载问题(换肤原理解析)</a><br><br><br><br>这篇文章主要通过现在一些应用自带的换肤技术的解读来看看，在开发插件的过程中如何解决一些资源加载上的问题，这个问题为何要单独拿出来解释，就是因为他涉及的知识很多，也是后面一篇文章的基础，我们在需要加载插件中的资源文件的时候。<a href="http://blog.csdn.net/jiangwei0910410003/article/details/48104455" target="_blank">10.尼古拉斯—插件开发终极篇：动态加载Activity(免安装运行程序)</a><br><br><br><br>这篇文章主要是讲解了如何加载插件中的Activity。从而实现免安装运行程序，同时这篇文章也是对前三篇文章知识的综合使用。下载很多应用都会使用到插件技术，因为包的大小和一些功能的优先级来决定哪些模块可以制作成插件。<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/" target="_blank">11.Weishu—Android插件化原理解析——概要</a><br><br><br><br>类的加载可以使用Java的ClassLoader机制，但是对于Android来说，并不是说类加载进来就可以用了，很多组件都是有“生命”的；因此对于这些有血有肉的类，必须给它们注入活力，也就是所谓的组件生命周期管理.<a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/" target="_blank">12.Weishu—Android插件化原理解析——Hook机制之动态代理</a><br><br><br><br>使用代理机制进行API Hook进而达到方法增强是框架的常用手段，比如J2EE框架Spring通过动态代理优雅地实现了AOP编程，极大地提升了Web开发效率；同样，插件框架也广泛使用了代理机制来增强系统API从而达到插件化的目的.<a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/" target="_blank">13.Weishu—Android插件化原理解析——Hook机制之Binder Hook</a><br><br><br><br>Android系统通过Binder机制给应用程序提供了一系列的系统服务，诸如ActivityManagerService，ClipboardManager， AudioManager等；这些广泛存在系统服务给应用程序提供了诸如任务管理，音频，视频等异常强大的功能。<a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/" target="_blank">14.Weishu—Android 插件化原理解析——Hook机制之AMS&amp;PMS</a><br><br><br><br>在前面的文章中我们介绍了DroidPlugin的Hook机制，也就是代理方式和Binder Hook；插件框架通过AOP实现了插件使用和开发的透明性。在讲述DroidPlugin如何实现四大组件的插件化之前，有必要说明一下它对AMS以及PMS的Hook方式。<a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/" target="_blank">15.Weishu—Android 插件化原理解析——Activity生命周期管理</a><br><br><br><br>之前的 Android插件化原理解析 系列文章揭开了Hook机制的神秘面纱，现在我们手握倚天屠龙，那么如何通过这种技术完成插件化方案呢？具体来说，插件中的Activity，Service等组件如何在Android系统上运行起来？<br><a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/" target="_blank">16.Weishu—Android 插件化原理解析——插件加载机制</a><br><br><br><br>上文 Activity生命周期管理 中我们地完成了『启动没有在AndroidManifest.xml中显式声明的Activity』的任务；通过Hook AMS和拦截ActivityThread中H类对于组件调度我们成功地绕过了AndroidMAnifest.xml的限制。<br><a href="http://weishu.me/2016/04/12/understand-plugin-framework-receiver/" target="_blank">17.Weishu—Android插件化原理解析——广播的管理</a><br><br><br><br>在Activity生命周期管理 以及 插件加载机制 中我们详细讲述了插件化过程中对于Activity组件的处理方式，为了实现Activity的插件化我们付出了相当多的努力；那么Android系统的其他组件，比如BroadcastReceiver，Service还有ContentProvider，它们又该如何处理呢？<a href="http://weishu.me/2016/05/11/understand-plugin-framework-service/" target="_blank">18.Weishu—Android 插件化原理解析——Service的插件化</a><br><br><br><br>在 Activity生命周期管理 以及 广播的管理 中我们详细探讨了Android系统中的Activity、BroadcastReceiver组件的工作原理以及它们的插件化方案，相信读者已经对Android Framework和插件化技术有了一定的了解；<br><br><b>类库</b><br><br><a href="https://github.com/Qihoo360/DroidPlugin" target="_blank">1.DroidPlugin</a><br><br><br><br>是360手机助手在Android系统上实现了一种新的插件机制<a href="https://github.com/limpoxe/Android-Plugin-Framework" target="_blank">2.Android-Plugin-Framework</a><br><br><br><br>此项目是Android插件开发框架完整源码及示例。用来通过动态加载的方式在宿主程序中运行插件APK。<a href="https://github.com/wequick/Small" target="_blank">3.Small</a><br><br><br><br>世界那么大，组件那么小。Small，做最轻巧的跨平台插件化框架。里面有很详细的文档<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank">4.dynamic-load-apk</a><br><br><br><br>Android 使用动态加载框架DL进行插件化开发<a href=" https://github.com/mmin18/AndroidDynamicLoader" target="_blank">5.AndroidDynamicLoader</a><br><br><br><br>Android 动态加载框架，他不是用代理 Activity 的方式实现而是用 Fragment 以及 Schema 的方式实现<a href="https://github.com/CtripMobile/DynamicAPK" target="_blank">6.DynamicAPK</a><br><br><br><br>实现Android App多apk插件化和动态加载，支持资源分包和热修复.携程App的插件化和动态加载框架.<a href="https://github.com/bunnyblue/ACDD/blob/master/README-Zh.md" target="_blank">7.ACDD</a><br><br><br>非代理Android动态部署框架<a href="https://github.com/houkx/android-pluginmgr" target="_blank">8.android-pluginmgr</a><br><br><br>不需要插件规范的apk动态加载框架。<br><b>参考视频</b><br><br><a href="http://www.infoq.com/cn/presentations/the-realization-principle-and-application-of-droidplugin" target="_blank">1.DroidPlugin的实现原理及其应用</a><br><br><br><br>Droid Plugin是360手机助手在2015年初研发的一个全新的基于Android平台的插件机制.<a href="http://v.youku.com/v_show/id_XNTMzMjYzMzM2.html" target="_blank">2.android插件化及动态部署</a><br><br><br><br> 阿里技术沙龙第十六期《android插件化及动态部署》视频  </section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;body&gt;&lt;/body&gt;&lt;/p&gt;
&lt;section class=&quot;content&quot;&gt;&lt;br&gt;&lt;ul class=&quot;items&quot;&gt;&lt;br&gt;    &lt;li style=&quot;background: #FFFFFF&quot;&gt;&lt;br&gt;    &lt;h1&gt;&lt;a href=&quot;#&quot; title=&quot;t
      
    
    </summary>
    
      <category term="develop" scheme="http://yoursite.com/categories/develop/"/>
    
    
      <category term="develop" scheme="http://yoursite.com/tags/develop/"/>
    
  </entry>
  
  <entry>
    <title>Github Top100</title>
    <link href="http://yoursite.com/2018/07/11/Github-Top100/"/>
    <id>http://yoursite.com/2018/07/11/Github-Top100/</id>
    <published>2018-07-11T01:16:30.000Z</published>
    <updated>2018-07-11T01:16:54.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="转-GitHub-Top-100-简介"><a href="#转-GitHub-Top-100-简介" class="headerlink" title="(转) GitHub Top 100 简介"></a>(转) GitHub Top 100 简介</h2><p>主要对当前 GitHub 排名前 100 的项目做一个简单的简介, 方便初学者快速了解到当前 Objective-C 在 GitHub 的情况.</p><table><thead><tr><th>项目名称</th><th>项目信息</th></tr></thead><tbody><tr><td>1. <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a></td><td>作者是 NSHipster 的博主, iOS 开发界的大神级人物, 毕业于卡内基·梅隆大学, 开源了许多牛逼的项目, 这个便是其中之一, AFNetworking 采用 NSURLConnection + NSOperation, 主要方便与服务端 API 进行数据交换, 操作简单, 功能强大, 现在许多人都用它取代 ASIHTTPRequest</td></tr><tr><td>2. <a href="https://github.com/BradLarson/GPUImage" target="_blank" rel="noopener">GPUImage</a></td><td>一款强大的图片滤镜工具, 支持自定义滤镜, 可用来实时处理图片和视频流, 作者是 SonoPlot 公司的 CTO, 在很小的时候便开始接触编程, 他在 <a href="http://stackoverflow.com/users/19679/brad-larson" target="_blank" rel="noopener">SO</a> 上面的回答也有很多值得阅读, GPUImage 这个项目从 2012 年开始, 使用 OpenGL 图形程序接口编写, 性能非常好, 现在很多 iOS 程序员都用它来实现 iOS 的模糊效果</td></tr><tr><td>3. <a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a></td><td>作者 Olivier Poitrey 是 Dailymotion 的 CTO, 拥有多个不错的开源项目, 此项目常用于对从 Web 端接受到的图片进行缓存, 是 UIImageView 的扩展, 应用起来比较简单</td></tr><tr><td>4. <a href="https://github.com/RestKit/RestKit" target="_blank" rel="noopener">RestKit</a></td><td>主要用于 iOS 上网络通信, 允许与 RESTful Web 服务交互, 常用于处理 API, 解析 JSON, 映射响应对象等操作, 简单易用, 方便你把所有精力都放在对数据的操作上</td></tr><tr><td>5. <a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa</a></td><td>由 GitHub 工程师们开发的一个应用于 iOS 和 OS X 开发的函数响应式编程新框架, Matt 称其为 “An open source project that exemplifies this brave new era for Objective-C”, 也有人说它是 Cocoa 的未来, 具体可看唐巧写的这篇<a href="http://www.devtang.com/blog/2014/02/11/reactivecocoa-introduction" target="_blank" rel="noopener">文章</a></td></tr><tr><td>6. <a href="https://github.com/facebookarchive/three20" target="_blank" rel="noopener">three20</a></td><td>由 Facebook iOS 客户端衍生出的一款 iPhone 框架, 内置许多丰富的功能, 有丰富的界面, 对底层的操作便捷, 为开发者省下了很多时间, 但现在已经停止了更新, 一个 <a href="https://github.com/facebookarchive/three20/pull/832?utm_source=iOS+Dev+Weekly&amp;utm_campaign=46a7deb647-iOS_Dev_Weekly_Issue_100&amp;utm_medium=email&amp;utm_term=0_7bda94b7ca-46a7deb647-299428269" target="_blank" rel="noopener">PR</a> 把代码删得干干净净, 不要好奇去点开 Files changed, 我点开后该页面直接卡死, three20 当中的一位作者创建了 <a href="https://github.com/jverkoey/nimbus" target="_blank" rel="noopener">Nimbus</a>, 算是 three20 的一个替代品</td></tr><tr><td>7. <a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="noopener">MBProgressHUD</a></td><td>作者 Matej Bukovinski 是一位全栈工程师, UI/UX 设计师,  此项目是一款提示框第三方库, 帮助开发者快速应用到项目中)</td></tr><tr><td>8. <a href="https://github.com/magicalpanda/MagicalRecord" target="_blank" rel="noopener">MagicalRecord</a></td><td>作者是 Coursera 的 iOS 工程师, 该项目创作灵感来自于 Ruby on Rails 的 Active Record, 主要为方便操作 CoreData 而生, 帮助清除 CoreData 引用的代码, 协助方便 CoreData 的工作</td></tr><tr><td>9. <a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB</a></td><td>一个对 SQLite 进行封装的库, 使用起来方便, 简单</td></tr><tr><td>10. <a href="https://github.com/Mantle/Mantle" target="_blank" rel="noopener">Mantle</a></td><td>作者是 GitHub 的员工, 文档写的很清楚: Mantle makes it easy to write a simple model layer for your Cocoa or Cocoa Touch application, 主要用来将 JSON 数据模型化为 Model 对象, 唱吧在前段时间也改用 Mantle 了.</td></tr><tr><td>11. <a href="https://github.com/Grouper/FlatUIKit" target="_blank" rel="noopener">FlatUIKit</a></td><td>收集了很多扁平化 UI 的 iOS 组件, 方便使用</td></tr><tr><td>12. <a href="https://github.com/pokeb/asi-http-request" target="_blank" rel="noopener">ASIHTTPRequest</a></td><td>一个轻量级的 iOS 网络通信类库, 基于 CFNetwork 框架开发, 但现在已经停止更新, 多数开发者改用 AFNetworking 替代)</td></tr><tr><td>13. <a href="https://github.com/path/FastImageCache" target="_blank" rel="noopener">FastImageCache</a></td><td>Path 公司出品的 iOS 库, 作者 Mallory Paine 是苹果前员工, 此类库适用于在滚动时快速显示图像, 高速持久是其最大的特点</td></tr><tr><td>14. <a href="https://github.com/Masonry/Masonry" target="_blank" rel="noopener">Masonry</a></td><td>一个轻量级的布局框架, 同时支持 iOS 和 Mac OS X, 语法优雅, 帮助开发者快速适配不同分辨率的 iOS 设备</td></tr><tr><td>15. <a href="https://github.com/facebook/Shimmer" target="_blank" rel="noopener">Shimmer</a></td><td>Facebook 推出的一款具有闪烁效果的第三方控件, 供它旗下一款名为 Paper 的应用使用, 安装使用整个过程都十分简单</td></tr><tr><td>16. <a href="https://github.com/TransitApp/SVProgressHUD" target="_blank" rel="noopener">SVProgressHUD</a></td><td>又一款轻量级的 iOS 第三方控件, 用于显示任务加载时的动画, 非常轻便, 容易使用</td></tr><tr><td>17. <a href="https://github.com/jigish/slate" target="_blank" rel="noopener">Slate</a></td><td>一款窗口管理应用程序, 但在两年前就已经停止更新了</td></tr><tr><td>18. <a href="https://github.com/johnezang/JSONKit" target="_blank" rel="noopener">JSONKit</a></td><td>主要用于解析 JSON, 适用于 iOS6 以下环境, 自从 iOS5 开始 Apple 官方给出了 NSJSONSerialization API, 自此大家都用官方的了</td></tr><tr><td>19. <a href="https://github.com/jverkoey/nimbus" target="_blank" rel="noopener">Nimbus</a></td><td>作者 Jeff 曾为 Facebook, Google 做过不少好东西, 也是 three20 的成员之一, three20 停更后, 他创造出这个框架来代替 three20, 文档齐全</td></tr><tr><td>20. <a href="https://github.com/CocoaLumberjack/CocoaLumberjack" target="_blank" rel="noopener">CocoaLumberjack</a></td><td>这是 Mac 和 iOS 的一款强大的日志框架, 配置简单, 多线程, 提供更高级的 log 功能, 可用于代替默认的 NSLog 语句</td></tr><tr><td>21. <a href="https://github.com/facebook/facebook-ios-sdk" target="_blank" rel="noopener">Facebook SDK for iOS</a></td><td>Facebook 官方的 iOS SDK, 方便开发者集成 Facebook 的一些功能到自己的 iOS APP 里面</td></tr><tr><td>22. <a href="https://github.com/facebook/AsyncDisplayKit" target="_blank" rel="noopener">AsyncDisplayKit</a></td><td>Facebook 开源的一款 iOS UI 框架, Paper 用的就是该框架, 另外框架还用到了 Facebook 早期开源 Pop 动画引擎</td></tr><tr><td>23. <a href="https://github.com/supermarin/Alcatraz" target="_blank" rel="noopener">Alcatraz</a></td><td>Alcatraz 是一款管理 Xcode 插件、模版以及颜色配置的工具, 可以集成到 Xcode 的图形界面中, 安装删除都是几条命令的事, 很方便, 支持自己开发插件并上传</td></tr><tr><td>24. <a href="https://github.com/Inferis/ViewDeck" target="_blank" rel="noopener">ViewDeck</a></td><td>一款开源的 iOS 活动面板组件, 还原 Path 2.0 的侧滑效果, 作者因为时间关系在两年前停止对其更新</td></tr><tr><td>25. <a href="https://github.com/jessesquires/JSQMessagesViewController" target="_blank" rel="noopener">JSQMessagesViewController</a></td><td>优雅的 iOS 消息类库, 常用于聊天应用中, 可定制性高</td></tr><tr><td>26. <a href="https://github.com/Flipboard/FLEX" target="_blank" rel="noopener">FLEX</a></td><td>这是 Flipboard 官方发布的一组专门用于 iOS 开发的应用内调试工具, 开发者无需将其连接到 LLDB/Xcode 或其他远程调试服务器,支持直接在 App 中运行</td></tr><tr><td>27. <a href="https://github.com/facebook/xctool" target="_blank" rel="noopener">Xctool</a></td><td>是 Facebook 开源的一个命令行工具，用来替代苹果的 XcodeBuild 工具, 极大的方便了 iOS 的构建和测试, 输出错误信息也比较友好, 受到许多 iOS 开发者的称赞, 经常与其搭配使用的还有 OCUnit, <a href="https://travis-ci.org" target="_blank" rel="noopener">Travis CI</a>, <a href="http://oclint.org" target="_blank" rel="noopener">OCLint</a> 等测试工具</td></tr><tr><td>28. <a href="https://github.com/OpenEmu/OpenEmu" target="_blank" rel="noopener">OpenEmu</a></td><td>超强的游戏模拟器, 做游戏开发必备, 官网做得也很不错</td></tr><tr><td>29. <a href="https://github.com/nicklockwood/iCarousel" target="_blank" rel="noopener">iCarousel</a></td><td>作者是英国 Charcoal Design 公司的创始人, 开源领域的贡献颇为卓著, 这个项目就是其中之一, 这是一款可以在 iOS 上实现旋转木马视图切换效果的第三方控件, 并提供多种切换效果</td></tr><tr><td>30. <a href="https://github.com/romaonthego/RESideMenu" target="_blank" rel="noopener">RESideMenu</a></td><td>作者 Roman Efimov 是雅虎的 iOS 工程师, 这个项目实现了 iOS 上的菜单侧滑效果, 创意来源于 Dribbble, 该项目支持 iOS8</td></tr><tr><td>321 <a href="https://github.com/kevinzhow/PNChart" target="_blank" rel="noopener">PNChart</a></td><td>作者周楷雯是 90 后, 秒视的创始人, 该项目是一个带动画效果的图表控件, 简约易用, 受到不少开发者喜爱</td></tr><tr><td>31.2<a href="https://github.com/square/PonyDebugger" target="_blank" rel="noopener">PonyDebugger</a></td><td>由 Square 公司推出的一款优秀的 iOS 应用网络调试工具, 用户可以实时看到应用程序的网络请求, 也可以对 iOS 应用程序的核心数据栈进行远程调试</td></tr><tr><td>33. <a href="https://github.com/jverdi/JVFloatLabeledTextField" target="_blank" rel="noopener">JVFloatLabeledTextField</a></td><td>作者是 Thumb Labs 的联合创始人, JVFloatLabeledTextField 是 UITextField 的子类, 主要实现输入框标签浮动效果, 创作灵感来自 Dribbble, 已出现多个移植版本</td></tr><tr><td>34. <a href="https://github.com/CEWendel/SWTableViewCell" target="_blank" rel="noopener">SWTableViewCell</a></td><td>UITableViewCell 的子类, 实现了左右滑动显示信息视图并调出按钮</td></tr><tr><td>35. <a href="https://github.com/levey/AwesomeMenu" target="_blank" rel="noopener">AwesomeMenu</a></td><td>作者是一位中国人, 该项目主要是使用 CoreAnimation 还原了 Path menu 的动画效果</td></tr><tr><td>36. <a href="https://github.com/tonymillion/Reachability" target="_blank" rel="noopener">Reachability</a></td><td>Reachablity 是用于检测 iOS 设备网络环境的库</td></tr><tr><td>37. <a href="https://github.com/onevcat/VVDocumenter-Xcode" target="_blank" rel="noopener">VVDocumenter-Xcode</a></td><td>作者是王巍国内著名的 iOS 开发者, 人称喵神, 目前在日本 LINE 公司工作, 该项目帮助开发者轻松的生成注释文档, 节省了不少工作量, 赞</td></tr><tr><td>38. <a href="https://github.com/google/physical-web" target="_blank" rel="noopener">The Physical Web</a></td><td>由 Chrome 团队主导的一个项目, 意在用 URL 连接世界, 方便用户接受数据, 目前尚处在实验阶段</td></tr><tr><td>39. <a href="https://github.com/samuelclay/NewsBlur" target="_blank" rel="noopener">NewsBlur</a></td><td>作者独自一个人 Samuel Clay 做出来的一款名为 NewsBlur 的新闻阅读器, 很多人都称其为 Google Reader 的替代品, 这是它的源码</td></tr><tr><td>40. <a href="https://github.com/cocos2d/cocos2d-spritebuilder" target="_blank" rel="noopener">Cocos2D-SpriteBuilder</a></td><td>一个可用于在 iOS, Mac 和 Android 上制作 2D 游戏或其它图形/交互应用的框架, 之前的项目名称为 Cocos Swift,  目前该项目在 GitHub 上更新较为频繁</td></tr><tr><td>41. <a href="https://github.com/TTTAttributedLabel/TTTAttributedLabel" target="_blank" rel="noopener">TTTAttributedLabel</a></td><td>UILabel 的替代品, 使 iOS 上的 Label 功能更加丰富, 可支持链接植入等功能</td></tr><tr><td>42. <a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="noopener">CocoaAsyncSocket</a></td><td>一个功能强大、简单易用的异步 socket 通讯类库, 支持 TCP 和 UDP 协议, 可用于 Mac 和 iOS 设备上, 作者 Robbie Hanson 是 Deusty 的首席软件工程师</td></tr><tr><td>43. <a href="https://github.com/devinross/tapkulibrary" target="_blank" rel="noopener">TapkuLibrary</a></td><td>作者是 Devin Ross, 这是在 iOS 上一款功能强大的 UI 效果类库, 可以实现多种酷炫的效果, 目前仍在更新中</td></tr><tr><td>44. <a href="https://github.com/CanvasPod/Canvas" target="_blank" rel="noopener">Canvas</a></td><td>无需编码实现牛逼的动画效果的库, 连设计师都可以快速上手</td></tr><tr><td>45. <a href="https://github.com/square/SocketRocket" target="_blank" rel="noopener">SocketRocket</a></td><td>Square 公司开源的一个 WebSocket 客户端, 稳定并且易用, 做实时应用常会用到, 受广大开发者喜爱</td></tr><tr><td>46. <a href="https://github.com/ECSlidingViewController/ECSlidingViewController" target="_blank" rel="noopener">ECSlidingViewController</a></td><td>一个视图控制器容器, 将子视图处理成两层, 通过滑动来处理层的切换, 创作灵感来自 Facebook 和 Path的 App, 作者是 Cleveland 的员工</td></tr><tr><td>47. <a href="https://github.com/stig/json-framework" target="_blank" rel="noopener">Json Framework</a></td><td>用于解析 JSON 数据的一个框架, 但是在 iOS5 以上版本大多数人都选择使用 NSJSONSerialization 来解析 JSON, 该项目现在在 GitHub 上也几乎没怎么更新了</td></tr><tr><td>48. <a href="https://github.com/facebook/Tweaks" target="_blank" rel="noopener">Tweaks</a></td><td>Facebook 开源的一款工具, 旨在帮助 iOS 开发者更快的迭代应用, 方便用户动态的调整参数, 是的, Paper 这个项目也用到了</td></tr><tr><td>49. <a href="https://github.com/realm/realm-cocoa" target="_blank" rel="noopener">realm-cocoa</a></td><td>Realm-Cocoa 是 Realm 公司推出一款移动端数据库, 可以运行在手机、平板和可穿戴设备之上, 其目标是取代 CoreData 和 SQLite 数据库</td></tr><tr><td>50. <a href="https://github.com/zwaldowski/BlocksKit" target="_blank" rel="noopener">BlocksKit</a></td><td>一个开源的与 Cocoa 紧密集合的基础性框架</td></tr><tr><td>51. <a href="https://github.com/arashpayan/appirater" target="_blank" rel="noopener">Appirater</a></td><td>一款用于提醒用户给你的 App 打分的工具</td></tr><tr><td>52. <a href="https://github.com/kif-framework/KIF" target="_blank" rel="noopener">KIF</a></td><td>Square 出品的一个开源的用户界面测试框架, 极大的简化了 iOS 开发者的 UI 测试流程</td></tr><tr><td>53. <a href="https://github.com/slackhq/SlackTextViewController" target="_blank" rel="noopener">SlackTextViewController</a></td><td>Slack 推出的一款具有文字输入框高度自适应, 自动输入, 复制单元格内容等功能的解决方案</td></tr><tr><td>54. <a href="https://github.com/IFTTT/JazzHands" target="_blank" rel="noopener">JazzHands</a></td><td>IFTTT 开源的一个简单易用的关键帧基础动画框架, 可通过手势、scroll views, KVO, ReactiveCocoa 等方式来控制动画</td></tr><tr><td>55. <a href="https://github.com/BoltsFramework/Bolts-iOS" target="_blank" rel="noopener">Bolts-iOS</a></td><td>Bolts 是一个 Parse 和 Facebook 在内部使用的底层库, 方便移动开发</td></tr><tr><td>56. <a href="https://github.com/eczarny/spectacle" target="_blank" rel="noopener">Spectacle</a></td><td>一款易用的 OS X 窗口分屏操作快捷键工具, 这是其源代码</td></tr><tr><td>57. <a href="https://github.com/tombenner/nui" target="_blank" rel="noopener">nui</a></td><td>方便样式化 iOS 应用中的 UI 元素, 可在短时间内样式化整个应用, 类 CSS 原理</td></tr><tr><td>58. <a href="https://github.com/Induction/Induction" target="_blank" rel="noopener">Induction</a></td><td>Induction 是一款用于理解数据关系的管理工具, 这是其程序代码</td></tr><tr><td>59. <a href="https://github.com/icanzilb/JSONModel" target="_blank" rel="noopener">JSONModel</a></td><td>一个能迅速解析服务器返回的 Json 数据的库, 方便数据的类型转换</td></tr><tr><td>60. <a href="https://github.com/Cocoanetics/DTCoreText" target="_blank" rel="noopener">DTCoreText</a></td><td>一个开源的 iOS 富文本组件, 它可以解析 HTML 与 CSS 并最终用 CoreText 绘制出来, 通常用于在一些需要显示富文本的场景下代替低性能的 UIWebView</td></tr><tr><td>61. <a href="https://github.com/schneiderandre/popping" target="_blank" rel="noopener">Popping</a></td><td>基于 Facebook Pop 引擎的 iOS 动画库, 集合了很多动画效果</td></tr><tr><td>62. <a href="https://github.com/KrauseFx/TSMessages" target="_blank" rel="noopener">TSMessages</a></td><td>一个用来弹出显示警告和通知的轻量级库, 样式丰富, 简单易用</td></tr><tr><td>63. <a href="https://github.com/facebook/KVOController" target="_blank" rel="noopener">KVOController</a></td><td>一个简单安全的 KVO(Key-value Observing, 键-值 观察)工具, 提供简单方便、线程安全的API, Facebook 的开源项目之一</td></tr><tr><td>64. <a href="https://github.com/mwaterfall/MWPhotoBrowser" target="_blank" rel="noopener">MWPhotoBrowser</a></td><td>一款简单的 iOS 照片浏览控件</td></tr><tr><td>65. <a href="https://github.com/mutualmobile/MMDrawerController" target="_blank" rel="noopener">MMDrawerController</a></td><td>一个轻量级, 易于使用的侧边抽屉导航 iOS 控件</td></tr><tr><td>66. <a href="https://github.com/escoz/QuickDialog" target="_blank" rel="noopener">QuickDialog</a></td><td>用于快速创建复杂的 iOS 表单, 自定义了 UITableViewCell, TableView 的样式</td></tr><tr><td>67. <a href="https://github.com/samvermette/SVPullToRefresh" target="_blank" rel="noopener">SVPullToRefresh</a></td><td>一款只需一行代码便可集成上拉刷新和下拉加载的组件</td></tr><tr><td>68. <a href="https://github.com/nothingmagical/cheddar-ios" target="_blank" rel="noopener">cheddar-ios</a></td><td>Cheddar 是一款简单易用的日程管理软件, 这是其早期版本的开源代码, 该项目已停止维护</td></tr><tr><td>69. <a href="https://github.com/XVimProject/XVim" target="_blank" rel="noopener">XVim</a></td><td>一款在 Xcode 上实现了 Vim 功能的插件</td></tr><tr><td>70. <a href="https://github.com/enormego/EGOTableViewPullRefresh" target="_blank" rel="noopener">EGOTableViewPullRefresh</a></td><td>一款提供下拉刷新的控件, 最后更新时间是一年前</td></tr><tr><td>71. <a href="https://github.com/gimenete/iOS-boilerplate" target="_blank" rel="noopener">iOS-boilerplate</a></td><td>iOS 应用程序的基础模板, 使用该模板可以省掉许多项目初始编码的工作, 内置非常多丰富的功能, 现已经停止维护</td></tr><tr><td>72. <a href="https://github.com/gotosleep/JASidePanels" target="_blank" rel="noopener">JASidePanels</a></td><td>一个 UIViewController 容器, 灵感来自 Facebook 和 Path 2.0 应用的菜单, 实现了左右侧滑的操作</td></tr><tr><td>73. <a href="https://github.com/mattt/FormatterKit" target="_blank" rel="noopener">FormatterKit</a></td><td>收集了很多构思优秀的 NSFormatter 子类</td></tr><tr><td>74. <a href="https://github.com/erichoracek/MSDynamicsDrawerViewController" target="_blank" rel="noopener">MSDynamicsDrawerViewController</a></td><td>实现了具有动态弹性效果的抽屉式侧边导航栏, 效果丰富, 可定制性强</td></tr><tr><td>75. <a href="https://github.com/boctor/idev-recipes" target="_blank" rel="noopener">idev-recipes</a></td><td>iDevRecipes 博客的代码, 演示如何实现一些有趣的控件, 该项目在两年前(2013)停止了更新</td></tr><tr><td>76. <a href="https://github.com/robbiehanson/XMPPFramework" target="_blank" rel="noopener">XMPPFramework</a></td><td>一个基于 RFC-3920 实现, 支持多线程和线程保护, 同时通用于所有的 iOS 和 Mac OS 开发设备的通信框架.</td></tr><tr><td>77. <a href="https://github.com/MacGapProject/MacGap1" target="_blank" rel="noopener">MacGap1</a></td><td>一款可以将 HTML/CSS/JS 网络应用打包成原生 Mac App 的工具</td></tr><tr><td>78. <a href="https://github.com/nicklockwood/FXBlurView" target="_blank" rel="noopener">FXBlurView</a></td><td>iOS 模糊背景类库, 可以方便的根据底层显示的状态生成模糊效果</td></tr><tr><td>79. <a href="https://github.com/shu223/iOS7-Sampler" target="_blank" rel="noopener">iOS7-Sampler</a></td><td>整合演示了多个具有 iOS7 新特性的的项目, 提供了非常多的例子参考</td></tr><tr><td>80. <a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="noopener">PromiseKit</a></td><td>提供强大的 iOS 开发异步功能, 是 Promises 的实现, 受到广大开发者的追捧</td></tr><tr><td>81. <a href="https://github.com/facebook/origami" target="_blank" rel="noopener">Origami</a></td><td>此为 Facebook 推出的 Quartz Composer 的一个开源插件, 由其设计团队花费了 9 个月打造而成, 目的是为方便设计师快速构建原型, 以零代码完成复杂动画的合成和测试, 堪称神器</td></tr><tr><td>82. <a href="https://github.com/fpillet/NSLogger" target="_blank" rel="noopener">NSLogger</a></td><td>一款强大的日志分析工具, 具有大窗口查看 Log, 自定义日志等级等功能</td></tr><tr><td>83. <a href="https://github.com/ksuther/KSImageNamed-Xcode" target="_blank" rel="noopener">KSImageNamed-Xcode</a></td><td>一款对 UIImage 的 imageNamed 提供自动补全功能的插件, 非常方便</td></tr><tr><td>84. <a href="https://github.com/smileyborg/PureLayout" target="_blank" rel="noopener">PureLayout</a></td><td>一个简单却强大的 AutoLayout API 库, 兼容了 Objective-C 和 Swift, 扩展了 UIView/NSView, NSArray, 和 NSLayoutConstraint</td></tr><tr><td>85. <a href="https://github.com/tomaz/appledoc" target="_blank" rel="noopener">AppleDoc</a></td><td>一款 Objective-C 文档生成工具, 生成的文档风格保持与 Apple 官方的一致, 极大的方便了 Xcode 识别自己写的 API 文档, 安装也是十分的简单</td></tr><tr><td>86. <a href="https://github.com/gnachman/iTerm2" target="_blank" rel="noopener">iTerm2</a></td><td>iTerm2 被不少程序员称赞为 Mac 下最好用的终端, 这是其源代码, 配合 oh-my-zsh 使用效果更佳</td></tr><tr><td>87. <a href="https://github.com/kiwi-bdd/Kiwi" target="_blank" rel="noopener">Kiwi</a></td><td>一个行为驱动开发测试框架, 适用于 iOS 平台, 旨在为开发者提供一个简单配置便可使用的 BDD 库</td></tr><tr><td>88. <a href="https://github.com/alloy/terminal-notifier" target="_blank" rel="noopener">terminal-notifier</a></td><td>一款命令行工具, 用来给 Mac OS X 用户发送通知</td></tr><tr><td>89. <a href="https://github.com/uranusjr/macdown" target="_blank" rel="noopener">MacDown</a></td><td>Mac OS X 下的一款开源的 Markdown 编辑器, 创意来自与 Mou, 使用 brew cask 即可完成安装</td></tr><tr><td>90. <a href="https://github.com/twitter/twui" target="_blank" rel="noopener">TwUI</a></td><td>Twitter 开源的一个支持硬件加速的 Mac 的 UI 框架, 最后一次的更新时间是在 3 年前(2012)</td></tr><tr><td>91. <a href="https://github.com/honcheng/PaperFold-for-iOS" target="_blank" rel="noopener">PaperFold for iOS</a></td><td>实现了类似折纸效果的视图切换, 可从不同方向进行切换, 该项目已经许久未更新</td></tr><tr><td>92. <a href="https://github.com/vfr/Reader" target="_blank" rel="noopener">Reader</a></td><td>一款开源的 iOS PDF 阅读器, 附带书签, 列纲要等功能</td></tr><tr><td>93. <a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="noopener">WebViewJavascriptBridge</a></td><td>一个方便使用 Objective-C 与 JavaScript 进行通信的第三方库, 支持消息发送, 接收, 消息处理器的注册与调用以及设置消息处理的回调</td></tr><tr><td>94. <a href="https://github.com/shu223/iOS8-Sampler" target="_blank" rel="noopener">iOS8-Sampler</a></td><td>iOSX-Sampler 系列之一, 整合演示了多个具有 iOS8 新特性的的项目, 提供了非常多的例子参考</td></tr><tr><td>95. <a href="https://github.com/robbiehanson/CocoaHTTPServer" target="_blank" rel="noopener">CocoaHTTPServer</a></td><td>一个用于 Mac OS X 或 iOS 应用的轻量级、可嵌入的HTTP 服务器框架, 方便开发者在应用中嵌入一个 HTTP 服务器</td></tr><tr><td>96. <a href="https://github.com/rsms/kod" target="_blank" rel="noopener">Kod</a></td><td>Mac OS X 上一款专为程序员打造的编辑器, 这是其开源代码, 可惜的是作者在 2011 年停止了维护</td></tr><tr><td>97. <a href="https://github.com/michaeltyson/TPKeyboardAvoiding" target="_blank" rel="noopener">TPKeyboardAvoiding</a></td><td>下拉键盘在 iOS 移动文本字段的通用解决方案, 能够自动处理键盘弹出后出现遮挡到文本输入框的问题</td></tr><tr><td>98. <a href="https://github.com/MugunthKumar/MKNetworkKit" target="_blank" rel="noopener">MKNetworkKit</a></td><td>一个轻量级网络请求框架, 完全基于 ARC, 仅有两个类, 具有自主操作多个网络请求, 更加准确的显示网络活动指标等优点</td></tr><tr><td>99. <a href="https://github.com/pkluz/PKRevealController" target="_blank" rel="noopener">PKRevealController</a></td><td>一个 iOS 平台上的视图控制器集合, 通过展现多个视图控制器来进行控制器之间的切换. 设置简单, 高度灵活</td></tr><tr><td>00. <a href="https://github.com/AlanQuatermain/AQGridView" target="_blank" rel="noopener">AQGridView</a></td><td>一个命令行工具, 通过项目里的 <code>.xcdatamodel</code> 文件, 可以为每个 entity 生成两个类, 方便 CoreData 的使用</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;转-GitHub-Top-100-简介&quot;&gt;&lt;a href=&quot;#转-GitHub-Top-100-简介&quot; class=&quot;headerlink&quot; title=&quot;(转) GitHub Top 100 简介&quot;&gt;&lt;/a&gt;(转) GitHub Top 100 简介&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="develop" scheme="http://yoursite.com/categories/develop/"/>
    
    
      <category term="develop" scheme="http://yoursite.com/tags/develop/"/>
    
  </entry>
  
  <entry>
    <title>Android ack 解决</title>
    <link href="http://yoursite.com/2018/07/11/Android-ack-%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2018/07/11/Android-ack-解决/</id>
    <published>2018-07-11T01:14:27.000Z</published>
    <updated>2018-07-11T01:15:32.754Z</updated>
    
    <content type="html"><![CDATA[<p>当adb出现如下异常时：可以考虑如下做法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\zhaohao1&gt;adb remount</span><br><span class="line">* daemon not running. starting it now on port 5037 *</span><br><span class="line">ADB server didn&apos;t ACK</span><br><span class="line">* failed to start daemon *</span><br><span class="line">error: cannot connect to daemon</span><br></pre></td></tr></table></figure></p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>方法一：<br>（1）查看任务管理器，关闭所有adb.exe,或者运行-&gt;cmd，在命令窗口输入adb kill-server<br>（2）重启eclipse即可<br>方法二, ：<br>如果方法一不行，就查看下自己电脑是否启动了如：91手机助手，360手机 豌豆荚等先把他关闭，重新连接试试，再不行就卸载这些软件应该可以解决。因为这些软件可能占用了android手机跟eclipse连接启动adb的端口<br> 方法三：<br>5037端口被占用的话，也会出现如下提示……<br>于是乎，真像是找到了救命稻草一般，先在命令行中输入如下指令，查看5037这个端口现在是被谁占用了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -a -o <span class="number">5037</span></span><br></pre></td></tr></table></figure></p><p>然后得到如下的一个结果，还真被占用了哦：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP    127.0.0.1:5037         USER-20161115XS:0      LISTENING       7608</span><br><span class="line">TCP    127.0.0.1:5037         USER-20161115XS:64426  CLOSE_WAIT      7608</span><br></pre></td></tr></table></figure></p><pre><code>C:\Users\zhaohao1&gt;netstat -ano | findstr &quot;5037&quot; TCP    127.0.0.1:5037         0.0.0.0:0              LISTENING       4436 TCP    127.0.0.1:5037         127.0.0.1:49343        TIME_WAIT       0</code></pre><p>那这个4792在我机器上，到底是个什么进程呢，好的，接着输入以下命令，把真凶找出来：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /fi <span class="string">"pid eq 4792"</span></span><br></pre></td></tr></table></figure></p><p>然后，额……我郁闷了……是存在adb进程占用端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">映像名称                       PID 会话名              会话#       内存使用</span><br><span class="line">========================= ======== ================</span><br><span class="line">adb.exe                       7608 Console                    1      9,740 K</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当adb出现如下异常时：可以考虑如下做法。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="http://yoursite.com/2018/07/07/hello-world/"/>
    <id>http://yoursite.com/2018/07/07/hello-world/</id>
    <published>2018-07-06T17:19:08.000Z</published>
    <updated>2018-07-06T17:29:33.119Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="blogs" scheme="http://yoursite.com/tags/blogs/"/>
    
  </entry>
  
  <entry>
    <title>Android 拉起通知设置界面</title>
    <link href="http://yoursite.com/2018/07/07/Android-%E6%8B%89%E8%B5%B7%E9%80%9A%E7%9F%A5%E8%AE%BE%E7%BD%AE%E7%95%8C%E9%9D%A2/"/>
    <id>http://yoursite.com/2018/07/07/Android-拉起通知设置界面/</id>
    <published>2018-07-06T17:19:08.000Z</published>
    <updated>2018-07-06T17:28:46.589Z</updated>
    
    <content type="html"><![CDATA[<p>4.4以下并没有提过从app跳转到应用通知设置页面的Action，可考虑跳转到应用详情页面,下面是直接跳转到应用通知设置的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (android.os.Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">                   Intent intent = new Intent();</span><br><span class="line">                   intent.setAction(&quot;android.settings.APP_NOTIFICATION_SETTINGS&quot;);</span><br><span class="line">                   intent.putExtra(&quot;app_package&quot;, getActivity().getPackageName());</span><br><span class="line">                   intent.putExtra(&quot;app_uid&quot;, getActivity().getApplicationInfo().uid);</span><br><span class="line">                   startActivity(intent);</span><br><span class="line">               &#125; else if (android.os.Build.VERSION.SDK_INT == Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">                   Intent intent = new Intent();</span><br><span class="line">                   intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);</span><br><span class="line">                   intent.addCategory(Intent.CATEGORY_DEFAULT);</span><br><span class="line">                   intent.setData(Uri.parse(&quot;package:&quot; + getActivity().getPackageName()));</span><br><span class="line">                   startActivity(intent);</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure></p><p>跳转到应用详情页面的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Intent localIntent = new Intent();</span><br><span class="line">              localIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">              if (Build.VERSION.SDK_INT &gt;= 9) &#123;</span><br><span class="line">                  localIntent.setAction(&quot;android.settings.APPLICATION_DETAILS_SETTINGS&quot;);</span><br><span class="line">                  localIntent.setData(Uri.fromParts(&quot;package&quot;, getActivity().getPackageName(), null));</span><br><span class="line">              &#125; else if (Build.VERSION.SDK_INT &lt;= 8) &#123;</span><br><span class="line">                  localIntent.setAction(Intent.ACTION_VIEW);</span><br><span class="line">                  localIntent.setClassName(&quot;com.android.settings&quot;, &quot;com.android.settings.InstalledAppDetails&quot;);</span><br><span class="line">                  localIntent.putExtra(&quot;com.android.settings.ApplicationPkgName&quot;, getActivity().getPackageName());</span><br><span class="line">              &#125;</span><br><span class="line">              startActivity(localIntent);</span><br></pre></td></tr></table></figure></p><p>对于检测app是否开启通知，同样是针对4.4以上的系统才有效:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NotificationManagerCompat manager = NotificationManagerCompat.from(App.getInstance().getContext());</span><br><span class="line">boolean isOpened = manager.areNotificationsEnabled();</span><br></pre></td></tr></table></figure></p><p>4.4以下调用该方法并不会出错，只是全部返回true,默认开启状态</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;4.4以下并没有提过从app跳转到应用通知设置页面的Action，可考虑跳转到应用详情页面,下面是直接跳转到应用通知设置的代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>markdown 语法</title>
    <link href="http://yoursite.com/2018/07/05/markdown%E8%AF%AD%E6%B3%95(%E8%BD%AC)/"/>
    <id>http://yoursite.com/2018/07/05/markdown语法(转)/</id>
    <published>2018-07-05T15:02:47.000Z</published>
    <updated>2018-07-26T13:20:14.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown-语法，参考CMD-Markdown"><a href="#Markdown-语法，参考CMD-Markdown" class="headerlink" title="Markdown 语法，参考CMD Markdown"></a>Markdown 语法，参考CMD Markdown</h1><hr><p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p><blockquote><ul><li>整理知识，学习笔记</li><li>发布日记，杂文，所见所想</li><li>撰写发布技术文稿（代码支持）</li><li>撰写发布学术论文（LaTeX 公式支持）</li></ul></blockquote><p><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"></p><p>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p><h3 id="Windows-Mac-Linux-全平台客户端"><a href="#Windows-Mac-Linux-全平台客户端" class="headerlink" title="Windows/Mac/Linux 全平台客户端"></a><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="noopener">Windows/Mac/Linux 全平台客户端</a></h3><blockquote><p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class="icon-file"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p></blockquote><hr><h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p><h3 id="1-制作一份待办事宜-Todo-列表"><a href="#1-制作一份待办事宜-Todo-列表" class="headerlink" title="1. 制作一份待办事宜 Todo 列表"></a>1. 制作一份待办事宜 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表" target="_blank" rel="noopener">Todo 列表</a></h3><ul><li style="list-style: none"><input type="checkbox"> 支持以 PDF 格式导出文稿</li><li style="list-style: none"><input type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li><li style="list-style: none"><input type="checkbox" checked> 新增 Todo 列表功能</li><li style="list-style: none"><input type="checkbox" checked> 修复 LaTex 公式渲染问题</li><li style="list-style: none"><input type="checkbox" checked> 新增 LaTex 公式编号功能</li></ul><h3 id="2-书写一个质能守恒公式-LaTeX"><a href="#2-书写一个质能守恒公式-LaTeX" class="headerlink" title="2. 书写一个质能守恒公式[^LaTeX]"></a>2. 书写一个质能守恒公式[^LaTeX]</h3><p>$$E=mc^2$$</p><h3 id="3-高亮一段代码-code"><a href="#3-高亮一段代码-code" class="headerlink" title="3. 高亮一段代码[^code]"></a>3. 高亮一段代码[^code]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># A comment</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure><h3 id="4-高效绘制-流程图"><a href="#4-高效绘制-流程图" class="headerlink" title="4. 高效绘制 流程图"></a>4. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图" target="_blank" rel="noopener">流程图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><h3 id="5-高效绘制-序列图"><a href="#5-高效绘制-序列图" class="headerlink" title="5. 高效绘制 序列图"></a>5. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图" target="_blank" rel="noopener">序列图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><h3 id="6-高效绘制-甘特图"><a href="#6-高效绘制-甘特图" class="headerlink" title="6. 高效绘制 甘特图"></a>6. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-甘特图" target="_blank" rel="noopener">甘特图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title 项目开发流程</span><br><span class="line">section 项目确定</span><br><span class="line">    需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">    可行性报告     :after a1, 5d</span><br><span class="line">    概念验证       : 5d</span><br><span class="line">section 项目实施</span><br><span class="line">    概要设计      :2016-07-05  , 5d</span><br><span class="line">    详细设计      :2016-07-08, 10d</span><br><span class="line">    编码          :2016-07-15, 10d</span><br><span class="line">    测试          :2016-07-22, 5d</span><br><span class="line">section 发布验收</span><br><span class="line">    发布: 2d</span><br><span class="line">    验收: 3d</span><br></pre></td></tr></table></figure><h3 id="7-绘制表格"><a href="#7-绘制表格" class="headerlink" title="7. 绘制表格"></a>7. 绘制表格</h3><table><thead><tr><th>项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td>计算机</td><td style="text-align:right">\$1600</td><td style="text-align:center">5</td></tr><tr><td>手机</td><td style="text-align:right">\$12</td><td style="text-align:center">12</td></tr><tr><td>管线</td><td style="text-align:right">\$1</td><td style="text-align:center">234</td></tr></tbody></table><h3 id="8-更详细语法说明"><a href="#8-更详细语法说明" class="headerlink" title="8. 更详细语法说明"></a>8. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考我们准备的 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown" target="_blank" rel="noopener">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册" target="_blank" rel="noopener">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p><p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p><hr><h2 id="什么是-Cmd-Markdown"><a href="#什么是-Cmd-Markdown" class="headerlink" title="什么是 Cmd Markdown"></a>什么是 Cmd Markdown</h2><p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p><h3 id="1-实时同步预览"><a href="#1-实时同步预览" class="headerlink" title="1. 实时同步预览"></a>1. 实时同步预览</h3><p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p><h3 id="2-编辑工具栏"><a href="#2-编辑工具栏" class="headerlink" title="2. 编辑工具栏"></a>2. 编辑工具栏</h3><p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p><p><img src="https://www.zybuluo.com/static/img/toolbar-editor.png" alt="tool-editor"></p><h3 id="3-编辑模式"><a href="#3-编辑模式" class="headerlink" title="3. 编辑模式"></a>3. 编辑模式</h3><p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右侧的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p><h3 id="4-实时的云端文稿"><a href="#4-实时的云端文稿" class="headerlink" title="4. 实时的云端文稿"></a>4. 实时的云端文稿</h3><p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p><h3 id="5-离线模式"><a href="#5-离线模式" class="headerlink" title="5. 离线模式"></a>5. 离线模式</h3><p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p><h3 id="6-管理工具栏"><a href="#6-管理工具栏" class="headerlink" title="6. 管理工具栏"></a>6. 管理工具栏</h3><p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p><p><img src="https://www.zybuluo.com/static/img/toolbar-manager.jpg" alt="tool-manager"></p><p>通过管理工具栏可以：</p><p><i class="icon-share"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class="icon-file"></i> 新建：开始撰写一篇新的文稿<br><i class="icon-trash"></i> 删除：删除当前的文稿<br><i class="icon-cloud"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class="icon-reorder"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class="icon-pencil"></i> 模式：切换 普通/Vim/Emacs 编辑模式</p><h3 id="7-阅读工具栏"><a href="#7-阅读工具栏" class="headerlink" title="7. 阅读工具栏"></a>7. 阅读工具栏</h3><p><img src="https://www.zybuluo.com/static/img/toolbar-reader.jpg" alt="tool-manager"></p><p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p><p>工具栏上的五个图标依次为：</p><p><i class="icon-list"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class="icon-chevron-sign-left"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class="icon-adjust"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class="icon-desktop"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class="icon-fullscreen"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p><h3 id="8-阅读模式"><a href="#8-阅读模式" class="headerlink" title="8. 阅读模式"></a>8. 阅读模式</h3><p>在 <strong>阅读工具栏</strong> 点击 <i class="icon-desktop"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p><h3 id="9-标签、分类和搜索"><a href="#9-标签、分类和搜索" class="headerlink" title="9. 标签、分类和搜索"></a>9. 标签、分类和搜索</h3><p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p><p>标签： 未分类</p><p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p><p><img src="https://www.zybuluo.com/static/img/file-list.png" alt="file-list"></p><h3 id="10-文稿发布和分享"><a href="#10-文稿发布和分享" class="headerlink" title="10. 文稿发布和分享"></a>10. 文稿发布和分享</h3><p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p><hr><p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class="icon-file"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p><p>作者 <a href="http://weibo.com/ghosert" target="_blank" rel="noopener">@ghosert</a><br>2016 年 07月 07日    </p><p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a> 参考更多使用方法。</p><p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown-语法，参考CMD-Markdown&quot;&gt;&lt;a href=&quot;#Markdown-语法，参考CMD-Markdown&quot; class=&quot;headerlink&quot; title=&quot;Markdown 语法，参考CMD Markdown&quot;&gt;&lt;/a&gt;Markdown
      
    
    </summary>
    
      <category term="blog" scheme="http://yoursite.com/categories/blog/"/>
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 入门</title>
    <link href="http://yoursite.com/2018/07/05/hexo/"/>
    <id>http://yoursite.com/2018/07/05/hexo/</id>
    <published>2018-07-05T12:29:15.000Z</published>
    <updated>2018-07-06T17:30:24.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo的下载和安装"><a href="#hexo的下载和安装" class="headerlink" title="hexo的下载和安装"></a>hexo的下载和安装</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">常用命令：</span><br><span class="line">hexo new post “博客名”  #创建</span><br><span class="line">hexo d -g  #发布</span><br><span class="line">hexo s --debug  #测试界面</span><br><span class="line"></span><br><span class="line">hexo new "postName" #新建文章</span><br><span class="line">hexo new page "pageName" #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br><span class="line"></span><br><span class="line">清除缓存的方法：</span><br><span class="line">- 执行命令：hexo clean</span><br><span class="line">- 然后可以生成静态博客并在本地预览：hexo g &amp; hexo s</span><br></pre></td></tr></table></figure><p>1、利用 npm 命令即可安装。在任意位置点击鼠标右键，选择Git Bash输入命令：npm install -g hexo<br>2、创建文件夹（我的是在E盘创建的Hexo），然后在Hexo文件下，右键运行Git Bash，输入命令：hexo init在_config.yml,进行基础配置</p><p><strong> 部分报错 </strong><br>1.找不到git部署 ERROR Deployer not found: git<br>解决方法<br>    npm install hexo-deployer-git –save<br>3.部署类型设置git<br>hexo 3.0 部署类型不再是github，_config.yml 中修改</p><h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><h2 id="Docs-http-hexo-io-docs-deployment-html"><a href="#Docs-http-hexo-io-docs-deployment-html" class="headerlink" title="Docs: http://hexo.io/docs/deployment.html"></a>Docs: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="noopener">http://hexo.io/docs/deployment.html</a></h2><p>deploy:<br>  type: git<br>  repository: git@<strong><em>.github.com:</em></strong>/***.github.io.git<br>  branch: master</p><ol start="4"><li>xcodebuild<br>xcode-select: error: tool ‘xcodebuild’ requires Xcode, but active developer directory ‘/Library/Developer/CommandLineTools’ is a command line tools instance<br>npm install bcrypt</li><li>RSS不显示<br>安装RSS插件<br>npm install hexo-generator-feed –save<br>开启RSS功能<br>编辑hexo/_config.yml，添加如下代码：</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;hexo的下载和安装&quot;&gt;&lt;a href=&quot;#hexo的下载和安装&quot; class=&quot;headerlink&quot; title=&quot;hexo的下载和安装&quot;&gt;&lt;/a&gt;hexo的下载和安装&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
      <category term="blog" scheme="http://yoursite.com/categories/blog/"/>
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>第一次使用hexo部署博客</title>
    <link href="http://yoursite.com/2018/07/05/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8hexo%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/07/05/第一次使用hexo部署博客/</id>
    <published>2018-07-05T11:48:13.000Z</published>
    <updated>2018-07-06T17:30:50.097Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是第一次使用hexo部署博客，后续将开始自发的写些文章，算是整理下之前一直没有做的事情吧~~~</p></blockquote><p>Mark： 坚持，自律，严于律己</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是第一次使用hexo部署博客，后续将开始自发的写些文章，算是整理下之前一直没有做的事情吧~~~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Mark： 坚持，自律，严于律己&lt;/p&gt;

      
    
    </summary>
    
      <category term="blog" scheme="http://yoursite.com/categories/blog/"/>
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
</feed>
