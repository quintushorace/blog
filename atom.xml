<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浩子</title>
  
  <subtitle>学无止境</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-21T03:02:56.082Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Horace Zhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>各平台离线日志开关</title>
    <link href="http://yoursite.com/2018/07/21/%E5%90%84%E5%B9%B3%E5%8F%B0%E7%A6%BB%E7%BA%BF%E6%97%A5%E5%BF%97%E5%BC%80%E5%85%B3/"/>
    <id>http://yoursite.com/2018/07/21/各平台离线日志开关/</id>
    <published>2018-07-21T02:20:06.000Z</published>
    <updated>2018-07-21T03:02:56.082Z</updated>
    
    <content type="html"><![CDATA[<p>以下是部分手机抓取日志方法</p><h3 id="360手机"><a href="#360手机" class="headerlink" title="360手机"></a>360手机</h3><hr><p>1） 在桌面的【其他应用】文件夹找到【用户反馈】，或通过搜索找到【用户反馈】<br>2 )  点击系统问题反馈<br>3 )  等复现问题，让问题出现2～3次<br>4 )  问题复现之后，直接到文件管理、本地存储，找到根目录下的“log或者mtklog”文件，将文件压缩后发送给工作人员</p><h3 id="MIUI："><a href="#MIUI：" class="headerlink" title="MIUI："></a>MIUI：</h3><hr><p>1） 在拨号键输入 *#*#284#*#* 来抓日志（不包括前后空格），过程可能要 1 分钟左右，成功后通知栏会提示；<br>2）等复现问题<br>3） 日志存放在 MIUI/debug_log 目录里，一个类似 bugreport-0227-14564.zip 的压缩包，将其发给我们</p><h3 id="魅族"><a href="#魅族" class="headerlink" title="魅族"></a>魅族</h3><hr><p>1） 去魅族应用市场下载一个叫“Log Report\ 的软件<br>2） 然后用它抓取LOG<br>3） 等问题复现后将log发给我们</p><h3 id="OPPO"><a href="#OPPO" class="headerlink" title="OPPO"></a>OPPO</h3><hr><p>1）在拨号键盘输入*#800# ，在弹出的界面选择第一项“Oppo Logkit”，再选取第一项“常规log日志信息抓取”，点击最下面一排按钮最左右的“保存log”，返回到上一界面<br>2）选择QXDM log抓取，选择打开Device_Log，运行一段时间后选择关闭Device_Log<br>3）问题出现后在进入“常规log日志信息抓取”点击暂停log，再点击转存log，<br>4）进入文件管理把文件夹OPPOlog里面最新的log和文件夹diag_logs里面的最新文件压缩后发送给相关的工作人员</p><h3 id="vivo"><a href="#vivo" class="headerlink" title="vivo"></a>vivo</h3><hr><p>在拨号键盘输入  *#*#112#*#*   进入bbklog<br>我们机型抓log的方法根据处理器的平台不同方法也不同，分高通处理器平台以及MTK处理器平台<br>mtk开启LOG方法：拔号界面输入*#*#112#*#* —&gt;MTKLogger,点最下方红色小键头,然后点返回键到主菜单，问题出现后，输入：*#*#112#*#*—&gt;MTKLogger，点红色的方框停止，log路径：文件管理根目录下的mtklog文件夹，将整个文件夹压缩后发给相关的工作人员<br>高通平台抓log的步骤：在拨号盘输入*#*#112#*#*即可进入Bbklog界面，ADBLog开关是总开关，开启后退出该界面。然后运行问题出现的软件或者打开问题出现的路径，log路径：文件管理根目录下的bbk_log文件夹，将整个文件夹压缩后发给相关的工作人员</p><h3 id="Nubia-UI："><a href="#Nubia-UI：" class="headerlink" title="Nubia UI："></a>Nubia UI：</h3><hr><p>拨号输入 *#62564#（旧版 ROM 为 *#983564#）进入自带的抓日志工具 Woodpecker</p><ol><li>软件报错、闪退相关问题：<br> a) 开启 MobileLog、NetworkLog 两项，并点击最下方开始箭头按钮<br> b) 退出工具界面，操作手机，使问题复现后，记下时间点，再次进入工具点击停止按钮<br> c) 在 内置存储/nubialog 文件夹里，将刚生成的 log 文件夹压缩，提交给工作人员并告知时间点</li><li>功耗问题：<br> a) 保证手机没有连接电脑、关闭 ModemLog 的情况下，重启手机，然后再开启 MobileLog 、NetworkLog、功耗Log 三项，记下当前电量，并点击最下方开始箭头按钮<br> b) 正常使用手机，观察耗电情况（至少30分钟）；若发现异常，记录时间点、当前电量、使用了什么软件，做了什么操作，并进入 Log 工具点击停止按钮<br> c) 在 内置存储/nubialog 文件夹里，将刚生成的 log 文件夹压缩，提交给工作人员并告知时间点</li></ol><h3 id="三星"><a href="#三星" class="headerlink" title="三星"></a>三星</h3><hr><ol><li>在系统拨号盘输入  *#9900#  进入sys Dump菜单</li><li>Delete dumpstate/logcat</li><li>Set Silent log : On to default</li><li>测试复现问题</li><li>*#9900#进入sys Dump菜单</li><li>Press Run dumpstate/logcat/modem log</li><li>press copy to SDcard(include CP Ramdump)</li><li>然后将内存根目录下的log文件夹压缩后发给工作人员</li></ol><h3 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h3><hr><ol><li>拨号键输入*#\<em>#2846579#\</em>#*，进入工程菜单</li><li>选择后台设置–Log设置-&gt;Log开关</li><li>点击页面最下方中间的播放按钮开始抓log，之后按钮会变成暂停图标，<br>点击后可以停止抓log，一旦选择了start，每次开机，log都会自动打开</li><li>复现问题后，需要先选择stop，这样log能完全保存下来；</li><li>打开LOG，正常使用手机，观察问题是否出现；</li><li>如果问题出现，请记录一下时间点，最好能截个问题现象的截图；在问题出现后过10分钟再停止LOG，确保整个过程的LOG都抓到；<br>（如果长时间不复现，考虑到LOG可能占满手机空间，造成LOG覆盖的情况，请定时清除一下LOG）</li><li>清除LOG方法为：首先将LOG停止；然后点击又下角的*桶图标，进入后选择“clear all”，然后选择确定，则手机存储中的LOG将会被全部清除；之后再打开LOG继续进行抓取；</li><li>停止LOG后将LOG导出压缩发送；<br>Log的保存路径是：手机内部存储或者SD卡存储根目录下会有一个“mtklog”的文件夹；请将此文件夹从手机中拖出后压缩发送给相关工作人员</li></ol><h3 id="联想（含Moto-z-z-play-M-国行）"><a href="#联想（含Moto-z-z-play-M-国行）" class="headerlink" title="联想（含Moto z/z play/M 国行）"></a>联想（含Moto z/z play/M 国行）</h3><hr><h3 id="3333-模式（MTK平台）"><a href="#3333-模式（MTK平台）" class="headerlink" title="####3333#模式（MTK平台）"></a>####3333#模式（MTK平台）</h3><ol><li>打开拨号界面，输入####3333#，打开工程模式</li><li>点击SystemLog后点击右上角设置按钮，进入设置界面，将三个log模式均点上，其他的暂时不要点<br>3.点击返回键，后点击屏幕下方中间的三角按钮，显示等待开始录取log，你会看到时间在动，这个时候退出，再通知栏也可以看到录取模式再运行<br>4.按照之前出现问题的操作方式再次进行操作，直至问题再次出现（即问题复现）<br>5.点击通知栏的log录取按钮，再次进入log录取界面，点击下方中间的方块按钮停止log录制<br>6.找到mtklog这个文件夹，将里面的内容拷出后压缩打包发给工程师<br>7.反馈完毕后为了避免log占用大量内存，按照步骤1进入工程模式后点击右下角的清除按钮（垃圾桶），然后选择需要清除的log，一般选择全部清除即可，然后返回退出即可。</li></ol><h3 id="8888-模式（高通平台）"><a href="#8888-模式（高通平台）" class="headerlink" title="####8888#模式（高通平台）"></a>####8888#模式（高通平台）</h3><ol><li>在拨号界面输入####8888#，进入工程模式</li><li>点选所有日志（或者根据问题类型选择）<br>3.点home键，然后按照之前的操作步骤复现问题<br>4.问题复现后再次按照步骤1进入工程模式点击保存日志<br>5.找到log这个文件夹，把里面的log拷出后打包发给工程师就ok了</li></ol><h3 id="金立"><a href="#金立" class="headerlink" title="金立"></a>金立</h3><hr><h3 id="高通平台"><a href="#高通平台" class="headerlink" title="高通平台"></a>高通平台</h3><ol><li>开机后，进入拨号界面，在拨号界面输入指令*#446633#</li><li>进入金立的log日志选项界面了，看到英文很头疼？放心，很简单的！下面我来介绍。</li><li>默认情况下，最上面两项Mobile Log和Kernel Log是打开的。遇到报错或者为了验证特殊问题时，如果是日常使用场景，不涉及到使用网络（WiFi、数据网络），打开它们就够了。</li><li>如果你反馈的问题与网络连接有关，那么一定要打开后面两项Modem Log和Net Log。（否则你做了无用功，工程师收到无效log也会感到心好累的= =！）modem log开启后会占用一定内存，这一点请注意，传完log记得及时清理，腾出存储空间。</li><li>接着看下面的Log Path选项，这个是log文件存储的位置选项，默认的就是Internal Storage（内置存储），所以这一项我们不用管。</li><li>大家注意到了吗，有一行小字，Start Automatically when Reboot，勾选这个选项后便于开机直接启动log记录器，而不需要每次都进拨号盘输入命令启动，尤其是验证死机重启的问题时它很有用。</li><li>最后也是最重要的一点，打开上面的所有选项后，一定记得点击绿色的“START”按钮。这时就会变成下面的界面了，log记录就开始了，我们就可以按返回键退出这个界面，执行各种操作，从而复现问题了。</li><li>最后的最后，复现了问题步骤以后，记得连接电脑，复制存储目录下的GNLogs文件夹（因机型与平台的不同，有些为diag_logs文件夹），最好压缩后发给工作人员</li></ol><h3 id="MTK平台"><a href="#MTK平台" class="headerlink" title="MTK平台"></a>MTK平台</h3><p>1、到手机的拨号界面，输入*#446633#，会进入工程模式的界面。如下图所示，然后手指向左侧滑动，进入Log and Debugging子项下的MTKLogger选项，点击进入<br>2、 默认界面如下，正常情况下直接开启即可。开启方法就是点击正下方的红色小三角，类似于播放器的图标一样。开启后会有一个等待动画，几秒钟后开始计时，就表明你已经开始记录log了。这时候就可以退出此界面去复现你遇到的问题了。（也就是操作一遍你遇到问题的过程）<br>PS：如果你对于log占用的空间比较在意，并且所反馈的问题确认与网络无关，可以在开启log之前，点击右上角的设置按钮，进入下方右侧图片中的界面，关闭ModemLog。这样记录下来的log体积会大大减少。<br>但如果你的问题跟网络有关（无论数据流量还是WiFi相关），请务必保持ModemLog在开启的状态，否则记录的log是没用的！<br>3、复现问题后，下拉状态栏，进入log抓取界面，然后点击按钮关闭log开关。进入文件管理器，找到mtklog文件夹，压缩后发给工作人员<br>4、 log抓取部分的教程到此就结束了。Log传完以后，手机里的log文件仍然占用着空间，你可以直接在文件管理器删除整个mtklog文件夹进行清理，也可以进入抓log界面，点击右下角的垃圾桶，进入后选择右下角的Clear All，即可完成清理</p><h3 id="一加"><a href="#一加" class="headerlink" title="一加"></a>一加</h3><hr><p>氢OS系统日志抓取步骤：</p><ol><li>打开拨号键盘输入*#800#——点击oneplus logkit；</li><li>勾选“保存log”；</li><li>点击“QXDM log抓取”；</li><li>点击“打开device log”；</li><li>返回操作使BUG复现；</li><li>问题复现后记录问题出现时间，等待几分钟；</li><li>将文件管理中“oem_log”文件夹拷出；</li><li>为了不占用更多手机容量，在LOG已经提取后，可以再次打开“常规log日志信息抓取”与“QXDM log抓取”，关闭log抓取以后点击“删除历史log”。<br>然后把提取的文件压缩后发我就可以了  </li></ol><h3 id="乐视"><a href="#乐视" class="headerlink" title="乐视"></a>乐视</h3><hr><ol><li>打开拨号页面，输入*#*#8888#*#* （或者打开问题反馈app，连续按5次左上角在线反馈后，会自动打开Log抓取设置页面）</li><li>进入抓取页面后，把所有log选项都打开</li><li>点击开始记录离线日志，点击后软件会在回后台运行记录日志</li><li>复现你所发现的bug或问题后，按照上面的方法再次进入Log抓取页，点击停止记录，选择复现了，保存日志。</li><li>保存日志后会自动打开在线反馈页面，请直接点返回键，放弃在线提交。(切记不要点提交!)</li><li>返回桌面，找到文件管理app打开。依次点击：手机储存→logs→ArchivedLogs。这时可以看到抓取的log日志就保存在ArchivedLogs文件夹下</li><li>把抓取的log日志压缩后可以发送给工程师们咯</li></ol><h3 id="酷派"><a href="#酷派" class="headerlink" title="酷派"></a>酷派</h3><hr><h3 id="MTK平台："><a href="#MTK平台：" class="headerlink" title="MTK平台："></a>MTK平台：</h3><p>一、 如何抓取日志？</p><ol><li>进入拨号盘，输入*20121220#进入工程模式，选择【MTK_Engineermode】。</li><li>左划到【Log and Debugging】下并点选【MTKLogger】。</li><li>点击图标抓取日志。<br>日志抓取是可home键挂后台并会在托盘显示日志正在运行提示，下拉托盘点击即可进入日志抓取界面。<br>注意：日志开启后，操作出现异常日志方有效，提供日志时同时提供问题发生时间点，以便定位问题。</li></ol><p>二、如何调整日志输出等级？<br>1、进入工程模式中后，进入日志输出等级，就是下面的截图<br>2、分别将Java log level和Cand C++ log level的日志等级调整为LOGV：<br>3、将Kernel log level的输出等级调整为最后的KERN_DEBUG：<br>三、如何保存日志？</p><ol><li>在日志抓取界面，点击结束图标，停止日志抓取。日志会自动保存到/storage/emulated/0/mtklog目录下。</li><li>进入文件管理器，在/storage/emulated/0/mtklog目录下，将【mdlog】、【mobilelog】、【netlog】三个文件夹一起压缩打包即可。<br>四、如何清除日志文件？</li><li>在日志抓取界面，点击删除图标，选择【CLEAR ALL】清除日志文件。<br>注意：长时间开启日志抓取会占用存储空间，建议及时清除日志文件。</li></ol><h3 id="高通平台："><a href="#高通平台：" class="headerlink" title="高通平台："></a>高通平台：</h3><p>方法如下：<br>1 、从拨号盘输入*20121220#进入到工程模式<br>2 、进入 日志输出等级<br>3、 按照如下的说明设置一下日志级别<br>       java log level 选择 LOGV (即第一项)<br>       c and c++ log level 选择  LOGV (即第一项)<br>       kernel log level 选择 KERN_DEBUG (即最后一项)<br>按照上面的设置之后，返回上一级<br>4、 进入 离线日志设置 进行如下的操作:<br>      (1)取消 离线日志开关  的钩钩,  然后依次点击菜单最后两行是 删除以前所有的日志 和 清除日志缓冲区。<br>      (2)进入 日志缓冲区类型，请勾选除最后一项“Elog日志转储”之外的所有选项，即勾选Main缓冲区，Radio缓 冲区，Events缓冲区，system缓冲区，网络日志转储，内核日志转储，QXDM日志转储。然后按  确定 ，请务必保证  QXDM日志转储  勾选上。<br>     (3)日志转储设为NO<br>     (4)完成上面的操作之后 ，重新将 离线日志开关 勾选上。<br>     (5)重启机器，按照你的操作步骤操作。<br>     (6)从/sdcard/log中把日志压缩发给我们，谢谢！</p><p>使用ADB抓取系统log<br>一、配置环境变量<br>电脑桌面上右击 计算机–&gt;属性–&gt;高级系统配置–&gt;环境变量，在 系统变量 中找到path（没有可以新建一个）。点击path后再变量值的开头加上你的路径“d:adb;”，切记路径最后还要带个分号。点击确定–&gt;确定，如此就完成了环境变量的配置。<br>二、抓log<br>将手机与电脑用数据线相连。<br>打开命令行（开始–&gt;附件–&gt;命令提示符），然后进行一下步骤：</p><ol><li>显示现在连接的手机设备：输入 adb devices  + 回车</li><li>抓log：输入 adb logcat + 回车</li><li>停止抓log：使用ctrl + c</li><li>将log导出：adb logcat &gt; d：1.txt（将log导出到d：/1.txt文件中<br>ADB工具下载地址：<a href="https://yunpan.cn/cWkyshMeDeKDf" target="_blank" rel="noopener">https://yunpan.cn/cWkyshMeDeKDf</a>  访问密码 8a91</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是部分手机抓取日志方法&lt;/p&gt;
&lt;h3 id=&quot;360手机&quot;&gt;&lt;a href=&quot;#360手机&quot; class=&quot;headerlink&quot; title=&quot;360手机&quot;&gt;&lt;/a&gt;360手机&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;1） 在桌面的【其他应用】文件夹找到【用户反馈】，或通过搜索找到
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>开发工具整理(转)</title>
    <link href="http://yoursite.com/2018/07/14/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/14/开发工具整理/</id>
    <published>2018-07-14T09:03:39.000Z</published>
    <updated>2018-07-14T09:21:11.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="辅助开发工具"><a href="#辅助开发工具" class="headerlink" title="辅助开发工具"></a>辅助开发工具</h2><p>转自： <a href="https://github.com/389273716/android-skill-summary" target="_blank" rel="noopener">https://github.com/389273716/android-skill-summary</a></p><ol><li><a href="http://tool.lu/json/" title="Title" target="_blank" rel="noopener">json格式化 - 在线工具</a></li><li><a href="http://www.th7.cn/Program/Android/201501/344556.shtml" title="Title" target="_blank" rel="noopener">android 不透明度16进制值</a></li><li><a href="http://tool.oschina.net/codeformat/json" title="Title" target="_blank" rel="noopener">在线代码格式化</a></li><li><a href="https://docs.bugtags.com/zh/start/integrate/android/manually.html" title="Title" target="_blank" rel="noopener">手动集成 | Bugtags 是移动时代首选 Bug 管理系统，针对不同的使用场景，Bugtags 具有以下强大特性： - 移动时代首选 Bug 管理系统 | 简单·高效·智能·云端管理</a></li><li><a href="https://mockingbot.com/workspace#apps/p88946F55BA1457319844154/templates" title="Title" target="_blank" rel="noopener">墨刀 - 猿理</a></li><li><a href="http://wowubuntu.com/markdown/" title="Title" target="_blank" rel="noopener">Markdown 语法说明(简体中文版)</a></li><li><a href="https://duotai.org/dashboard" title="Title" target="_blank" rel="noopener">多态-vpn</a></li><li><a href="https://github.com/getlantern/lantern" title="Title" target="_blank" rel="noopener">getlantern/lantern: Open Internet for everyone. Lantern is a free application that delivers fast, reliable and secure access to the open Internet for users in censored regions. It uses a variety of techniques to stay unblocked, including domain fronting, p2p, and pluggable transports.</a></li><li><a href="http://blog.csdn.net/forlong401/article/details/45102119" title="Title" target="_blank" rel="noopener">facebook的Android调试工具Stetho介绍 - forlong401的专栏–有问题上：http://www.androidren.com - 博客频道 - CSDN.NET</a></li><li><a href="http://www.jianshu.com/p/62bcbb2a5833" title="Title" target="_blank" rel="noopener">一些浏览器插件，比如同步手机屏幕到pc</a></li><li><a href="https://www.codota.com/" title="Title" target="_blank" rel="noopener">代码搜索</a></li><li><a href="http://ju.outofmemory.cn/entry/22854" title="Title" target="_blank" rel="noopener">使用Fiddler调试手机页面请求 - 为程序员服务</a></li><li><a href="https://searchcode.com/" title="Title" target="_blank" rel="noopener">searchcode搜索代码</a></li><li><a href="https://github.com/kiruto/debug-bottle" title="Title" target="_blank" rel="noopener">debug插件 debug-bottle</a></li><li><a href="http://www.cnplugins.com/" title="Title" target="_blank" rel="noopener">Chrome插件,Chrome商店,谷歌浏览器插件下载 - Chrome插件网</a></li><li><a href="https://github.com/skyhacker2/SQLiteOnWeb-Android" title="Title" target="_blank" rel="noopener">skyhacker2/SQLiteOnWeb-Android: Manage you Sqlite Database in browser</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650237619&amp;idx=1&amp;sn=ccfc790d4e203549b8c9d83d641207fd&amp;chksm=88639bdcbf1412ca91d6ae9b8c3ef9bc1596e956fd04f1d5a1d157d836436ad10483fc7f4817&amp;scene=0#wechat_redirect" title="Title" target="_blank" rel="noopener">利用Jenkins玩转Android自动打包发包</a></li><li><a href="https://github.com/xitu/gold-miner/blob/master/TODO/exploring-firebase-on-android-ios-analytics.md" title="Title" target="_blank" rel="noopener">探索 Firebase 在 Android 和 iOS 的使用: 分析</a></li><li><a href="http://droidyue.com/blog/2014/08/03/great-web-tools-for-android-development/" title="Title" target="_blank" rel="noopener">快速提高Android开发效率的Web工具</a></li><li><a href="http://droidyue.com/blog/2016/05/22/use-checkstyle-for-better-code-style/" title="Title" target="_blank" rel="noopener">Android代码规范利器： Checkstyle</a></li><li><a href="https://gold.xitu.io/entry/57ae98217db2a2005416394d" title="Title" target="_blank" rel="noopener">Android Studio ＋Vim</a></li><li><a href="https://zhuanlan.zhihu.com/p/21250613" title="Title" target="_blank" rel="noopener">一招鲜，吃遍天！这是一篇专供收藏的 Chrome 插件推荐</a></li><li><a href="https://tech.meituan.com/android_custom_lint.html#" title="Title" target="_blank" rel="noopener">Android自定义Lint实践</a></li><li><a href="https://github.com/amitshekhariitbhu/Android-Debug-Database" title="Title" target="_blank" rel="noopener">Android Debug Database数据库debug工具</a></li><li><a href="https://segmentfault.com/p/1210000009108620/read" title="Title" target="_blank" rel="noopener">如何在Windows下像Mac一样优雅开发?</a></li><li><a href="https://zhuanlan.zhihu.com/p/26101114?utm_source=com.ideashower.readitlater.pro&amp;utm_medium=social" title="Title" target="_blank" rel="noopener">告诉你三个我用的高效软件工具</a></li><li><a href="https://juejin.im/entry/58c65e3aa22b9d0058b36be7" title="Title" target="_blank" rel="noopener">震惊！如此多的 Android 开发技巧！</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;辅助开发工具&quot;&gt;&lt;a href=&quot;#辅助开发工具&quot; class=&quot;headerlink&quot; title=&quot;辅助开发工具&quot;&gt;&lt;/a&gt;辅助开发工具&lt;/h2&gt;&lt;p&gt;转自： &lt;a href=&quot;https://github.com/389273716/android-skil
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android debug 神器</title>
    <link href="http://yoursite.com/2018/07/12/Android-debug-%E7%A5%9E%E5%99%A8/"/>
    <id>http://yoursite.com/2018/07/12/Android-debug-神器/</id>
    <published>2018-07-12T06:07:44.000Z</published>
    <updated>2018-07-12T07:09:43.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🍼Debug-Bottle"><a href="#🍼Debug-Bottle" class="headerlink" title="🍼Debug Bottle"></a>🍼Debug Bottle</h1><ul><li><a href="#Http监听">简易的HTTP请求嗅探</a><br>转自 <a href="https://github.com/kiruto/debug-bottle" target="_blank" rel="noopener">https://github.com/kiruto/debug-bottle</a></li></ul><hr><p>Android Java / Kotlin 程序员开发调试工具。Debug Bottle的所有功能均建立在App的debug版本中，不会对release版本产生任何影响。Debug Bottle旨在提高开发效率，把控App质量。</p><ul><li><a href="docs/zh-CN/README.md">开发文档</a></li><li><a href="CHANGELOG.md">CHANGELOG</a></li><li><a href="TODO.md">TODO</a></li></ul><p>Demo App可在Google Play中下载:</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li><a href="#Http监听">简易的HTTP请求嗅探</a></li><li><a href="#3D化视图">3D化Activity视图</a></li><li><a href="#shared-preferences编辑器">Shared Preferences编辑器</a></li><li><a href="#使用strict-mode">使用Strict mode调试软件</a></li><li><a href="#崩溃日志">截获App崩溃，收集崩溃日志</a></li><li><a href="#使用leak-canary">轻松找到可能出现的内存泄漏代码</a></li><li><a href="#使用block-canary">找到可能出现的UI卡顿代码</a></li><li><a href="#进入一切activity并注入参数">简易创造Activity入口，及测试Runnable</a></li></ul><h4 id="Http监听"><a href="#Http监听" class="headerlink" title="Http监听"></a>Http监听</h4><p>通过OkHttp的拦截器监听通过App的Http请求，并记录在Debug Bottle的日志中。记录过的日志可以通过分享按钮分享给其他开发者。</p><h4 id="3D化视图"><a href="#3D化视图" class="headerlink" title="3D化视图"></a>3D化视图</h4><p>通过设置打开“3D”功能，可以更直观地看到当前Activity的layout结构。<br>本功能支持单点手势旋转，双点手势缩放和位移。</p><h4 id="Shared-Preferences编辑器"><a href="#Shared-Preferences编辑器" class="headerlink" title="Shared Preferences编辑器"></a>Shared Preferences编辑器</h4><p>通过Debug Bottle可以简单地编辑App用到的所有Shared Preferences。</p><h4 id="使用Strict-Mode"><a href="#使用Strict-Mode" class="headerlink" title="使用Strict Mode"></a>使用Strict Mode</h4><p>Debug Bottle可以在运行时启用或禁用Strict Mode。StrictMode最常用来捕捉应用程序的主线程，它将报告与线程及虚拟机相关的策略违例。一旦检测到策略违例（policy violation），你将获得警告，其包含了一个栈trace显示你的应用在何处发生违例。除了主线程，我们还可以在Handler，AsyncTask，AsyncQueryHandler，IntentService等API中使用StrictMode。更多使用方法介绍，参见<a href="https://developer.android.com/reference/android/os/StrictMode.html" target="_blank" rel="noopener">官方开发者文档</a>。</p><h4 id="崩溃日志"><a href="#崩溃日志" class="headerlink" title="崩溃日志"></a>崩溃日志</h4><p>收集所有崩溃的信息，存储成日志文件。</p><h4 id="使用Leak-Canary"><a href="#使用Leak-Canary" class="headerlink" title="使用Leak Canary"></a>使用Leak Canary</h4><p>Debug Bottle中编译进了Leak Canary，所有Leak Canary的功能都可以使用了，并且可以通过Debug Bottle来控制开关。Leak Canary的使用方法请参考<a href="https://github.com/square/leakcanary/wiki/FAQ" target="_blank" rel="noopener">官方Wiki</a>。</p><h4 id="使用Block-Canary"><a href="#使用Block-Canary" class="headerlink" title="使用Block Canary"></a>使用Block Canary</h4><p>加入了支持Kotlin的Block Canary，可以监控UI线程卡死。</p><h4 id="进入一切Activity并注入参数"><a href="#进入一切Activity并注入参数" class="headerlink" title="进入一切Activity并注入参数"></a>进入一切Activity并注入参数</h4><p>简单的Activity／Runnable入口。可以随心所欲进入任何一个Activity，使用任何参数，甚至可以向App中注入想要测试的Intent。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>安装嵌入Debug Bottle的App后，你将看到初你App外的新图标🍼。点击进入Debug面板。</p><h2 id="搭建方法"><a href="#搭建方法" class="headerlink" title="搭建方法"></a>搭建方法</h2><h4 id="1-加入Gradle依赖"><a href="#1-加入Gradle依赖" class="headerlink" title="1. 加入Gradle依赖"></a>1. 加入Gradle依赖</h4><p>首先在工程Gradle文件中添加snapshot源：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">"https://oss.sonatype.org/content/repositories/snapshots"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在主模块中（Application类所在模块）加入依赖：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    debugCompile <span class="string">'com.exyui.android:debug-bottle-runtime:1.1.1'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果你的工程是Java工程,使用此依赖</span></span><br><span class="line">    releaseCompile <span class="string">'com.exyui.android:debug-bottle-noop-java:1.1.1'</span></span><br><span class="line">    testCompile <span class="string">'com.exyui.android:debug-bottle-noop-java:1.1.1'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果你的工程是Kotlin工程,使用此依赖</span></span><br><span class="line">    releaseCompile <span class="string">'com.exyui.android:debug-bottle-noop-kotlin:1.1.1'</span></span><br><span class="line">    testCompile <span class="string">'com.exyui.android:debug-bottle-noop-kotlin:1.1.1'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:23.2.0+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Debug Bottle不仅支持API 23+，还可以支持API 22. 若想使用API 22，请按照下面方式加入依赖：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    debugCompile <span class="string">'com.exyui.android:debug-bottle-runtime:1.0.6-support22'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果你的工程是Java工程,使用此依赖</span></span><br><span class="line">    releaseCompile <span class="string">'com.exyui.android:debug-bottle-noop-java:1.0.6-support22'</span></span><br><span class="line">    testCompile <span class="string">'com.exyui.android:debug-bottle-noop-java:1.0.6-support22'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果你的工程是Kotlin工程,使用此依赖</span></span><br><span class="line">    releaseCompile <span class="string">'com.exyui.android:debug-bottle-noop-kotlin:1.0.6-support22'</span></span><br><span class="line">    testCompile <span class="string">'com.exyui.android:debug-bottle-noop-kotlin:1.0.6-support22'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:22+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若只需支持API23，请按照下面方式加入依赖:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    debugCompile <span class="string">'com.exyui.android:debug-bottle-runtime:1.0.6-support23'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果你的工程是Java工程,使用此依赖</span></span><br><span class="line">    releaseCompile <span class="string">'com.exyui.android:debug-bottle-noop-java:1.0.6-support23'</span></span><br><span class="line">    testCompile <span class="string">'com.exyui.android:debug-bottle-noop-java:1.0.6-support23'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果你的工程是Kotlin工程,使用此依赖</span></span><br><span class="line">    releaseCompile <span class="string">'com.exyui.android:debug-bottle-noop-kotlin:1.0.6-support23'</span></span><br><span class="line">    testCompile <span class="string">'com.exyui.android:debug-bottle-noop-kotlin:1.0.6-support23'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:23+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-编辑Manifest"><a href="#2-编辑Manifest" class="headerlink" title="2. 编辑Manifest"></a>2. 编辑Manifest</h4><p>加入Debug Bottle的主Activity：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.exyui.android.debugbottle.components.DTDrawerActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@style/Theme.AppCompat.Light"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"调试工具"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>“调试工具”是Debug Bottle在Android launch pad中显示的名称, 可以随意命名。</p><h4 id="3-在Application中插入Debug-Bottle代码"><a href="#3-在Application中插入Debug-Bottle代码" class="headerlink" title="3. 在Application中插入Debug Bottle代码"></a>3. 在Application中插入Debug Bottle代码</h4><p>首先实现Block Canary运行必要的上下文类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppBlockCanaryContext</span> <span class="keyword">extends</span> <span class="title">BlockCanaryContext</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p><p>然后在Application的onCreate中插入代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        DTInstaller.install(<span class="keyword">this</span>)</span><br><span class="line">            .setBlockCanary(<span class="keyword">new</span> AppBlockCanaryContext(<span class="keyword">this</span>))</span><br><span class="line">            .setOkHttpClient(httpClient)</span><br><span class="line">            .setInjector(<span class="string">"your.package.injector.ContentInjector"</span>)</span><br><span class="line">            .setPackageName(<span class="string">"your.package"</span>)</span><br><span class="line">            .enable()</span><br><span class="line">            .run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者如果你的工程是Kotlin,你还可以这样写:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span>: <span class="type">Application</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        DTInstaller.install(<span class="keyword">this</span>)</span><br><span class="line">            .setBlockCanary(AppBlockCanaryContext(<span class="keyword">this</span>))</span><br><span class="line">            .setOkHttpClient(httpClient)</span><br><span class="line">            .setInjector(<span class="string">"your.package.injector.ContentInjector"</span>)</span><br><span class="line">            .setPackageName(<span class="string">"your.package"</span>)</span><br><span class="line">            .enable()</span><br><span class="line">            .run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>收工。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">Leak Canary</a></li><li><a href="https://github.com/markzhai/AndroidPerformanceMonitor" target="_blank" rel="noopener">Android Performance Monitor</a></li><li><a href="https://github.com/JakeWharton/scalpel" target="_blank" rel="noopener">Scalpel</a></li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Debug Bottle</span><br><span class="line"></span><br><span class="line">Copyright 2016 Yuriel (http://exyui.com).</span><br><span class="line"></span><br><span class="line">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line">you may not use this file except in compliance with the License.</span><br><span class="line">You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">   http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">Unless required by applicable law or agreed to in writing, software</span><br><span class="line">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">See the License for the specific language governing permissions and</span><br><span class="line">limitations under the License.</span><br></pre></td></tr></table></figure><p>Debug Bottle 功能实现是基于以下项目的派生:</p><ul><li>Apache License 2.0<ul><li><a href="https://raw.githubusercontent.com/markzhai/AndroidPerformanceMonitor/master/LICENSE" target="_blank" rel="noopener">Android Performance Monitor</a></li><li><a href="https://raw.githubusercontent.com/square/leakcanary/master/LICENSE.txt" target="_blank" rel="noopener">Leak Canary</a></li><li><a href="https://raw.githubusercontent.com/JakeWharton/scalpel/master/LICENSE.txt" target="_blank" rel="noopener">Scalpel</a></li><li><a href="https://raw.githubusercontent.com/txusballesteros/bubbles-for-android/master/LICENSE" target="_blank" rel="noopener">Bubbles for Android</a></li><li><a href="https://raw.githubusercontent.com/wasabeef/Takt/master/LICENSE" target="_blank" rel="noopener">Takt</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;🍼Debug-Bottle&quot;&gt;&lt;a href=&quot;#🍼Debug-Bottle&quot; class=&quot;headerlink&quot; title=&quot;🍼Debug Bottle&quot;&gt;&lt;/a&gt;🍼Debug Bottle&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#Http监听
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 反射机制</title>
    <link href="http://yoursite.com/2018/07/11/Java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/07/11/Java-反射机制/</id>
    <published>2018-07-11T08:22:04.000Z</published>
    <updated>2018-07-11T08:22:24.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第-16-章-反射（Reflection）"><a href="#第-16-章-反射（Reflection）" class="headerlink" title="第 16 章 反射（Reflection）"></a>第 16 章 反射（Reflection）</h1><p>2016-09-29 转自：<a href="https://github.com/JustinSDK/JavaSE6Tutorial/blob/master/docs/CH16.md" target="_blank" rel="noopener">https://github.com/JustinSDK/JavaSE6Tutorial/blob/master/docs/CH16.md</a></p><p>Java 提供的反射机制允许您于执行时期动态加载类别、检视类别信息、生成对象或操作生成的对象，要举反射机制的一个应用实例，就是在集成开发环境中所提供的方法提示或是类别检视工具，另外像 JSP 中的 JavaBean 自动收集请求信息也使用到反射，而一些软件开发框架（Framework）也常见到反射机制的使用，以达到动态加载用户自定义类别的目的。</p><p>即使您暂时用不到反射机制，也建议您花时间看看这个章节，藉由对反射机制的认识，您可以了解 Java 中是如何加载类别的，而且了解到每个被载入的类别在 JVM 中，都以 Class 类别的一个实例存在的事实。</p><hr><h2 id="16-1-类别载入与检视"><a href="#16-1-类别载入与检视" class="headerlink" title="16.1 类别载入与检视"></a>16.1 类别载入与检视</h2><p>即使您拿到一个类别并对它一无所知，但其实它本身就包括了许多信息，Java 在需要使用到某个类别时才会将类别加载，并在 JVM 中以一个 java.lang.Class 的实例存在，从 Class 实例开始，您可以获得类别的许多讯息。</p><h3 id="16-1-1-简介-Class-与类别载入"><a href="#16-1-1-简介-Class-与类别载入" class="headerlink" title="16.1.1 简介 Class 与类别载入"></a>16.1.1 简介 Class 与类别载入</h3><p>Java 在真正需要使用一个类别时才会加以加载，而不是在程序启动时就加载所有的类别，因为大多数的使用者都只使用到应用程序的部份资源，在需要某些功能时才加载某些资源，可以让系统的资源运用更有效率（Java 本来就是为了资源有限的小型设备而设计的，这样的考虑是必然的）。</p><p>一个 java.lang.Class 对象代表了 Java 应用程序在运行时所加载的类别或接口实例，也用来表达 enum（属于类别的一种）、 annotation（属于接口的一种）、数组、原生型态（Primitive type）、void；Class 类别没有公开的（public）建构方法，Class 对象是由 JVM 自动产生，每当一个类别被加载时，JVM 就自动为其生成一个 Class 对象。</p><p>您可以透过 Object 的 getClass() 方法来取得每一个对象对应的 Class 对象，或者是透过 “class” 常量（Class literal），在取得 Class 对象之后，您就可以操作 Class 对象上的一些公开方法来取得类别的基本信息，范例 16.1 简单的使用 getClass() 方法来取得 String 类别的 Class 实例，并从中得到 String 的一些基本信息。</p><h4 id="范例-16-1-ClassDemo-java"><a href="#范例-16-1-ClassDemo-java" class="headerlink" title="范例 16.1  ClassDemo.java"></a><strong>范例 16.1  ClassDemo.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">"caterpillar"</span>;</span><br><span class="line">        Class stringClass = name.getClass();</span><br><span class="line">        System.out.println(<span class="string">"类别名称："</span> +</span><br><span class="line">                    stringClass.getName());</span><br><span class="line">        System.out.println(<span class="string">"是否为接口："</span> +</span><br><span class="line">                    stringClass.isInterface());</span><br><span class="line">        System.out.println(<span class="string">"是否为基本型态："</span> +</span><br><span class="line">                    stringClass.isPrimitive());</span><br><span class="line">        System.out.println(<span class="string">"是否为数组对象："</span> +</span><br><span class="line">                    stringClass.isArray());</span><br><span class="line">        System.out.println(<span class="string">"父类别名称："</span> +</span><br><span class="line">                    stringClass.getSuperclass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><pre><code>类别名称：java.lang.String是否为接口：false是否为基本型态：false是否为数组对象：false父类别名称：java.lang.Object</code></pre><p>您也可以直接使用以下的方式来取得 String 类别的 Class 对象：</p><pre><code>Class stringClass = String.class;</code></pre><p>Java 在真正需要类别时才会加载类别，所谓「真正需要」通常指的是要使用指定的类别生成对象时（或是用户指定要加载类别时，例如使用 Class.forName() 加载类别，或是使用 ClassLoader 的 loadClass() 加载类别，稍后都会说明）。使用类别名称来宣告参考名称并不会导致类别的加载，可以设计一个测试类别的印证这个说法。</p><h4 id="范例-16-2-TestClass-java"><a href="#范例-16-2-TestClass-java" class="headerlink" title="范例 16.2  TestClass.java"></a><strong>范例 16.2  TestClass.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"类别被载入"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在范例中定义了一个静态区块，「默认」在类别第一次被加载时会执行静态区块（说默认的原因，是因为可以设定加载类别时不执行静态区块，使用 Class 生成对象时才执行静态区块，稍后会介绍），藉由在文本模式下显示讯息，您可以了解类别何时被加载，可以使用范例 16.3 来测试类别加载时机。</p><h4 id="范例-16-3-LoadClassTest-java"><a href="#范例-16-3-LoadClassTest-java" class="headerlink" title="范例 16.3  LoadClassTest.java"></a><strong>范例 16.3  LoadClassTest.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestClass test = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"宣告TestClass参考名称"</span>);</span><br><span class="line">        test = <span class="keyword">new</span> TestClass();</span><br><span class="line">        System.out.println(<span class="string">"生成TestClass实例"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><pre><code>宣告TestClass参考名称类别被载入生成TestClass实例</code></pre><p>从执行结果中可以看出，宣告参考名称并不导致 TestClass 类别被加载，而是在使用 “new” 生成对象时才会加载类别。</p><p>Class 的讯息是在编译时期就被加入至 .class 档案中，这是 Java 支持执行时期型别辨识（RTTI，Run-Time Type Information或Run-Time Type Identification）的一种方式，在编译时期编译程序会先检查对应的 .class 档案，而执行时期JVM在使用某类别时，会先检查对应的 Class 对象是否已经加载，如果没有加载，则会寻找对应的 .class 档案并载入，一个类别在 JVM 中只会有一个 Class 实例，每个类别的实例都会记得自己是由哪个 Class 实例所生成，您可以使用 getClass() 或 .class 来取得 Class 实例。</p><p><img src="../images/img16-01.png" alt="每个对象会记得生成它的 Class 实例"></p><p>图 16.1 每个对象会记得生成它的 Class 实例</p><p>在 Java 中，数组也是一个对象，也有其对应的 Class 实例，这个对象是由具相同元素与维度的数组所共享，而基本型态像是 boolean, byte, char, short, int, long, float, double 以及关键词 void，也都有对应的 Class 对象，您可以用类别常量（Class literal）来取得这些对象。</p><h4 id="范例-16-4-ClassDemo2-java"><a href="#范例-16-4-ClassDemo2-java" class="headerlink" title="范例 16.4  ClassDemo2.java"></a><strong>范例 16.4  ClassDemo2.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">boolean</span>.class);</span><br><span class="line">        System.out.println(<span class="keyword">void</span>.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] iarr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        System.out.println(iarr.getClass().toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[] darr = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">10</span>];</span><br><span class="line">        System.out.println(darr.getClass().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><pre><code>booleanvoidclass [Iclass [D</code></pre><p>在 Java 中数组确实是以对象的形式存在，其对应的类别是由 JVM 自动生成，当您使用 toString() 来显示数组对象的描述时，[表示为数组型态，并加上一个型态代表字，范例中I表示是一个 int 数组，而 D 表示是一个 double 数组，16.2.4 还会对数组对象加以讨论。</p><h3 id="16-1-2-使用-Class-forName-载入类别"><a href="#16-1-2-使用-Class-forName-载入类别" class="headerlink" title="16.1.2 使用 Class.forName() 载入类别"></a>16.1.2 使用 Class.forName() 载入类别</h3><p>在一些应用中，您无法事先知道使用者将加载什么类别，而必须让使用者指定类别名称以加载类别，您可以使用 Class 的静态 forName() 方法实现动态加载类别，范例 16.5 是个简单示范，可以让您可以指定类别名称来获得类别的相关信息。</p><h4 id="范例-16-5-ForNameDemo-java"><a href="#范例-16-5-ForNameDemo-java" class="headerlink" title="范例 16.5  ForNameDemo.java"></a><strong>范例 16.5  ForNameDemo.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForNameDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">            System.out.println(<span class="string">"类别名称："</span> +</span><br><span class="line">                          c.getName());</span><br><span class="line">            System.out.println(<span class="string">"是否为接口："</span> +</span><br><span class="line">                             c.isInterface());</span><br><span class="line">            System.out.println(<span class="string">"是否为基本型态："</span> +</span><br><span class="line">                             c.isPrimitive());</span><br><span class="line">            System.out.println(<span class="string">"是否为数组："</span> + c.isArray());</span><br><span class="line">            System.out.println(<span class="string">"父类别："</span> +</span><br><span class="line">                             c.getSuperclass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有指定类别名称"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到指定的类别"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在指定类别给 forName() 方法后，如果找不到指定的类别，会丢出 ClassNotFoundException 例外，一个的执行结果如下：</p><pre><code>java onlyfun.caterpillar.ForNameDemo java.util.Scanner类别名称：java.util.Scanner是否为接口：false是否为基本型态：false是否为数组：false父类别：java.lang.Object</code></pre><p>Class 的静态 forName() 方法有两个版本，范例16.5所示范的是只指定类别名称的版本，而另一个版本可以让您指定类别名称、加载类别时是否执行静态区块、指定类别加载器（Class loader）：</p><pre><code>static Class forName(String name, boolean initialize, ClassLoader loader)</code></pre><p>之前曾经说过，预设上在加载类别的时候，如果类别中有定义静态区块则会执行它，您可以使用 forName() 的第二个版本，将 initialize 设定为 false，如此在加载类别时并不会马上执行静态区块，而会在使用类别建立对象时才执行静态区块，为了印证，您可以先设计一个测试类别。</p><h4 id="范例-16-6-TestClass2-java"><a href="#范例-16-6-TestClass2-java" class="headerlink" title="范例 16.6  TestClass2.java"></a><strong>范例 16.6  TestClass2.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"[执行静态区块]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>范例 16.6 中只定义了静态区块显示一段讯息，以观察静态区块何时被执行，您可以设计范例 16.7 使用第一个版本的 forName() 方法。</p><h4 id="范例-16-7-ForNameDemoV1-java"><a href="#范例-16-7-ForNameDemoV1-java" class="headerlink" title="范例 16.7  ForNameDemoV1.java"></a><strong>范例 16.7  ForNameDemoV1.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForNameDemoV1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"载入TestClass2"</span>);</span><br><span class="line">            Class c = Class.forName(<span class="string">"onlyfun.caterpillar.TestClass2"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"使用TestClass2宣告参考名称"</span>);</span><br><span class="line">            TestClass2 test = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"使用TestClass2建立对象"</span>);                        </span><br><span class="line">            test = <span class="keyword">new</span> TestClass2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到指定的类别"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><pre><code>载入TestClass2[执行静态区块]使用TestClass2宣告参考名称使用TestClass2建立对象</code></pre><p>从执行结果中可以看到，第一个版本的 forName() 方法在加载类别之后，默认会马上执行静态区块，来看看范例 16.8 中使用第二个版本的 forName() 方法会是如何。</p><h4 id="范例-16-8-ForNameDemoV2-java"><a href="#范例-16-8-ForNameDemoV2-java" class="headerlink" title="范例 16.8  ForNameDemoV2.java"></a><strong>范例 16.8  ForNameDemoV2.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForNameDemoV2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"载入TestClass2"</span>);</span><br><span class="line">            Class c = Class.forName(</span><br><span class="line">                         <span class="string">"onlyfun.caterpillar.TestClass2"</span>,</span><br><span class="line">                         <span class="keyword">false</span>, <span class="comment">// 加载类别时不执行静态方法</span></span><br><span class="line">                         Thread.currentThread().getContextClassLoader());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"使用TestClass2宣告参考名称"</span>);</span><br><span class="line">            TestClass2 test = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"使用TestClass2建立对象"</span>);                        </span><br><span class="line">            test = <span class="keyword">new</span> TestClass2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到指定的类别"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><pre><code>载入TestClass2使用TestClass2宣告参考名称使用TestClass2建立对象[执行静态区块]</code></pre><p>由于使用第二个版本的 forName() 方法时，设定 initialize 为 false，所以加载类别时并不会马上执行静态区块，而会在使用类别建立对象时才去执行静态区块，第二个版本的 forName() 方法会需要一个类别加载器（Class loader），范例中所使用的是主线程的类别加载器，16.1.4 还会详细介绍 Java 中的类别加载器机制。</p><h3 id="16-1-3-从-Class-中获取信息"><a href="#16-1-3-从-Class-中获取信息" class="headerlink" title="16.1.3 从 Class 中获取信息"></a>16.1.3 从 Class 中获取信息</h3><p>Class 对象表示所加载的类别，取得 Class 对象之后，您就可以取得与类别相关联的信息，像是套件（package）（别忘了 package 也是类别名称的一部份）、建构方法、方法成员、数据成员等的讯息，而每一个讯息，也会有相应的类别型态，例如套件的对应型态是 java.lang.Package，建构方法的对应型态是 java.lang.reflect.Constructor，方法成员的对应型态是 java.lang.reflect.Method，数据成员的对应型态是 java.lang.reflect.Field 等。</p><p>来看个简单的示范，范例 16.9 可以让您取得所指定类别上的套件名称。</p><h4 id="范例-16-9-ClassInfoDemo-java"><a href="#范例-16-9-ClassInfoDemo-java" class="headerlink" title="范例 16.9  ClassInfoDemo.java"></a><strong>范例 16.9  ClassInfoDemo.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInfoDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">            Package p = c.getPackage();</span><br><span class="line">            System.out.println(p.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有指定类别"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到指定类别"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><pre><code>java onlyfun.caterpillar.ClassInfoDemo java.util.ArrayListjava.util</code></pre><p>您可以分别取回 Field、Constructor、Method等对象，分别代表数据成员、建构方法与方法成员，范例16.10 简单的实作了取得类别基本信息的程序。</p><h4 id="范例-16-10-SimpleClassViewer-java"><a href="#范例-16-10-SimpleClassViewer-java" class="headerlink" title="范例 16.10  SimpleClassViewer.java"></a><strong>范例 16.10  SimpleClassViewer.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClassViewer</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 取得套件代表对象</span></span><br><span class="line">            Package p = c.getPackage();</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">"package %s;%n"</span>, p.getName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取得型态修饰，像是class、interface</span></span><br><span class="line">            <span class="keyword">int</span> m = c.getModifiers();</span><br><span class="line"></span><br><span class="line">            System.out.print(Modifier.toString(m) + <span class="string">" "</span>);</span><br><span class="line">            <span class="comment">// 如果是接口</span></span><br><span class="line">            <span class="keyword">if</span>(Modifier.isInterface(m)) &#123;</span><br><span class="line">                System.out.print(<span class="string">"interface "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">"class "</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(c.getName() + <span class="string">" &#123;"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取得宣告的数据成员代表对象</span></span><br><span class="line">            Field[] fields = c.getDeclaredFields();</span><br><span class="line">            <span class="keyword">for</span>(Field field : fields) &#123;</span><br><span class="line">                <span class="comment">// 显示权限修饰，像是public、protected、private</span></span><br><span class="line">                System.out.print(<span class="string">"\t"</span> +</span><br><span class="line">                    Modifier.toString(field.getModifiers()));</span><br><span class="line">                <span class="comment">// 显示型态名称</span></span><br><span class="line">                System.out.print(<span class="string">" "</span> +</span><br><span class="line">                    field.getType().getName() + <span class="string">" "</span>);</span><br><span class="line">                <span class="comment">// 显示数据成员名称</span></span><br><span class="line">                System.out.println(field.getName() + <span class="string">";"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取得宣告的建构方法代表对象            </span></span><br><span class="line">            Constructor[] constructors =</span><br><span class="line">                            c.getDeclaredConstructors();</span><br><span class="line">            <span class="keyword">for</span>(Constructor constructor : constructors) &#123;</span><br><span class="line">                <span class="comment">// 显示权限修饰，像是public、protected、private</span></span><br><span class="line">                System.out.print(<span class="string">"\t"</span> +</span><br><span class="line">                     Modifier.toString(</span><br><span class="line">                       constructor.getModifiers()));</span><br><span class="line">                <span class="comment">// 显示建构方法名称</span></span><br><span class="line">                System.out.println(<span class="string">" "</span> +</span><br><span class="line">                      constructor.getName() + <span class="string">"();"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 取得宣告的方法成员代表对象             </span></span><br><span class="line">            Method[] methods = c.getDeclaredMethods();</span><br><span class="line">            <span class="keyword">for</span>(Method method : methods) &#123;</span><br><span class="line">                <span class="comment">// 显示权限修饰，像是public、protected、private</span></span><br><span class="line">                System.out.print(<span class="string">"\t"</span> +</span><br><span class="line">                     Modifier.toString(</span><br><span class="line">                              method.getModifiers()));</span><br><span class="line">                <span class="comment">// 显示返回值型态名称</span></span><br><span class="line">                System.out.print(<span class="string">" "</span> +</span><br><span class="line">                     method.getReturnType().getName() + <span class="string">" "</span>);</span><br><span class="line">                <span class="comment">// 显示方法名称</span></span><br><span class="line">                System.out.println(method.getName() + <span class="string">"();"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"&#125;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有指定类别"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到指定类别"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><pre><code>package java.util;public class java.util.ArrayList {        private static final long serialVersionUID;        private transient [Ljava.lang.Object; elementData;        private int size;        public java.util.ArrayList();        public java.util.ArrayList();        public java.util.ArrayList();        public boolean add();        public void add();        public java.lang.Object clone();        public void clear();        public boolean contains();        public int indexOf();        略...}</code></pre><p>一些类别查看器的实作原理基本上就是范例 16.10 所示范的，当然还可以取得更多的信息，您可以参考 Class 的在线 API 文件得到更多的讯息。</p><h3 id="16-1-4-简介类别加载器"><a href="#16-1-4-简介类别加载器" class="headerlink" title="16.1.4 简介类别加载器"></a>16.1.4 简介类别加载器</h3><p>Java 在需要使用类别的时候，才会将类别加载，Java 的类别载入是由类别加载器（Class loader）来达到的。</p><p>当您在文本模式下执行 java XXX 指令后，java 执行程序会尝试找到 JRE 安装的所在目录，然后寻找 jvm.dll（默认是在JRE目录下bin\client目录中），接着启动 JVM 并进行初始化动作，接着产生 Bootstrap Loader，Bootstrap Loader 会加载 Extended Loader，并设定 Extended Loader 的 parent 为 Bootstrap Loader，接着 Bootstrap Loader 会加载 System Loader，并将 System Loader 的 parent 设定为 Extended Loader。</p><p>Bootstrap Loader 通常由 C 撰写而成；Extended Loader 是由 Java 所撰写而成，实际是对应于 sun.misc.Launcher\$ExtClassLoader（Launcher 中的内部类别）；System Loader 是由 Java 撰写而成，实际对应于sun.misc. Launcher\$AppClassLoader（Launcher 中的内部类别）。</p><p>图 16.2 是 java 程序启动与加载类别的顺序图，也就是所谓的「类别加载器阶层架构」。</p><p><img src="../images/img16-02.png" alt="Java 类别加载器阶层架构"></p><p>图 16.2 Java 类别加载器阶层架构</p><p>Bootstrap Loader 会搜寻系统参数 sun.boot.class.path 中指定位置的类别，默认是 JRE  classes 下之  档案，或 lib 目录下 .jar 档案中（例如 rt.jar）的类别并加载，您可以使用 System.getProperty(“sun.boot.class.path”) 陈述来显示 sun.boot.class.path 中指定的路径，例如在我的计算机中显示的是以下的路径：</p><pre><code>C:\Program Files\Java\jre1.5.0_03\lib\rt.jar;C:\Program Files\Java\jre1.5.0_03\lib\i18n.jar;C:\Program Files\Java\jre1.5.0_03\lib\sunrsasign.jar;C:\Program Files\Java\jre1.5.0_03\lib\jsse.jar;C:\Program Files\Java\jre1.5.0_03\lib\jce.jar;C:\Program Files\Java\jre1.5.0_03\lib\charsets.jar;C:\Program Files\Java\jre1.5.0_03\classes</code></pre><p>Extended Loader（sun.misc.Launcher$ExtClassLoader）是由 Java 撰写而成，会搜寻系统参数 java.ext.dirs 中指定位置的类别，默认是 JRE 目录下的 lib\ext\classes 目录下的 .class 档案，或 lib\ext 目录下的 .jar 档案中（例如 rt.jar）的类别并加载，您可以使用 System.getProperty(“java.ext.dirs”) 陈述来显示  中指定的路径，例如在我的计算机中显示的是以下的路径：</p><pre><code>C:\Program Files\Java\jre1.5.0_03\lib\ext</code></pre><p>System Loader（sun.misc.Launcher$AppClassLoader）是由 Java 撰写而成，会搜寻系统参数 java.class.path 中指定位置的类别，也就是 Classpath 所指定的路径，默认是目前工作路径下的 .class 档案，您可以使用 System.getProperty(“java.class.path”) 陈述来显示 java.class.path 中指定的路径，在使用 java 执行程序时，您也可以加上 -cp 来覆盖原有的 Classpath 设定，例如：</p><pre><code>java –cp ./classes SomeClass</code></pre><p>Bootstrap Loader 会在 JVM 启动之后产生，之后它会加载 Extended Loader 并将其 parent 设为 Bootstrap Loader，然后 Bootstrap Loader 再加载 System Loader 并将其 parent 设定为 ExtClassLoader，接着 System Loader 开始加载您指定的类别，在加载类别时，每个类别加载器会先将加载类别的任务交由其 parent，如果 parent 找不到，才由自己负责加载，所以在加载类别时，会以 Bootstrap Loader→Extended Loader→System Loader 的顺序来寻找类别，如果都找不到，就会丢出 NoClassDefFoundError。</p><p>类别加载器在 Java 中是以 java.lang.ClassLoader 型态存在，每一个类别被载入后，都会有一个 Class 的实例来代表，而每个 Class 的实例都会记得自己是由哪个 ClassLoader 加载的，可以由 Class 的 getClassLoader() 取得加载该类别的 ClassLoader，而从 ClassLoader 的 getParent() 方法可以取得自己的 parent，图 16.3 显示了一个自定义的 SomeClass 实例与 Class、ClassLoader 及各 parent 的关系。</p><p><img src="../images/img16-03.png" alt="对象、Class、ClassLoader 与 parent 的关系"></p><p>图 16.3 对象、Class、ClassLoader 与 parent 的关系</p><p>范例 16.11 示范了图 16.3 的一个实际例子。</p><h4 id="范例-16-11-SomeClass-java"><a href="#范例-16-11-SomeClass-java" class="headerlink" title="范例 16.11  SomeClass.java"></a><strong>范例 16.11  SomeClass.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 建立SomeClass实例</span></span><br><span class="line">        SomeClass some = <span class="keyword">new</span> SomeClass();</span><br><span class="line">        <span class="comment">// 取得SomeClass的Class实例</span></span><br><span class="line">        Class c = some.getClass();</span><br><span class="line">        <span class="comment">// 取得ClassLoader</span></span><br><span class="line">        ClassLoader loader = c.getClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        <span class="comment">// 取得父ClassLoader</span></span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">        <span class="comment">// 再取得父ClassLoader</span></span><br><span class="line">        System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><pre><code>sun.misc.Launcher$AppClassLoader@82ba41sun.misc.Launcher$ExtClassLoader@923e30null</code></pre><p>onlyfun.caterpillar.SomeClass 是个自定义类别，您在目前的工作目录下执行程序，首先 AppClassLoader 会将加载类别的任务交给 ExtClassLoader，而 ExtClassLoader 会将加载类别的任务交给 Bootstrap Loader，由于 Bootstrap Loader 在它的路径设定（sun.boot.class.path）下找不到类别，所以由 ExtClassLoader 来试着寻找，而 ExtClassLoader 在它的路径设定（java.ext.dirs）下也找不到类别，所以由 AppClassLoader 来试着寻找，AppClassLoader 最后在 Classpath（java.class.path）设定下找到指定的类别并加载。</p><p>在执行结果中可以看到，加载 SomeClass 的 ClassLoader 是 AppClassLoader，而 AppClassLoader 的 parent 是 ExtClassLoader，而 ExtClassLoader 的 parent 是 null，null 并不是表示 ExtClassLoader 没有设定 parent，而是因为 Bootstrap Loader 通常由 C 所撰写而成，在 Java 中并没有一个实际的类别来表示它，所以才会显示为 null。</p><p>如果把 SomeClass 的 .class 档案移至 JRE 目录下的 lib\ext\classes下（由于设定了套件，所以实际上 SomeClass.class 要放置在 JRE 目录下的 lib\ext\classes\onlyfun\caterpillar下），并重新（于任何目录下）执行程序，您会看到以下的讯息：</p><pre><code>sun.misc.Launcher$ExtClassLoader@923e30nullException in thread &quot;main&quot; java.lang.NullPointerException        at onlyfun.caterpillar.SomeClass.main(SomeClass.java:15)</code></pre><p>由于 SomeClass 这次可以在 ExtClassLoader 的设定路径下找到，所以会由 ExtClassLoader 来加载 SomeClass 类别，而 ExtClassLoader 的 parent 显示为 null，指的是它的 parent 是由 C 撰写而成的 Bootstrap Loader，因为没有实际的 Java 类别而表示为 null，所以再由 null 上尝试呼叫 getParent() 方法就会丢出 NullPointerException 例外。</p><p>如果再把 SomeClass 的 .class 档案移至 JRE 目录下的 classes 目录下（由于设定了套件，所以实际上 SomeClass.class 要放置在 JRE 目录下的 classes/onlyfun/caterpillar下），并重新（于任何目录下）执行程序，您会看到以下的讯息：</p><pre><code>nullException in thread &quot;main&quot; java.lang.NullPointerException        at onlyfun.caterpillar.SomeClass.main(SomeClass.java:13)</code></pre><p>由于 SomeClass 这次可以在 Bootstrap Loader 的设定路径下找到，所以会由 Bootstrap Loader 来加载 SomeClass 类别，Bootstrap Loader 通常由 C 撰写而成，在 Java 中没有一个实际的类别来表示，所以显示为 null，因为表示为 null，所以再 由 null 上尝试呼叫 getParent() 方法就会丢出 NullPointerException 例外。</p><p>取得 ClassLoader 的实例之后，您可以使用它的 loadClass() 方法来加载类别，使用 loadClass() 方法加载别时，不会执行静态区块，静态区块的执行会等到真正使用类别来建立实例时，例如您可以改写范例 16.7 为范例 16.12。</p><h4 id="范例-16-12-ForNameDemoV3-java"><a href="#范例-16-12-ForNameDemoV3-java" class="headerlink" title="范例 16.12  ForNameDemoV3.java"></a><strong>范例 16.12  ForNameDemoV3.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForNameDemoV3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"载入TestClass2"</span>);</span><br><span class="line">            ClassLoader loader = ForNameDemoV3.class.getClassLoader();</span><br><span class="line">            Class c = loader.loadClass(<span class="string">"onlyfun.caterpillar.TestClass2"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"使用TestClass2宣告参考名称"</span>);</span><br><span class="line">            TestClass2 test = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"使用TestClass2建立对象"</span>);</span><br><span class="line">            test = <span class="keyword">new</span> TestClass2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到指定的类别"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从执行结果中可以看到，loadClass() 不会在加载类别时执行静态区块，而会在使用类别新建对象时才执行静态区块，结果如下所示：</p><pre><code>载入TestClass2使用TestClass2宣告参考名称使用TestClass2建立对象[执行静态区块]</code></pre><h3 id="16-1-5-使用自己的-ClassLoader"><a href="#16-1-5-使用自己的-ClassLoader" class="headerlink" title="16.1.5 使用自己的 ClassLoader"></a>16.1.5 使用自己的 ClassLoader</h3><p>ExtClassLoader 与 AppClassLoader 都是 java.net.URLClassLoader 的子类别，您可以在使用 java 启动程序时，使用以下的指令来指定 ExtClassLoader 的搜寻路径：</p><pre><code>java -Djava.ext.dirs=c:\workspace\ YourClass</code></pre><p>可以在使用 java 启动程序时，使用 -classpath 或 -cp 来指定 AppClassLoader 的搜寻路径，也就是设定 Classpath：</p><pre><code>java -classpath c:\workspace\ YourClass</code></pre><p>ExtClassLoader 与 AppClassLoader 在程序启动后会在虚拟机中存在一份，您在程序运行过程中就无法再改变它的搜寻路径，如果在程序运行过程中，打算动态决定从其它的路径加载类别，就要产生新的类别加载器。</p><p>您可以使用 URLClassLoader 来产生新的类别加载器，它需要 java.net.URL 作为其参数来指定类别加载的搜寻路径，例如：</p><pre><code>URL url = new URL(&quot;file:/d:/workspace/&quot;);ClassLoader urlClassLoader =                    new URLClassLoader(new URL[] {url});Class c = urlClassLoader.loadClass(&quot;SomeClass&quot;);</code></pre><p>由于 ClassLoader 是 Java SE 的标准API之一，可以在 rt.jar 中找到，因而会由 Bootstrap Loader 来载入 ClassLoader 类别，在新增了 ClassLoader 实例后，您可以使用它的 loadClass() 方法来指定要加载的类别名称，在新增 ClassLoader 时，会自动将新建的 ClassLoader 的 parent 设定为 AppClassLoader，并在每次加载类别时，先委托 parent 代为搜寻，所以上例中搜寻 SomeClass 类别时，会一路往上委托至 Bootstrap Loader 先开始搜寻，接着是 ExtClassLoader、AppClassLoader，如果都找不到，才使用新建的 ClassLoader 搜寻。</p><p>Java 的类别加载器阶层架构除了可以达到动态加载类别目的之外，还有着安全上的考虑，首先，因为每次寻找类别时都是委托 parent 开始寻找，所以除非有人可以侵入您的计算机，置换掉标准 Java SE API 与您自己安装的延伸套件，否则是不可能藉由撰写自己的类别加载器来载入恶意类别，以置换掉标准 Java SE API与您自己安装的延伸套件。</p><p>由于每次的类别载入是由子 ClassLoader 委托父 ClassLoader 先尝试加载，但父 lassLoader 看不到子 ClassLoader，所以同一阶层的子 ClassLoader 不会被误用，从而避免了加载错误类别的可能性，例如在图 16.4 中，您想从 YourClassLoader 来加载类别的话，类别加载器阶层不会看到 MaliciousClassLoader。</p><p><img src="../images/img16-04.png" alt="类别加载器阶层的安全设计"></p><p>图 16.4 类别加载器阶层的安全设计</p><p>由同一个 ClassLoader 加载的类别档案，会只有一份Class实例，如果同一个类别档案是由两个不同的ClassLoader 载入，则会有两份不同的 Class 实例。注意这个说法，如果有两个不同的 ClassLoader 搜寻同一个类别，而在 parent 的 AppClassLoader 搜寻路径中就可以找到指定类别的话，则 Class 实例就只会有一个，因为两个不同的 ClassLoader 都是在委托父 ClassLoader 时找到该类别的，如果父 ClassLoader 找不到，而是由各自的 ClassLoader 搜寻到，则 Class 的实例会有两份。</p><p>范例 16.13 是个简单的示范，可用来测试加载路径与Class实例是否为同一对象。</p><h4 id="范例-16-13-ClassLoaderDemo-java"><a href="#范例-16-13-ClassLoaderDemo-java" class="headerlink" title="范例 16.13  ClassLoaderDemo.java"></a><strong>范例 16.13  ClassLoaderDemo.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 测试路径</span></span><br><span class="line">            String classPath = args[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 测试类别</span></span><br><span class="line">            String className = args[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            URL url1 = <span class="keyword">new</span> URL(classPath);</span><br><span class="line">            <span class="comment">// 建立ClassLoader</span></span><br><span class="line">            ClassLoader loader1 =</span><br><span class="line">                      <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[] &#123;url1&#125;);</span><br><span class="line">            <span class="comment">// 加载指定类别</span></span><br><span class="line">            Class c1 = loader1.loadClass(className);</span><br><span class="line">            <span class="comment">// 显示类别描述</span></span><br><span class="line">            System.out.println(c1);</span><br><span class="line"></span><br><span class="line">            URL url2 = <span class="keyword">new</span> URL(classPath);</span><br><span class="line">            ClassLoader loader2 =</span><br><span class="line">                      <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[] &#123;url2&#125;);</span><br><span class="line">            Class c2 = loader2.loadClass(className);</span><br><span class="line"></span><br><span class="line">            System.out.println(c2);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"c1 与 c1 为同一实例？"</span></span><br><span class="line">                                     + (c1 == c2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有指定类别加载路径与名称"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(MalformedURLException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"加载路径错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到指定的类别"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以任意设计一个类别，例如 TestClass，其中 classPath 可以输入不为 ExtClassLoader 或 AppClassLoader 的搜寻路径，例如 file:/d:/workspace/，这样同一个类别会分由两个 ClassLoader 载入，结果会有两份 Class 实例，则测试 c1 与 c2 是否为同一实例时，则结果会显示 false，一个执行结果如下：</p><pre><code>java onlyfun.caterpillar.ClassLoaderDemo file:/d:/workspace/ TestClassclass TestClassclass TestClassc1 与 c1 为同一实例？false</code></pre><p>如果您在执行程序时，以 -cp 将 file:/d:/workspace/ 加入为 Classpath 的一部份，由于两个 ClassLoader 的 parent 都是 AppClassLoader，而 AppClassLoader 会在 Classpath 中找到指定的类别，所以最后会只有一个指定的类别之 Class 实例，则测试 c1 与 c2 是否为同一实例时，结果会显示 true，一个执行结果如下：</p><pre><code>java -cp .;d:\workspace onlyfun.caterpillar.ClassLoaderDemo file:/d:/workspace/ TestClassclass TestClassclass TestClassc1 与 c1 为同一实例？true</code></pre><p>使用 -cp 指定 Classpath 时，会覆盖原有的 Classpath 定义，也就是连现行工作目录的路径也覆盖了，由于我的 ClassLoaderDemo 类别是在现行工作目录下，所以使用 -cp 时，也包括了现行工作目录，记得组合多个 Classpath 路径时，可以使用「;」。</p><h2 id="16-2-使用反射生成与操作对象"><a href="#16-2-使用反射生成与操作对象" class="headerlink" title="16.2 使用反射生成与操作对象"></a>16.2 使用反射生成与操作对象</h2><p>使用反射机制，您可以于执行时期动态加载类别并生成对象，操作对象上的方法、改变类别成员的值，甚至连私用（private）成员的值也可以改变。</p><h3 id="16-2-1-生成物件"><a href="#16-2-1-生成物件" class="headerlink" title="16.2.1 生成物件"></a>16.2.1 生成物件</h3><p>您可以使用 Class 的 newInstance() 方法来实例化一个对象，实例化的对象是以 Object 型态传回，例如：</p><pre><code>Class c = Class.forName(className);Object obj = c.newInstance();</code></pre><p>范例 16.14 是个简单的示范，您可以动态加载实现了 List 接口的类别。</p><h4 id="范例-16-14-NewInstanceDemo-java"><a href="#范例-16-14-NewInstanceDemo-java" class="headerlink" title="范例 16.14  NewInstanceDemo.java"></a><strong>范例 16.14  NewInstanceDemo.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewInstanceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">            List list = (List) c.newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                list.add(<span class="string">"element "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(Object o: list.toArray()) &#123;</span><br><span class="line">                System.out.println(o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到指定的类别"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><pre><code>java onlyfun.caterpillar.NewInstanceDemo java.util.ArrayListelement 0element 1element 2element 3element 4</code></pre><p>实际上如果想要使用反射来动态加载类别，通常是对对象的接口或类型都一无所知，也就无法像范例 16.14 中对 newInstance() 传回的对象进行接口转换动作，稍后会介绍如何以反射来呼叫方法以操作 newInstance() 所传回的对象。</p><p>如果加载的类别中具备无参数的建构方法，则可以无参数的 newInstance() 来建构一个不指定初始自变量的对象，如果您要在动态加载及生成对象时指定对象的初始化自变量，则要先指定参数型态、取得 Constructor 对象、使用 Constructor 的 newInstance() 并指定参数的接受值。</p><p>以一个例子来说明，首先定义一个 Student 类。</p><h4 id="范例-16-15-Student-java"><a href="#范例-16-15-Student-java" class="headerlink" title="范例 16.15  Student.java"></a><strong>范例 16.15  Student.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name = <span class="string">"N/A"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">":"</span> + score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以用 Class.forName() 来加载 Student 类别，并使用第二个有参数的建构方法来建构 Student 实例，如范例 16.16 所示。</p><h4 id="范例-16-16-NewInstanceDemo2-java"><a href="#范例-16-16-NewInstanceDemo2-java" class="headerlink" title="范例 16.16  NewInstanceDemo2.java"></a><strong>范例 16.16  NewInstanceDemo2.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewInstanceDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指定参数型态</span></span><br><span class="line">            Class[] params = <span class="keyword">new</span> Class[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">// 第一个参数是String</span></span><br><span class="line">            params[<span class="number">0</span>] = String.class;</span><br><span class="line">            <span class="comment">// 第二个参数是int</span></span><br><span class="line">            params[<span class="number">1</span>] = Integer.TYPE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取得对应参数列的建构方法            </span></span><br><span class="line">            Constructor constructor =</span><br><span class="line">                             c.getConstructor(params);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指定自变量内容</span></span><br><span class="line">            Object[] argObjs = <span class="keyword">new</span> Object[<span class="number">2</span>];</span><br><span class="line">            argObjs[<span class="number">0</span>] = <span class="string">"caterpillar"</span>;</span><br><span class="line">            argObjs[<span class="number">1</span>] = <span class="keyword">new</span> Integer(<span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 给定自变量并实例化</span></span><br><span class="line">            Object obj = constructor.newInstance(argObjs);</span><br><span class="line">            <span class="comment">// 呼叫toString()来观看描述</span></span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到类别"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有所指定的方法"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在指定基本型态时，要使用对应的包裹类别（Wrapper）并使用 .TYPE，例如指定 int 型态时，则使用 Integer.TYPE，如果要指定 Integer 型态的参数的话，才是使用 Integer.class，范例 16.16 会根据指定的自变量呼叫对应的建构方法，加载 onlyfun.caterpillar.Student 的执行结果如下：</p><pre><code>java onlyfun.caterpillar.NewInstanceDemo2 onlyfun.caterpillar.Studentcaterpillar:90</code></pre><h3 id="16-2-2-呼叫方法"><a href="#16-2-2-呼叫方法" class="headerlink" title="16.2.2 呼叫方法"></a>16.2.2 呼叫方法</h3><p>使用反射可以取回类别上方法的对象代表，方法的对象代表是 java.lang.reflect.Method 的实例，您可以使用它的 invoke() 方法来动态呼叫指定的方法，例如呼叫范例 16.15 的 Student 类别上之 setName() 等方法，这边直接以范例 16.17 作为示范。</p><h4 id="范例-16-17-InvokeMethodDemo-java"><a href="#范例-16-17-InvokeMethodDemo-java" class="headerlink" title="范例 16.17  InvokeMethodDemo.java"></a><strong>范例 16.17  InvokeMethodDemo.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 使用无参数建构方法建立对象</span></span><br><span class="line">            Object targetObj = c.newInstance();</span><br><span class="line">            <span class="comment">// 设定参数型态</span></span><br><span class="line">            Class[] param1 = &#123;String.class&#125;;</span><br><span class="line">            <span class="comment">// 根据参数型态取回方法对象</span></span><br><span class="line">            Method setNameMethod = c.getMethod(<span class="string">"setName"</span>, param1);</span><br><span class="line">            <span class="comment">// 设定自变量值</span></span><br><span class="line">            Object[] argObjs1 = &#123;<span class="string">"caterpillar"</span>&#125;;</span><br><span class="line">            <span class="comment">// 给定自变量呼叫指定对象之方法</span></span><br><span class="line">            setNameMethod.invoke(targetObj, argObjs1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Class[] param2 = &#123;Integer.TYPE&#125;;</span><br><span class="line">            Method setScoreMethod =</span><br><span class="line">                     c.getMethod(<span class="string">"setScore"</span>, param2);</span><br><span class="line"></span><br><span class="line">            Object[] argObjs2 = &#123;<span class="keyword">new</span> Integer(<span class="number">90</span>)&#125;;</span><br><span class="line">            setScoreMethod.invoke(targetObj, argObjs2);</span><br><span class="line">            <span class="comment">// 显示对象描述</span></span><br><span class="line">            System.out.println(targetObj);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到类别"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有这个方法"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>范例 16.17 可以指定加载 Student 类别并生成实例，接着可以动态呼叫 setName() 与 setScore() 方法，范例中参数型态与自变量值的设定与范例 16.16 是类似的，由于呼叫 setName() 与 setScore() 所给定的自变量是 “caterpillar” 与 90，所以执行的结果与范例 16.16 是相同的。</p><p>在很少的情况下，您会需要突破 Java 的存取限制来呼叫受保护的（protected）或私有（private）的方法（例如您拿到一个组件（Component），但您没法修改它的原始码来改变某个私有方法的权限，而您又一定要呼叫某个私有方法），这时候您可以使用反射机制来达到您的目的，一个存取私有方法的例子如下：</p><pre><code>Method privateMethod =            c.getDeclaredMethod(&quot;somePrivateMethod&quot;, new Class[0]);privateMethod.setAccessible(true);privateMethod.invoke(targetObj, argObjs);</code></pre><p>使用反射来动态呼叫方法的实际例子之一是在 JavaBean 的设定，例如在 JSP/Servlet 中，可以根据使用者的请求名称与 JavaBean 的属性名称自动比对，将字符串请求值设定至指定的 JavaBean 上，并自动根据参数型态作型态转换（详细说明请见本章后网络索引）。范例 16.18 是个简单的示范，您可以给 CommandUtil 工具类别一个 Map 对象与类别名称，然后取得一个更新了值的实例，其中参数 Map 对象的「键」（Key）为要呼叫的 setter 方法名称（不包括set开头的名称，例如 setName() 方法的话，只要给定键为 name 即可），而「值」（Value）为要设定给 setter 的自变量。</p><h4 id="范例-16-18-CommandUtil-java"><a href="#范例-16-18-CommandUtil-java" class="headerlink" title="范例 16.18  CommandUtil.java"></a><strong>范例 16.18  CommandUtil.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给定Map对象及要产生的Bean类别名称</span></span><br><span class="line">    <span class="comment">// 可以取回已经设定完成的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getCommand</span><span class="params">(Map requestMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    String commandClass)</span></span></span><br><span class="line"><span class="function">                                      <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class c = Class.forName(commandClass);</span><br><span class="line">        Object o = c.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> updateCommand(requestMap, o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用reflection自动找出要更新的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">updateCommand</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                           Map requestMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Object command)</span></span></span><br><span class="line"><span class="function">                              <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Method[] methods =</span><br><span class="line">                   command.getClass().getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 略过private、protected成员</span></span><br><span class="line">            <span class="comment">// 且找出必须是set开头的方法名称</span></span><br><span class="line">            <span class="keyword">if</span>(!Modifier.isPrivate(methods[i].getModifiers()) &amp;&amp;</span><br><span class="line">               !Modifier.isProtected(methods[i].getModifiers()) &amp;&amp;  </span><br><span class="line">               methods[i].getName().startsWith(<span class="string">"set"</span>)) &#123;</span><br><span class="line">                <span class="comment">// 取得不包括set的名称</span></span><br><span class="line">                String name = methods[i].getName()</span><br><span class="line">                                        .substring(<span class="number">3</span>)</span><br><span class="line">                                        .toLowerCase();</span><br><span class="line">                <span class="comment">// 如果setter名称与键值相同</span></span><br><span class="line">                <span class="comment">// 呼叫对应的setter并设定值</span></span><br><span class="line">                <span class="keyword">if</span>(requestMap.containsKey(name)) &#123;</span><br><span class="line">                    String param = (String) requestMap.get(name);</span><br><span class="line">                    Object[] values = findOutParamValues(</span><br><span class="line">                                        param, methods[i]);</span><br><span class="line">                    methods[i].invoke(command, values);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> command;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为对应型态的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object[] findOutParamValues(</span><br><span class="line">                     String param, Method method) &#123;</span><br><span class="line">        Class[] params = method.getParameterTypes();</span><br><span class="line">        Object[] objs = <span class="keyword">new</span> Object[params.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(params[i] == String.class) &#123;</span><br><span class="line">                objs[i] = param;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(params[i] == Short.TYPE) &#123;</span><br><span class="line">                <span class="keyword">short</span> number = Short.parseShort(param);</span><br><span class="line">                objs[i] = <span class="keyword">new</span> Short(number);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(params[i] == Integer.TYPE) &#123;</span><br><span class="line">                <span class="keyword">int</span> number = Integer.parseInt(param);</span><br><span class="line">                objs[i] = <span class="keyword">new</span> Integer(number);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(params[i] == Long.TYPE) &#123;</span><br><span class="line">                <span class="keyword">long</span> number = Long.parseLong(param);</span><br><span class="line">                objs[i] = <span class="keyword">new</span> Long(number);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(params[i] == Float.TYPE) &#123;</span><br><span class="line">                <span class="keyword">float</span> number = Float.parseFloat(param);</span><br><span class="line">                objs[i] = <span class="keyword">new</span> Float(number);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(params[i] == Double.TYPE) &#123;</span><br><span class="line">                <span class="keyword">double</span> number = Double.parseDouble(param);</span><br><span class="line">                objs[i] = <span class="keyword">new</span> Double(number);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(params[i] == Boolean.TYPE) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> bool = Boolean.parseBoolean(param);</span><br><span class="line">                objs[i] = <span class="keyword">new</span> Boolean(bool);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> objs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CommandUtil 可以自动根据方法上的参数型态，将 Map 对象中的「值」对象转换为属性上的对应型态，目前它可以转换基本型态与 String 型态的属性，一个使用 CommandUtil 类别的例子如范例 16.19 所示。</p><h4 id="范例-16-19-CommandUtilDemo-java"><a href="#范例-16-19-CommandUtilDemo-java" class="headerlink" title="范例 16.19  CommandUtilDemo.java"></a><strong>范例 16.19  CommandUtilDemo.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandUtilDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; request =</span><br><span class="line">                  <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        request.put(<span class="string">"name"</span>, <span class="string">"caterpillar"</span>);</span><br><span class="line">        request.put(<span class="string">"score"</span>, <span class="string">"90"</span>);</span><br><span class="line">        Object obj = CommandUtil.getCommand(request, args[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以使用范例 16.19 来加载 Student 类别，使用 CommandUtil.getCommand() 方法可以返回一个设定好值的 Student 实例，虽然您设定给 request 的「值」是字符串型态，但 CommandUtil 会使用反射机制来自动转换为属性上的对应型态，一个执行的范例如下所示：</p><pre><code>java onlyfun.caterpillar.CommandUtilDemo onlyfun.caterpillar.Studentcaterpillar:90</code></pre><blockquote><p><strong>良葛格的话匣子</strong> 不知道方法的名称如何呼叫？其实范例 16.17 就给出了答案，透过规范方法的命名方式，之后就可以透用反射机制加上方法名称的比对，以正确呼叫对应的方法。</p></blockquote><h3 id="16-2-3-修改成员值"><a href="#16-2-3-修改成员值" class="headerlink" title="16.2.3 修改成员值"></a>16.2.3 修改成员值</h3><p>尽管直接存取类别的数据成员（Field）是不被鼓励的，但您仍是可以直接存取公开的（public）数据成员，而您甚至也可以透过反射机制来存取私用数据成员，以一个实例来说明，首先撰写个 TestedField 类别。</p><h4 id="范例-16-20-TestField-java"><a href="#范例-16-20-TestField-java" class="headerlink" title="范例 16.20  TestField.java"></a><strong>范例 16.20  TestField.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestField</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> testInt;</span><br><span class="line">    <span class="keyword">public</span> String testString;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testInt + <span class="string">":"</span> + testString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>范例 16.21 则利用反射机制动态加载类别来存取数据成员。</p><h4 id="范例-16-21-AssignFieldDemo-java"><a href="#范例-16-21-AssignFieldDemo-java" class="headerlink" title="范例 16.21  AssignFieldDemo.java"></a><strong>范例 16.21  AssignFieldDemo.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssignFieldDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">            Object targetObj = c.newInstance();</span><br><span class="line"></span><br><span class="line">            Field testInt = c.getField(<span class="string">"testInt"</span>);</span><br><span class="line">            testInt.setInt(targetObj, <span class="number">99</span>);</span><br><span class="line"></span><br><span class="line">            Field testString = c.getField(<span class="string">"testString"</span>);</span><br><span class="line">            testString.set(targetObj, <span class="string">"caterpillar"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(targetObj);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有指定类别"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到指定的类别"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到指定的数据成员"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以加载 TestField 类别来看看执行的结果，如下所示：</p><pre><code>java onlyfun.caterpillar.AssignFieldDemo onlyfun.caterpillar.TestField99:caterpillar</code></pre><p>如果有必要的话，您也可以透过反射机制来存取私有的数据成员，例如：</p><pre><code>Field privateField = c.getDeclaredField(&quot;privateField&quot;);privateField.setAccessible(true);privateField.setInt(targetObj, 99);</code></pre><h3 id="16-2-4-再看数组对象"><a href="#16-2-4-再看数组对象" class="headerlink" title="16.2.4 再看数组对象"></a>16.2.4 再看数组对象</h3><p>在 Java 中数组也是一个对象，也会有一个 Class 实例来表示它，范例 16.22 显示几个基本型态以及 String 数组的类别名称描述。</p><h2 id="范例-16-22-ArrayDemo-java"><a href="#范例-16-22-ArrayDemo-java" class="headerlink" title="范例 16.22  ArrayDemo.java"></a><strong>范例 16.22  ArrayDemo.java</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">short</span>[] sArr = <span class="keyword">new</span> <span class="keyword">short</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span>[] iArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">long</span>[] lArr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">float</span>[] fArr = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">double</span>[] dArr = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] bArr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[] zArr = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">5</span>];</span><br><span class="line">        String[] strArr = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"short 数组类别："</span> + sArr.getClass());</span><br><span class="line">        System.out.println(<span class="string">"int 数组类别："</span> + iArr.getClass());</span><br><span class="line">        System.out.println(<span class="string">"long 数组类别："</span> + lArr.getClass());</span><br><span class="line">        System.out.println(<span class="string">"float 数组类别："</span> + fArr.getClass());</span><br><span class="line">        System.out.println(<span class="string">"double 数组类别："</span> + dArr.getClass());</span><br><span class="line">        System.out.println(<span class="string">"byte 数组类别："</span> + bArr.getClass());</span><br><span class="line">        System.out.println(<span class="string">"boolean 数组类别："</span> + zArr.getClass());</span><br><span class="line">        System.out.println(<span class="string">"String 数组类别："</span> + strArr.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 toString() 来显示数组对象的类别名称描述时，会以 “class [“ 作为开始，之后跟随着一个型态表示字符，执行结果如下所示：</p><pre><code>short 数组类别：class [Sint 数组类别：class [Ilong 数组类别：class [Jfloat 数组类别：class [Fdouble 数组类别：class [Dbyte 数组类别：class [Bboolean 数组类别：class [ZString 数组类别：class [Ljava.lang.String;</code></pre><p>要使用反射机制动态生成数组的话，可以使用 java.lang.reflect.Array 来协助，范例 16.23 简单的示范了如何生成 String 数组。</p><h4 id="范例-16-23-NewArrayDemo-java"><a href="#范例-16-23-NewArrayDemo-java" class="headerlink" title="范例 16.23  NewArrayDemo.java"></a><strong>范例 16.23  NewArrayDemo.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c = String.class;</span><br><span class="line">        Object objArr = Array.newInstance(c, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Array.set(objArr, i, i+<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.print(Array.get(objArr, i) + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        String[] strs = (String[]) objArr;</span><br><span class="line">        <span class="keyword">for</span>(String s : strs) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Array.newInstance() 的第一个参数是指定元素型态，而第二个参数是用来指定数组长度，执行结果如下：</p><pre><code>0 1 2 3 40 1 2 3 4</code></pre><p>Array.newInstance() 还有另一个版本，可用于建立二维数组，只要用一个表示二维数组的两个维度长度的 int 数组，传递给第二个参数，范例 16.24 是个简单示范。</p><h4 id="范例-16-24-NewArrayDemo2-java"><a href="#范例-16-24-NewArrayDemo2-java" class="headerlink" title="范例 16.24  NewArrayDemo2.java"></a><strong>范例 16.24  NewArrayDemo2.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewArrayDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c = String.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打算建立一个3*4数组</span></span><br><span class="line">        <span class="keyword">int</span>[] dim = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        Object objArr = Array.newInstance(c, dim);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Object row = Array.get(objArr, i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                Array.set(row, j, <span class="string">""</span> + (i+<span class="number">1</span>)*(j+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Object row = Array.get(objArr, i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                System.out.print(Array.get(row, j) + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><pre><code>1 2 3 42 4 6 83 6 9 12</code></pre><p>如果想要得知数组元素的型态，可以在取得数组的 Class 实例之后，使用 Class 实例的 getComponentType() 方法，所取回的是元素的 Class 实例，例如：</p><pre><code>int[] iArr = new int[5];System.out.println(iArr.getClass().getComponentType());</code></pre><h3 id="16-2-5-Proxy-类别"><a href="#16-2-5-Proxy-类别" class="headerlink" title="16.2.5 Proxy 类别"></a>16.2.5 Proxy 类别</h3><p>Java 在 J2SE 1.3 之后加入 java.lang.reflect.Proxy 类别，可协助您实现动态代理功能，举个实际应用的例子，假设今天您打算开发一个 HelloSpeaker 类别，当中有一个 hello() 方法，而您想要在这个 hello() 呼叫前后加上记录（log）的功能，但又不想将记录的功能写到 HelloSpeaker 类别中，这时您可以使用 Proxy 类别来实现动态代理。<br>要实现动态代理，首先要定义所要代理的接口，范例 16.25 为定义了有 hello() 方法的 IHello 接口。</p><h4 id="范例-16-25-IHello-java"><a href="#范例-16-25-IHello-java" class="headerlink" title="范例 16.25 IHello.java"></a><strong>范例 16.25 IHello.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您的 HelloSpeaker 类别实现了 IHello 接口，如范例 16.26 所示。</p><h4 id="范例-16-26-HelloSpeaker-java"><a href="#范例-16-26-HelloSpeaker-java" class="headerlink" title="范例 16.26  HelloSpeaker.java"></a><strong>范例 16.26  HelloSpeaker.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSpeaker</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以实作一个处理记录（log）的处理者（Handler），让处理者在呼叫 hello() 方法的前后进行记录的动作，一个处理者必须实现 java.lang.reflect.InvocationHandler 接口，InvocationHandler 有一个 invoke() 方法必须实现，范例 16.27 是个简单的实现。</p><h4 id="范例-16-27-LogHandler-java"><a href="#范例-16-27-LogHandler-java" class="headerlink" title="范例 16.27  LogHandler.java"></a><strong>范例 16.27  LogHandler.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.logging.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger =</span><br><span class="line">               Logger.getLogger(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">    <span class="keyword">private</span> Object delegate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定要代理的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">        <span class="comment">// 建立并传回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                 delegate.getClass().getClassLoader(),</span><br><span class="line">                 <span class="comment">// 要被代理的接口</span></span><br><span class="line">                 delegate.getClass().getInterfaces(),</span><br><span class="line">                 <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理要呼叫的方法，并在其前后增加行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.log(Level.INFO,</span><br><span class="line">                         <span class="string">"method starts..."</span> + method.getName());</span><br><span class="line">            result = method.invoke(delegate, args);</span><br><span class="line">            logger.log(Level.INFO,</span><br><span class="line">                         <span class="string">"method ends..."</span> + method.getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            logger.log(Level.INFO, e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的概念是使用 Proxy.newProxyInstance() 方法建立一个代理对象，建立代理对象时必须告知所要代理的操作接口，之后您可以操作所建立的代理对象，在每次操作时会呼叫 InvocationHandler 的 invoke() 方法，invoke() 方法会传入被代理对象的方法名称与执行自变量，实际上要执行的方法交由 method.invoke()，您在 method.invoke() 前后加上记录动作，method.invoke() 传回的对象是实际方法执行过后的回传结果，先从范例 16.28 来看看一个执行的例子。</p><h4 id="范例-16-28-ProxyDemo-java"><a href="#范例-16-28-ProxyDemo-java" class="headerlink" title="范例 16.28  ProxyDemo.java"></a><strong>范例 16.28  ProxyDemo.java</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> onlyfun.caterpillar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LogHandler handler  = <span class="keyword">new</span> LogHandler();</span><br><span class="line">        IHello speaker = <span class="keyword">new</span> HelloSpeaker();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代理speaker的对象</span></span><br><span class="line">        IHello speakerProxy =</span><br><span class="line">                 (IHello) handler.bind(speaker);</span><br><span class="line"></span><br><span class="line">        speakerProxy.hello(<span class="string">"Justin"</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><pre><code>2005/6/4 上午 09:39:11 onlyfun.caterpillar.LogHandler invoke信息: method starts...helloHello, Justin2005/6/4 上午 09:39:11 onlyfun.caterpillar.LogHandler invoke信息: method ends...hello</code></pre><p>透过代理机制，在不将记录动作写入为 HelloSpeaker 类别程序代码的情况下，您可以为其加入记录的功能，这并不是什么魔法，只不过是在 hello() 方法前后由代理对象 speakerProxy 先执行记录功能而已，而真正执行 hello() 方法时才使用 speaker 对象。</p><blockquote><p><strong>良葛格的话匣子</strong> 这边的例子是「Proxy 模式」的实现，您可以进一步参考：</p><ul><li><a href="http://openhome.cc/Gossip/DesignPattern/ProxyPattern.htm" target="_blank" rel="noopener">Proxy 模式（一）</a></li><li><a href="http://openhome.cc/Gossip/DesignPattern/ProxyPattern2.htm" target="_blank" rel="noopener">Proxy 模式（二）</a></li></ul></blockquote><h2 id="16-3-接下来的主题"><a href="#16-3-接下来的主题" class="headerlink" title="16.3 接下来的主题"></a>16.3 接下来的主题</h2><p>每一个章节的内容由浅至深，初学者该掌握的深度要到哪呢？在这个章节中，对于初学者我建议至少掌握以下几点内容：</p><ul><li>了解 Class 实例与类别的关系</li><li>会使用 Class.forName() 加载类别并获得类别信息</li><li>会使用 Class 建立实例</li><li>会使用反射机制呼叫对象上的方法</li></ul><p>下一个章节要来介绍 J2SE 5.0 中新增的 Annotation 功能，Annotation 是 J2SE 5.0 对 metadata 的支持，metadata 简单的说就是「数据的数据」（Data about data），您可以使用 Annotation 对程序代码作出一些说明，以利一些程序代码分析工具来使用这些信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第-16-章-反射（Reflection）&quot;&gt;&lt;a href=&quot;#第-16-章-反射（Reflection）&quot; class=&quot;headerlink&quot; title=&quot;第 16 章 反射（Reflection）&quot;&gt;&lt;/a&gt;第 16 章 反射（Reflection）&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android 插件化开发</title>
    <link href="http://yoursite.com/2018/07/11/Android-%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2018/07/11/Android-插件化开发/</id>
    <published>2018-07-11T08:20:59.000Z</published>
    <updated>2018-07-11T12:53:32.156Z</updated>
    
    <content type="html"><![CDATA[<p><body></body></p><section class="content"><br><ul class="items"><br>    <li style="background: #FFFFFF"><br>    <h1><a href="#" title="title">Android博客周刊专题之＃插件化开发＃</a></h1><br>本期专栏目讨论插件化开发。插件化涉及的东西很多，所以我们需要多个维度去学习。大概分为5个部分：预备知识、入门、进阶、系列、类库。一步一步深入了解插件的原理。本专栏会不定时更新相关内容，请留意更新的消息。<br>    <footer>转自：<a href="http://www.androidblog.cn/index.php/Index/detail/id/16#" target="_blank" rel="noopener">http://www.androidblog.cn/index.php/Index/detail/id/16#</a></footer> </li><br></ul><br><br><b>基础</b><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/" target="_blank">1.Java 类加载器</a><br>类加载器（class loader）是 Java™中的一个很重要的概念。类加载器负责加载 Java 类的字节代码到 Java 虚拟机中。本文首先详细介绍了 Java 类加载器的基本概念，包括代理模式、加载类的具体过程和线程上下文类加载器等，接着介绍如何开发自己的类加载器，最后介绍了类加载器在 Web 容器和 OSGi™中的应用。<br><a href="https://github.com/JustinSDK/JavaSE6Tutorial/blob/master/docs/CH16.md" target="_blank">2.反射原理</a><br><br>Java 提供的反射機制允許您於執行時期動態載入類別、檢視類別資訊、生成物件或操作生成的物件，要舉反射機制的一個應用實例，就是在整合式開發環境中所提供的方法提示或是類別檢視工具，另外像 JSP 中的 JavaBean 自動收集請求資訊也使用到反射，而一些軟體開發框架（Framework）也常見到反射機制的使用，以達到動態載入使用者自訂類別的目的。<br><a href="http://www.jianshu.com/p/6f6bb2f0ece9" target="_blank">3.代理模式及Java实现动态代理</a><br>定义：给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。<br><b>入门</b><br><br><a href="http://blog.csdn.net/u013478336/article/details/50734108" target="_blank">1.Android动态加载dex技术初探</a><br><br><br>  Android使用Dalvik虚拟机加载可执行程序，所以不能直接加载基于class的jar，而是需要将class转化为dex字节码，从而执行代码。优化后的字节码文件可以存在一个<em>.jar中，只要其内部存放的是</em>.dex即可使用。<a href="http://104.236.134.90/2016/02/02/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%9F%BA%E7%A1%80/" target="_blank">2.Android插件化入门</a><br><br>开发者将插件代码封装成Jar或者APK。宿主下载或者从本地加载Jar或者APK到宿主中。将宿主调用插件中的算法或者Android特定的Class（如Activity）<a href="http://blog.csdn.net/u010687392/article/details/47121729?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io" target="_blank">3.插件化开发—动态加载技术加载已安装和未安装的apk</a><br><br>动态加载技术就是使用类加载器加载相应的apk、dex、jar（必须含有dex文件），再通过反射获得该apk、dex、jar内部的资源（class、图片、color等等）进而供宿主app使用。<a href="https://blog.tingyun.com/web/article/detail/166" target="_blank">4.Android动态加载技术三个关键问题详解</a><br><br>动态加载技术（也叫插件化技术）在技术驱动型的公司中扮演着相当重要的角色，当项目越来越庞大的时候，需要通过插件化来减轻应用的内存和CPU占用，还可以实现热插拔，即在不发布新版本的情况下更新某些模块。<br><b>进阶</b><br><a href="http://mp.weixin.qq.com/s?__biz=MzAwMTcwNTE0NA==&mid=400217391&idx=1&sn=86181541ce0164156dfab135ed99bb5c&scene=0&key=b410d3164f5f798e61a5d4afb759fa38371c8b119384c6163a30c28163b4d4d5f59399f2400800ec842f1d0e0ffb84af&ascene=0&uin=MjExMjQ&pass_ticket=Nt5Jaa28jjFxcQO9o%2BvQiXX%2B0iXG5DlZlHNW97Fk1Ew%3D" target="_blank">1.携程Android App插件化和动态加载实践</a><br><br>携程Android App的插件化和动态加载框架已上线半年，经历了初期的探索和持续的打磨优化，新框架和工程配置经受住了生产实践的考验。本文将详细介绍Android平台插件式开发和动态加载技术的原理和实现细节，回顾携程Android App的架构演化过程，期望我们的经验能帮助到更多的Android工程师。<a href="http://blog.csdn.net/hkxxx/article/details/42194387" target="_blank">2.动态加载APK原理分享</a><br><br> 被加载的apk称之为插件，因为机制类似于生物学的”寄生”，加载了插件的应用也被称为宿主。<br>往往不是所有的apk都可作为插件被加载，往往需要遵循一定的”开发规范”，还需要插件项目引入某种api类库，业界通常都是这么做的。<a href="http://www.cnblogs.com/coding-way/p/4669591.html" target="_blank">3.Android插件化的一种实现</a><br><br>Android的插件化已经是老生常谈的话题了，插件化的好处有很多：解除代码耦合，插件支持热插拔，静默升级，从根本上解决65K属性和方法的bug等等。下面给大家介绍一下我们正在用的差价化框架。本片主要以类图的方式向大家介绍插件话框架的实现。<a href="http://mogu.io/117-117" target="_blank">4.蘑菇街 App 的组件化之路</a><br><br><br><br>随着我街业务的蓬勃发展，产品和运营随时上新功能新活动的需求越来越强烈，经常可以听到“有个功能我想周x上，行不行”。行么？当然是不行啦，上新功能得发新版本啊，到时候费时费力打乱开发节奏不说，覆盖率也是个问题。<a href="http://www.codekk.com/open-source-project-analysis/detail/Android/FFish/DynamicLoadApk%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io" target="_blank">5.DynamicLoadApk 源码解析</a><br><br><br><br>DynamicLoadApk 是一个开源的 Android 插件化框架。插件化的优点包括：(1) 模块解耦，(2) 动态升级，(3) 高效并行开发(编译速度更快) (4) 按需加载，内存占用更低等等DynamicLoadApk 提供了 3 种开发方式，让开发者在无需理解其工作原理的情况下快速的集成插件化功能。<a href="http://blog.csdn.net/singwhatiwanna/article/details/22597587" target="_blank">6.Android apk动态加载机制的研究</a><br><br><br><br>问题是这样的：我们知道，apk必须安装才能运行，如果不安装要是也能运行该多好啊，事实上，这不是完全不可能的，尽管它比较难实现。在理论层面上，我们可以通过一个宿主程序来运行一些未安装的apk，当然，实践层面上也能实现，不过这对未安装的apk有要求。我们的想法是这样的，首先要明白apk未安装是不能被直接调起来.<a href="http://tech.meituan.com/mt-android-auto-split-dex.html" target="_blank">7.美团Android DEX自动拆包及动态加载简介</a><br><br><br><br>作为一个android开发者，在开发应用时，随着业务规模发展到一定程度，不断地加入新功能、添加新的类库，代码在急剧的膨胀，相应的apk包的大小也急剧增加， 那么终有一天，你会不幸遇到这个错误.<br><a href="http://mp.weixin.qq.com/s?__biz=MzAwOTE0ODEwMQ==&mid=401731625&idx=1&sn=9bf2bacfbba43ba9dc7b2e854b64e66c&scene=23&srcid=1231ni0s2Y0OMfYSoNhkkJ47#rd&ADUIN=289832127&ADSESSION=1451551778&ADTAG=CLIENT.QQ.5425_.0&ADPUBNO=26509" target="_blank">8.途牛原创|途牛Android App的插件实现</a><br><br><br><br>途牛的插件化是基于dynamic-load-apk（github）实现的。定义了宿主和插件的通信方式，使得两者能够互起对方的页面，调用彼此的功能。同时对activity的启动方式singletask等进行了模式实现，并增加了对Service的支持等。总之使得插件开发最大限度的保持着原有的Android开发习惯。<a href="http://blog.csdn.net/singwhatiwanna/article/details/23387079" target="_blank">9. Android apk资源加载和activity生命周期管理</a><br><br><br><br>博主分析了Android中apk的动态加载机制，并在文章的最后指出需要解决的两个复杂问题：资源的访问和activity生命周期的管理，而本文将会分析这两个复杂问题的解决方法。<a href="http://blog.csdn.net/singwhatiwanna/article/details/39937639" target="_blank">10.APK动态加载框架（DL）解析</a><br><br><br><br>首先要说的是动态加载技术（或者说插件化）在技术驱动型的公司中扮演这相当重要的角色，当项目越来越庞大的时候，需要通过插件化来减轻应用的内存和cpu占用，还可以实现热插拔，即在不发布新版本的情况下更新某些模块。<br><br><b>系列</b><br><br><a href="https://segmentfault.com/a/1190000004062866" target="_blank">1.Kaedea—Android动态加载技术 简单易懂的介绍</a><br><br><br><br>我们很早开始就在Android项目中采用了动态加载技术，主要目的是为了达到让用户不用重新安装APK就能升级应用的功能（特别是 SDK项目），这样一来不但可以大大提高应用新版本的覆盖率，也减少了服务器对旧版本接口兼容的压力，同时如果也可以快速修复一些线上的BUG。<a href="https://segmentfault.com/a/1190000004062880" target="_blank">2.Kaedea—Android动态加载基础 ClassLoader的工作机制</a><br><br><br><br>早期使用过Eclipse等Java编写的软件的同学可能比较熟悉，Eclipse可以加载许多第三方的插件（或者叫扩展），这就是动态加载。这些插件大多是一些Jar包，而使用插件其实就是动态加载Jar包里的Class进行工作。<a href="https://segmentfault.com/a/1190000004062899" target="_blank">3.Kaedea—Android动态加载补充 加载SD卡的SO库</a><br><br><br><br>Android中JNI的使用其实就包含了动态加载，APP运行时动态加载.so库并通过JNI调用其封装好的方法。后者一般是使用NDK工具从C/C++代码编译而成，运行在Native层，效率会比执行在虚拟机的Java代码高很多，所以Android中经常通过动态加载.so库来完成一些对性能比较有需求的工作（比如T9搜索、或者Bitmap的解码、图片高斯模糊处理等）。<a href="https://segmentfault.com/a/1190000004062952" target="_blank">4.Kaedea—Android动态加载入门 简单加载模式</a><br><br><br><br>Java程序中，JVM虚拟机是通过类加载器ClassLoader加载.jar文件里面的类的。Android也类似，不过Android用的是Dalvik/ART虚拟机，不是JVM，也不能直接加载.jar文件，而是加载dex文件。<a href="https://segmentfault.com/a/1190000004062972" target="_blank">5.Kaedea—Android动态加载进阶 代理Activity模式</a><br><br><br><br>简单模式中，使用ClassLoader加载外部的Dex或Apk文件，可以加载一些本地APP不存在的类，从而执行一些新的代码逻辑。但是使用这种方法却不能直接启动插件里的Activity。<a href="https://segmentfault.com/a/1190000004077469" target="_blank">6.Kaedea—Android动态加载黑科技 动态创建Activity模式</a><br><br><br><br>还记得我们在代理Activity模式里谈到启动插件APK里的Activity的两个难题吗，由于插件里的Activity没在主项目的Manifest里面注册，所以无法经历系统Framework层级的一系列初始化过程，最终导致获得的Activity实例并没有生命周期和无法使用res资源。<a href="http://blog.csdn.net/jiangwei0910410003/article/details/17679823" target="_blank">7.尼古拉斯—插件开发基础篇：动态加载技术解读</a><br><br><br><br>在目前的软硬件环境下，Native App与Web App在用户体验上有着明显的优势，但在实际项目中有些会因为业务的频繁变更而频繁的升级客户端，造成较差的用户体验，而这也恰恰是Web App的优势。本文对网上Android动态加载jar的资料进行梳理和实践在这里与大家一起分享，试图改善频繁升级这一弊病。<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41384667" target="_blank">8.尼古拉斯—插件开发开篇：类加载器分析</a><br><br><br><br>这篇文章主要介绍了Android中主要的两个类加载器：PathClassLoader和DexClassLoader,他们的区别，联系，用法等问题，以及我们在制作插件的过程中会遇到哪些常见的问题。这篇文章也是后续两篇文章的基础，因为如果不了解这两个类的话，我们将无法进行后续的操作。<a href="http://blog.csdn.net/jiangwei0910410003/article/details/47679843" target="_blank">9.尼古拉斯—插件开发中篇：资源加载问题(换肤原理解析)</a><br><br><br><br>这篇文章主要通过现在一些应用自带的换肤技术的解读来看看，在开发插件的过程中如何解决一些资源加载上的问题，这个问题为何要单独拿出来解释，就是因为他涉及的知识很多，也是后面一篇文章的基础，我们在需要加载插件中的资源文件的时候。<a href="http://blog.csdn.net/jiangwei0910410003/article/details/48104455" target="_blank">10.尼古拉斯—插件开发终极篇：动态加载Activity(免安装运行程序)</a><br><br><br><br>这篇文章主要是讲解了如何加载插件中的Activity。从而实现免安装运行程序，同时这篇文章也是对前三篇文章知识的综合使用。下载很多应用都会使用到插件技术，因为包的大小和一些功能的优先级来决定哪些模块可以制作成插件。<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/" target="_blank">11.Weishu—Android插件化原理解析——概要</a><br><br><br><br>类的加载可以使用Java的ClassLoader机制，但是对于Android来说，并不是说类加载进来就可以用了，很多组件都是有“生命”的；因此对于这些有血有肉的类，必须给它们注入活力，也就是所谓的组件生命周期管理.<a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/" target="_blank">12.Weishu—Android插件化原理解析——Hook机制之动态代理</a><br><br><br><br>使用代理机制进行API Hook进而达到方法增强是框架的常用手段，比如J2EE框架Spring通过动态代理优雅地实现了AOP编程，极大地提升了Web开发效率；同样，插件框架也广泛使用了代理机制来增强系统API从而达到插件化的目的.<a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/" target="_blank">13.Weishu—Android插件化原理解析——Hook机制之Binder Hook</a><br><br><br><br>Android系统通过Binder机制给应用程序提供了一系列的系统服务，诸如ActivityManagerService，ClipboardManager， AudioManager等；这些广泛存在系统服务给应用程序提供了诸如任务管理，音频，视频等异常强大的功能。<a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/" target="_blank">14.Weishu—Android 插件化原理解析——Hook机制之AMS&amp;PMS</a><br><br><br><br>在前面的文章中我们介绍了DroidPlugin的Hook机制，也就是代理方式和Binder Hook；插件框架通过AOP实现了插件使用和开发的透明性。在讲述DroidPlugin如何实现四大组件的插件化之前，有必要说明一下它对AMS以及PMS的Hook方式。<a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/" target="_blank">15.Weishu—Android 插件化原理解析——Activity生命周期管理</a><br><br><br><br>之前的 Android插件化原理解析 系列文章揭开了Hook机制的神秘面纱，现在我们手握倚天屠龙，那么如何通过这种技术完成插件化方案呢？具体来说，插件中的Activity，Service等组件如何在Android系统上运行起来？<br><a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/" target="_blank">16.Weishu—Android 插件化原理解析——插件加载机制</a><br><br><br><br>上文 Activity生命周期管理 中我们地完成了『启动没有在AndroidManifest.xml中显式声明的Activity』的任务；通过Hook AMS和拦截ActivityThread中H类对于组件调度我们成功地绕过了AndroidMAnifest.xml的限制。<br><a href="http://weishu.me/2016/04/12/understand-plugin-framework-receiver/" target="_blank">17.Weishu—Android插件化原理解析——广播的管理</a><br><br><br><br>在Activity生命周期管理 以及 插件加载机制 中我们详细讲述了插件化过程中对于Activity组件的处理方式，为了实现Activity的插件化我们付出了相当多的努力；那么Android系统的其他组件，比如BroadcastReceiver，Service还有ContentProvider，它们又该如何处理呢？<a href="http://weishu.me/2016/05/11/understand-plugin-framework-service/" target="_blank">18.Weishu—Android 插件化原理解析——Service的插件化</a><br><br><br><br>在 Activity生命周期管理 以及 广播的管理 中我们详细探讨了Android系统中的Activity、BroadcastReceiver组件的工作原理以及它们的插件化方案，相信读者已经对Android Framework和插件化技术有了一定的了解；<br><br><b>类库</b><br><br><a href="https://github.com/Qihoo360/DroidPlugin" target="_blank">1.DroidPlugin</a><br><br><br><br>是360手机助手在Android系统上实现了一种新的插件机制<a href="https://github.com/limpoxe/Android-Plugin-Framework" target="_blank">2.Android-Plugin-Framework</a><br><br><br><br>此项目是Android插件开发框架完整源码及示例。用来通过动态加载的方式在宿主程序中运行插件APK。<a href="https://github.com/wequick/Small" target="_blank">3.Small</a><br><br><br><br>世界那么大，组件那么小。Small，做最轻巧的跨平台插件化框架。里面有很详细的文档<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank">4.dynamic-load-apk</a><br><br><br><br>Android 使用动态加载框架DL进行插件化开发<a href=" https://github.com/mmin18/AndroidDynamicLoader" target="_blank">5.AndroidDynamicLoader</a><br><br><br><br>Android 动态加载框架，他不是用代理 Activity 的方式实现而是用 Fragment 以及 Schema 的方式实现<a href="https://github.com/CtripMobile/DynamicAPK" target="_blank">6.DynamicAPK</a><br><br><br><br>实现Android App多apk插件化和动态加载，支持资源分包和热修复.携程App的插件化和动态加载框架.<a href="https://github.com/bunnyblue/ACDD/blob/master/README-Zh.md" target="_blank">7.ACDD</a><br><br><br>非代理Android动态部署框架<a href="https://github.com/houkx/android-pluginmgr" target="_blank">8.android-pluginmgr</a><br><br><br>不需要插件规范的apk动态加载框架。<br><b>参考视频</b><br><br><a href="http://www.infoq.com/cn/presentations/the-realization-principle-and-application-of-droidplugin" target="_blank">1.DroidPlugin的实现原理及其应用</a><br><br><br><br>Droid Plugin是360手机助手在2015年初研发的一个全新的基于Android平台的插件机制.<a href="http://v.youku.com/v_show/id_XNTMzMjYzMzM2.html" target="_blank">2.android插件化及动态部署</a><br><br><br><br> 阿里技术沙龙第十六期《android插件化及动态部署》视频  </section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;body&gt;&lt;/body&gt;&lt;/p&gt;
&lt;section class=&quot;content&quot;&gt;&lt;br&gt;&lt;ul class=&quot;items&quot;&gt;&lt;br&gt;    &lt;li style=&quot;background: #FFFFFF&quot;&gt;&lt;br&gt;    &lt;h1&gt;&lt;a href=&quot;#&quot; title=&quot;t
      
    
    </summary>
    
      <category term="develop" scheme="http://yoursite.com/categories/develop/"/>
    
    
      <category term="develop" scheme="http://yoursite.com/tags/develop/"/>
    
  </entry>
  
  <entry>
    <title>Github Top100</title>
    <link href="http://yoursite.com/2018/07/11/Github-Top100/"/>
    <id>http://yoursite.com/2018/07/11/Github-Top100/</id>
    <published>2018-07-11T01:16:30.000Z</published>
    <updated>2018-07-11T01:16:54.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="转-GitHub-Top-100-简介"><a href="#转-GitHub-Top-100-简介" class="headerlink" title="(转) GitHub Top 100 简介"></a>(转) GitHub Top 100 简介</h2><p>主要对当前 GitHub 排名前 100 的项目做一个简单的简介, 方便初学者快速了解到当前 Objective-C 在 GitHub 的情况.</p><table><thead><tr><th>项目名称</th><th>项目信息</th></tr></thead><tbody><tr><td>1. <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a></td><td>作者是 NSHipster 的博主, iOS 开发界的大神级人物, 毕业于卡内基·梅隆大学, 开源了许多牛逼的项目, 这个便是其中之一, AFNetworking 采用 NSURLConnection + NSOperation, 主要方便与服务端 API 进行数据交换, 操作简单, 功能强大, 现在许多人都用它取代 ASIHTTPRequest</td></tr><tr><td>2. <a href="https://github.com/BradLarson/GPUImage" target="_blank" rel="noopener">GPUImage</a></td><td>一款强大的图片滤镜工具, 支持自定义滤镜, 可用来实时处理图片和视频流, 作者是 SonoPlot 公司的 CTO, 在很小的时候便开始接触编程, 他在 <a href="http://stackoverflow.com/users/19679/brad-larson" target="_blank" rel="noopener">SO</a> 上面的回答也有很多值得阅读, GPUImage 这个项目从 2012 年开始, 使用 OpenGL 图形程序接口编写, 性能非常好, 现在很多 iOS 程序员都用它来实现 iOS 的模糊效果</td></tr><tr><td>3. <a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a></td><td>作者 Olivier Poitrey 是 Dailymotion 的 CTO, 拥有多个不错的开源项目, 此项目常用于对从 Web 端接受到的图片进行缓存, 是 UIImageView 的扩展, 应用起来比较简单</td></tr><tr><td>4. <a href="https://github.com/RestKit/RestKit" target="_blank" rel="noopener">RestKit</a></td><td>主要用于 iOS 上网络通信, 允许与 RESTful Web 服务交互, 常用于处理 API, 解析 JSON, 映射响应对象等操作, 简单易用, 方便你把所有精力都放在对数据的操作上</td></tr><tr><td>5. <a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa</a></td><td>由 GitHub 工程师们开发的一个应用于 iOS 和 OS X 开发的函数响应式编程新框架, Matt 称其为 “An open source project that exemplifies this brave new era for Objective-C”, 也有人说它是 Cocoa 的未来, 具体可看唐巧写的这篇<a href="http://www.devtang.com/blog/2014/02/11/reactivecocoa-introduction" target="_blank" rel="noopener">文章</a></td></tr><tr><td>6. <a href="https://github.com/facebookarchive/three20" target="_blank" rel="noopener">three20</a></td><td>由 Facebook iOS 客户端衍生出的一款 iPhone 框架, 内置许多丰富的功能, 有丰富的界面, 对底层的操作便捷, 为开发者省下了很多时间, 但现在已经停止了更新, 一个 <a href="https://github.com/facebookarchive/three20/pull/832?utm_source=iOS+Dev+Weekly&amp;utm_campaign=46a7deb647-iOS_Dev_Weekly_Issue_100&amp;utm_medium=email&amp;utm_term=0_7bda94b7ca-46a7deb647-299428269" target="_blank" rel="noopener">PR</a> 把代码删得干干净净, 不要好奇去点开 Files changed, 我点开后该页面直接卡死, three20 当中的一位作者创建了 <a href="https://github.com/jverkoey/nimbus" target="_blank" rel="noopener">Nimbus</a>, 算是 three20 的一个替代品</td></tr><tr><td>7. <a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="noopener">MBProgressHUD</a></td><td>作者 Matej Bukovinski 是一位全栈工程师, UI/UX 设计师,  此项目是一款提示框第三方库, 帮助开发者快速应用到项目中)</td></tr><tr><td>8. <a href="https://github.com/magicalpanda/MagicalRecord" target="_blank" rel="noopener">MagicalRecord</a></td><td>作者是 Coursera 的 iOS 工程师, 该项目创作灵感来自于 Ruby on Rails 的 Active Record, 主要为方便操作 CoreData 而生, 帮助清除 CoreData 引用的代码, 协助方便 CoreData 的工作</td></tr><tr><td>9. <a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB</a></td><td>一个对 SQLite 进行封装的库, 使用起来方便, 简单</td></tr><tr><td>10. <a href="https://github.com/Mantle/Mantle" target="_blank" rel="noopener">Mantle</a></td><td>作者是 GitHub 的员工, 文档写的很清楚: Mantle makes it easy to write a simple model layer for your Cocoa or Cocoa Touch application, 主要用来将 JSON 数据模型化为 Model 对象, 唱吧在前段时间也改用 Mantle 了.</td></tr><tr><td>11. <a href="https://github.com/Grouper/FlatUIKit" target="_blank" rel="noopener">FlatUIKit</a></td><td>收集了很多扁平化 UI 的 iOS 组件, 方便使用</td></tr><tr><td>12. <a href="https://github.com/pokeb/asi-http-request" target="_blank" rel="noopener">ASIHTTPRequest</a></td><td>一个轻量级的 iOS 网络通信类库, 基于 CFNetwork 框架开发, 但现在已经停止更新, 多数开发者改用 AFNetworking 替代)</td></tr><tr><td>13. <a href="https://github.com/path/FastImageCache" target="_blank" rel="noopener">FastImageCache</a></td><td>Path 公司出品的 iOS 库, 作者 Mallory Paine 是苹果前员工, 此类库适用于在滚动时快速显示图像, 高速持久是其最大的特点</td></tr><tr><td>14. <a href="https://github.com/Masonry/Masonry" target="_blank" rel="noopener">Masonry</a></td><td>一个轻量级的布局框架, 同时支持 iOS 和 Mac OS X, 语法优雅, 帮助开发者快速适配不同分辨率的 iOS 设备</td></tr><tr><td>15. <a href="https://github.com/facebook/Shimmer" target="_blank" rel="noopener">Shimmer</a></td><td>Facebook 推出的一款具有闪烁效果的第三方控件, 供它旗下一款名为 Paper 的应用使用, 安装使用整个过程都十分简单</td></tr><tr><td>16. <a href="https://github.com/TransitApp/SVProgressHUD" target="_blank" rel="noopener">SVProgressHUD</a></td><td>又一款轻量级的 iOS 第三方控件, 用于显示任务加载时的动画, 非常轻便, 容易使用</td></tr><tr><td>17. <a href="https://github.com/jigish/slate" target="_blank" rel="noopener">Slate</a></td><td>一款窗口管理应用程序, 但在两年前就已经停止更新了</td></tr><tr><td>18. <a href="https://github.com/johnezang/JSONKit" target="_blank" rel="noopener">JSONKit</a></td><td>主要用于解析 JSON, 适用于 iOS6 以下环境, 自从 iOS5 开始 Apple 官方给出了 NSJSONSerialization API, 自此大家都用官方的了</td></tr><tr><td>19. <a href="https://github.com/jverkoey/nimbus" target="_blank" rel="noopener">Nimbus</a></td><td>作者 Jeff 曾为 Facebook, Google 做过不少好东西, 也是 three20 的成员之一, three20 停更后, 他创造出这个框架来代替 three20, 文档齐全</td></tr><tr><td>20. <a href="https://github.com/CocoaLumberjack/CocoaLumberjack" target="_blank" rel="noopener">CocoaLumberjack</a></td><td>这是 Mac 和 iOS 的一款强大的日志框架, 配置简单, 多线程, 提供更高级的 log 功能, 可用于代替默认的 NSLog 语句</td></tr><tr><td>21. <a href="https://github.com/facebook/facebook-ios-sdk" target="_blank" rel="noopener">Facebook SDK for iOS</a></td><td>Facebook 官方的 iOS SDK, 方便开发者集成 Facebook 的一些功能到自己的 iOS APP 里面</td></tr><tr><td>22. <a href="https://github.com/facebook/AsyncDisplayKit" target="_blank" rel="noopener">AsyncDisplayKit</a></td><td>Facebook 开源的一款 iOS UI 框架, Paper 用的就是该框架, 另外框架还用到了 Facebook 早期开源 Pop 动画引擎</td></tr><tr><td>23. <a href="https://github.com/supermarin/Alcatraz" target="_blank" rel="noopener">Alcatraz</a></td><td>Alcatraz 是一款管理 Xcode 插件、模版以及颜色配置的工具, 可以集成到 Xcode 的图形界面中, 安装删除都是几条命令的事, 很方便, 支持自己开发插件并上传</td></tr><tr><td>24. <a href="https://github.com/Inferis/ViewDeck" target="_blank" rel="noopener">ViewDeck</a></td><td>一款开源的 iOS 活动面板组件, 还原 Path 2.0 的侧滑效果, 作者因为时间关系在两年前停止对其更新</td></tr><tr><td>25. <a href="https://github.com/jessesquires/JSQMessagesViewController" target="_blank" rel="noopener">JSQMessagesViewController</a></td><td>优雅的 iOS 消息类库, 常用于聊天应用中, 可定制性高</td></tr><tr><td>26. <a href="https://github.com/Flipboard/FLEX" target="_blank" rel="noopener">FLEX</a></td><td>这是 Flipboard 官方发布的一组专门用于 iOS 开发的应用内调试工具, 开发者无需将其连接到 LLDB/Xcode 或其他远程调试服务器,支持直接在 App 中运行</td></tr><tr><td>27. <a href="https://github.com/facebook/xctool" target="_blank" rel="noopener">Xctool</a></td><td>是 Facebook 开源的一个命令行工具，用来替代苹果的 XcodeBuild 工具, 极大的方便了 iOS 的构建和测试, 输出错误信息也比较友好, 受到许多 iOS 开发者的称赞, 经常与其搭配使用的还有 OCUnit, <a href="https://travis-ci.org" target="_blank" rel="noopener">Travis CI</a>, <a href="http://oclint.org" target="_blank" rel="noopener">OCLint</a> 等测试工具</td></tr><tr><td>28. <a href="https://github.com/OpenEmu/OpenEmu" target="_blank" rel="noopener">OpenEmu</a></td><td>超强的游戏模拟器, 做游戏开发必备, 官网做得也很不错</td></tr><tr><td>29. <a href="https://github.com/nicklockwood/iCarousel" target="_blank" rel="noopener">iCarousel</a></td><td>作者是英国 Charcoal Design 公司的创始人, 开源领域的贡献颇为卓著, 这个项目就是其中之一, 这是一款可以在 iOS 上实现旋转木马视图切换效果的第三方控件, 并提供多种切换效果</td></tr><tr><td>30. <a href="https://github.com/romaonthego/RESideMenu" target="_blank" rel="noopener">RESideMenu</a></td><td>作者 Roman Efimov 是雅虎的 iOS 工程师, 这个项目实现了 iOS 上的菜单侧滑效果, 创意来源于 Dribbble, 该项目支持 iOS8</td></tr><tr><td>321 <a href="https://github.com/kevinzhow/PNChart" target="_blank" rel="noopener">PNChart</a></td><td>作者周楷雯是 90 后, 秒视的创始人, 该项目是一个带动画效果的图表控件, 简约易用, 受到不少开发者喜爱</td></tr><tr><td>31.2<a href="https://github.com/square/PonyDebugger" target="_blank" rel="noopener">PonyDebugger</a></td><td>由 Square 公司推出的一款优秀的 iOS 应用网络调试工具, 用户可以实时看到应用程序的网络请求, 也可以对 iOS 应用程序的核心数据栈进行远程调试</td></tr><tr><td>33. <a href="https://github.com/jverdi/JVFloatLabeledTextField" target="_blank" rel="noopener">JVFloatLabeledTextField</a></td><td>作者是 Thumb Labs 的联合创始人, JVFloatLabeledTextField 是 UITextField 的子类, 主要实现输入框标签浮动效果, 创作灵感来自 Dribbble, 已出现多个移植版本</td></tr><tr><td>34. <a href="https://github.com/CEWendel/SWTableViewCell" target="_blank" rel="noopener">SWTableViewCell</a></td><td>UITableViewCell 的子类, 实现了左右滑动显示信息视图并调出按钮</td></tr><tr><td>35. <a href="https://github.com/levey/AwesomeMenu" target="_blank" rel="noopener">AwesomeMenu</a></td><td>作者是一位中国人, 该项目主要是使用 CoreAnimation 还原了 Path menu 的动画效果</td></tr><tr><td>36. <a href="https://github.com/tonymillion/Reachability" target="_blank" rel="noopener">Reachability</a></td><td>Reachablity 是用于检测 iOS 设备网络环境的库</td></tr><tr><td>37. <a href="https://github.com/onevcat/VVDocumenter-Xcode" target="_blank" rel="noopener">VVDocumenter-Xcode</a></td><td>作者是王巍国内著名的 iOS 开发者, 人称喵神, 目前在日本 LINE 公司工作, 该项目帮助开发者轻松的生成注释文档, 节省了不少工作量, 赞</td></tr><tr><td>38. <a href="https://github.com/google/physical-web" target="_blank" rel="noopener">The Physical Web</a></td><td>由 Chrome 团队主导的一个项目, 意在用 URL 连接世界, 方便用户接受数据, 目前尚处在实验阶段</td></tr><tr><td>39. <a href="https://github.com/samuelclay/NewsBlur" target="_blank" rel="noopener">NewsBlur</a></td><td>作者独自一个人 Samuel Clay 做出来的一款名为 NewsBlur 的新闻阅读器, 很多人都称其为 Google Reader 的替代品, 这是它的源码</td></tr><tr><td>40. <a href="https://github.com/cocos2d/cocos2d-spritebuilder" target="_blank" rel="noopener">Cocos2D-SpriteBuilder</a></td><td>一个可用于在 iOS, Mac 和 Android 上制作 2D 游戏或其它图形/交互应用的框架, 之前的项目名称为 Cocos Swift,  目前该项目在 GitHub 上更新较为频繁</td></tr><tr><td>41. <a href="https://github.com/TTTAttributedLabel/TTTAttributedLabel" target="_blank" rel="noopener">TTTAttributedLabel</a></td><td>UILabel 的替代品, 使 iOS 上的 Label 功能更加丰富, 可支持链接植入等功能</td></tr><tr><td>42. <a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="noopener">CocoaAsyncSocket</a></td><td>一个功能强大、简单易用的异步 socket 通讯类库, 支持 TCP 和 UDP 协议, 可用于 Mac 和 iOS 设备上, 作者 Robbie Hanson 是 Deusty 的首席软件工程师</td></tr><tr><td>43. <a href="https://github.com/devinross/tapkulibrary" target="_blank" rel="noopener">TapkuLibrary</a></td><td>作者是 Devin Ross, 这是在 iOS 上一款功能强大的 UI 效果类库, 可以实现多种酷炫的效果, 目前仍在更新中</td></tr><tr><td>44. <a href="https://github.com/CanvasPod/Canvas" target="_blank" rel="noopener">Canvas</a></td><td>无需编码实现牛逼的动画效果的库, 连设计师都可以快速上手</td></tr><tr><td>45. <a href="https://github.com/square/SocketRocket" target="_blank" rel="noopener">SocketRocket</a></td><td>Square 公司开源的一个 WebSocket 客户端, 稳定并且易用, 做实时应用常会用到, 受广大开发者喜爱</td></tr><tr><td>46. <a href="https://github.com/ECSlidingViewController/ECSlidingViewController" target="_blank" rel="noopener">ECSlidingViewController</a></td><td>一个视图控制器容器, 将子视图处理成两层, 通过滑动来处理层的切换, 创作灵感来自 Facebook 和 Path的 App, 作者是 Cleveland 的员工</td></tr><tr><td>47. <a href="https://github.com/stig/json-framework" target="_blank" rel="noopener">Json Framework</a></td><td>用于解析 JSON 数据的一个框架, 但是在 iOS5 以上版本大多数人都选择使用 NSJSONSerialization 来解析 JSON, 该项目现在在 GitHub 上也几乎没怎么更新了</td></tr><tr><td>48. <a href="https://github.com/facebook/Tweaks" target="_blank" rel="noopener">Tweaks</a></td><td>Facebook 开源的一款工具, 旨在帮助 iOS 开发者更快的迭代应用, 方便用户动态的调整参数, 是的, Paper 这个项目也用到了</td></tr><tr><td>49. <a href="https://github.com/realm/realm-cocoa" target="_blank" rel="noopener">realm-cocoa</a></td><td>Realm-Cocoa 是 Realm 公司推出一款移动端数据库, 可以运行在手机、平板和可穿戴设备之上, 其目标是取代 CoreData 和 SQLite 数据库</td></tr><tr><td>50. <a href="https://github.com/zwaldowski/BlocksKit" target="_blank" rel="noopener">BlocksKit</a></td><td>一个开源的与 Cocoa 紧密集合的基础性框架</td></tr><tr><td>51. <a href="https://github.com/arashpayan/appirater" target="_blank" rel="noopener">Appirater</a></td><td>一款用于提醒用户给你的 App 打分的工具</td></tr><tr><td>52. <a href="https://github.com/kif-framework/KIF" target="_blank" rel="noopener">KIF</a></td><td>Square 出品的一个开源的用户界面测试框架, 极大的简化了 iOS 开发者的 UI 测试流程</td></tr><tr><td>53. <a href="https://github.com/slackhq/SlackTextViewController" target="_blank" rel="noopener">SlackTextViewController</a></td><td>Slack 推出的一款具有文字输入框高度自适应, 自动输入, 复制单元格内容等功能的解决方案</td></tr><tr><td>54. <a href="https://github.com/IFTTT/JazzHands" target="_blank" rel="noopener">JazzHands</a></td><td>IFTTT 开源的一个简单易用的关键帧基础动画框架, 可通过手势、scroll views, KVO, ReactiveCocoa 等方式来控制动画</td></tr><tr><td>55. <a href="https://github.com/BoltsFramework/Bolts-iOS" target="_blank" rel="noopener">Bolts-iOS</a></td><td>Bolts 是一个 Parse 和 Facebook 在内部使用的底层库, 方便移动开发</td></tr><tr><td>56. <a href="https://github.com/eczarny/spectacle" target="_blank" rel="noopener">Spectacle</a></td><td>一款易用的 OS X 窗口分屏操作快捷键工具, 这是其源代码</td></tr><tr><td>57. <a href="https://github.com/tombenner/nui" target="_blank" rel="noopener">nui</a></td><td>方便样式化 iOS 应用中的 UI 元素, 可在短时间内样式化整个应用, 类 CSS 原理</td></tr><tr><td>58. <a href="https://github.com/Induction/Induction" target="_blank" rel="noopener">Induction</a></td><td>Induction 是一款用于理解数据关系的管理工具, 这是其程序代码</td></tr><tr><td>59. <a href="https://github.com/icanzilb/JSONModel" target="_blank" rel="noopener">JSONModel</a></td><td>一个能迅速解析服务器返回的 Json 数据的库, 方便数据的类型转换</td></tr><tr><td>60. <a href="https://github.com/Cocoanetics/DTCoreText" target="_blank" rel="noopener">DTCoreText</a></td><td>一个开源的 iOS 富文本组件, 它可以解析 HTML 与 CSS 并最终用 CoreText 绘制出来, 通常用于在一些需要显示富文本的场景下代替低性能的 UIWebView</td></tr><tr><td>61. <a href="https://github.com/schneiderandre/popping" target="_blank" rel="noopener">Popping</a></td><td>基于 Facebook Pop 引擎的 iOS 动画库, 集合了很多动画效果</td></tr><tr><td>62. <a href="https://github.com/KrauseFx/TSMessages" target="_blank" rel="noopener">TSMessages</a></td><td>一个用来弹出显示警告和通知的轻量级库, 样式丰富, 简单易用</td></tr><tr><td>63. <a href="https://github.com/facebook/KVOController" target="_blank" rel="noopener">KVOController</a></td><td>一个简单安全的 KVO(Key-value Observing, 键-值 观察)工具, 提供简单方便、线程安全的API, Facebook 的开源项目之一</td></tr><tr><td>64. <a href="https://github.com/mwaterfall/MWPhotoBrowser" target="_blank" rel="noopener">MWPhotoBrowser</a></td><td>一款简单的 iOS 照片浏览控件</td></tr><tr><td>65. <a href="https://github.com/mutualmobile/MMDrawerController" target="_blank" rel="noopener">MMDrawerController</a></td><td>一个轻量级, 易于使用的侧边抽屉导航 iOS 控件</td></tr><tr><td>66. <a href="https://github.com/escoz/QuickDialog" target="_blank" rel="noopener">QuickDialog</a></td><td>用于快速创建复杂的 iOS 表单, 自定义了 UITableViewCell, TableView 的样式</td></tr><tr><td>67. <a href="https://github.com/samvermette/SVPullToRefresh" target="_blank" rel="noopener">SVPullToRefresh</a></td><td>一款只需一行代码便可集成上拉刷新和下拉加载的组件</td></tr><tr><td>68. <a href="https://github.com/nothingmagical/cheddar-ios" target="_blank" rel="noopener">cheddar-ios</a></td><td>Cheddar 是一款简单易用的日程管理软件, 这是其早期版本的开源代码, 该项目已停止维护</td></tr><tr><td>69. <a href="https://github.com/XVimProject/XVim" target="_blank" rel="noopener">XVim</a></td><td>一款在 Xcode 上实现了 Vim 功能的插件</td></tr><tr><td>70. <a href="https://github.com/enormego/EGOTableViewPullRefresh" target="_blank" rel="noopener">EGOTableViewPullRefresh</a></td><td>一款提供下拉刷新的控件, 最后更新时间是一年前</td></tr><tr><td>71. <a href="https://github.com/gimenete/iOS-boilerplate" target="_blank" rel="noopener">iOS-boilerplate</a></td><td>iOS 应用程序的基础模板, 使用该模板可以省掉许多项目初始编码的工作, 内置非常多丰富的功能, 现已经停止维护</td></tr><tr><td>72. <a href="https://github.com/gotosleep/JASidePanels" target="_blank" rel="noopener">JASidePanels</a></td><td>一个 UIViewController 容器, 灵感来自 Facebook 和 Path 2.0 应用的菜单, 实现了左右侧滑的操作</td></tr><tr><td>73. <a href="https://github.com/mattt/FormatterKit" target="_blank" rel="noopener">FormatterKit</a></td><td>收集了很多构思优秀的 NSFormatter 子类</td></tr><tr><td>74. <a href="https://github.com/erichoracek/MSDynamicsDrawerViewController" target="_blank" rel="noopener">MSDynamicsDrawerViewController</a></td><td>实现了具有动态弹性效果的抽屉式侧边导航栏, 效果丰富, 可定制性强</td></tr><tr><td>75. <a href="https://github.com/boctor/idev-recipes" target="_blank" rel="noopener">idev-recipes</a></td><td>iDevRecipes 博客的代码, 演示如何实现一些有趣的控件, 该项目在两年前(2013)停止了更新</td></tr><tr><td>76. <a href="https://github.com/robbiehanson/XMPPFramework" target="_blank" rel="noopener">XMPPFramework</a></td><td>一个基于 RFC-3920 实现, 支持多线程和线程保护, 同时通用于所有的 iOS 和 Mac OS 开发设备的通信框架.</td></tr><tr><td>77. <a href="https://github.com/MacGapProject/MacGap1" target="_blank" rel="noopener">MacGap1</a></td><td>一款可以将 HTML/CSS/JS 网络应用打包成原生 Mac App 的工具</td></tr><tr><td>78. <a href="https://github.com/nicklockwood/FXBlurView" target="_blank" rel="noopener">FXBlurView</a></td><td>iOS 模糊背景类库, 可以方便的根据底层显示的状态生成模糊效果</td></tr><tr><td>79. <a href="https://github.com/shu223/iOS7-Sampler" target="_blank" rel="noopener">iOS7-Sampler</a></td><td>整合演示了多个具有 iOS7 新特性的的项目, 提供了非常多的例子参考</td></tr><tr><td>80. <a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="noopener">PromiseKit</a></td><td>提供强大的 iOS 开发异步功能, 是 Promises 的实现, 受到广大开发者的追捧</td></tr><tr><td>81. <a href="https://github.com/facebook/origami" target="_blank" rel="noopener">Origami</a></td><td>此为 Facebook 推出的 Quartz Composer 的一个开源插件, 由其设计团队花费了 9 个月打造而成, 目的是为方便设计师快速构建原型, 以零代码完成复杂动画的合成和测试, 堪称神器</td></tr><tr><td>82. <a href="https://github.com/fpillet/NSLogger" target="_blank" rel="noopener">NSLogger</a></td><td>一款强大的日志分析工具, 具有大窗口查看 Log, 自定义日志等级等功能</td></tr><tr><td>83. <a href="https://github.com/ksuther/KSImageNamed-Xcode" target="_blank" rel="noopener">KSImageNamed-Xcode</a></td><td>一款对 UIImage 的 imageNamed 提供自动补全功能的插件, 非常方便</td></tr><tr><td>84. <a href="https://github.com/smileyborg/PureLayout" target="_blank" rel="noopener">PureLayout</a></td><td>一个简单却强大的 AutoLayout API 库, 兼容了 Objective-C 和 Swift, 扩展了 UIView/NSView, NSArray, 和 NSLayoutConstraint</td></tr><tr><td>85. <a href="https://github.com/tomaz/appledoc" target="_blank" rel="noopener">AppleDoc</a></td><td>一款 Objective-C 文档生成工具, 生成的文档风格保持与 Apple 官方的一致, 极大的方便了 Xcode 识别自己写的 API 文档, 安装也是十分的简单</td></tr><tr><td>86. <a href="https://github.com/gnachman/iTerm2" target="_blank" rel="noopener">iTerm2</a></td><td>iTerm2 被不少程序员称赞为 Mac 下最好用的终端, 这是其源代码, 配合 oh-my-zsh 使用效果更佳</td></tr><tr><td>87. <a href="https://github.com/kiwi-bdd/Kiwi" target="_blank" rel="noopener">Kiwi</a></td><td>一个行为驱动开发测试框架, 适用于 iOS 平台, 旨在为开发者提供一个简单配置便可使用的 BDD 库</td></tr><tr><td>88. <a href="https://github.com/alloy/terminal-notifier" target="_blank" rel="noopener">terminal-notifier</a></td><td>一款命令行工具, 用来给 Mac OS X 用户发送通知</td></tr><tr><td>89. <a href="https://github.com/uranusjr/macdown" target="_blank" rel="noopener">MacDown</a></td><td>Mac OS X 下的一款开源的 Markdown 编辑器, 创意来自与 Mou, 使用 brew cask 即可完成安装</td></tr><tr><td>90. <a href="https://github.com/twitter/twui" target="_blank" rel="noopener">TwUI</a></td><td>Twitter 开源的一个支持硬件加速的 Mac 的 UI 框架, 最后一次的更新时间是在 3 年前(2012)</td></tr><tr><td>91. <a href="https://github.com/honcheng/PaperFold-for-iOS" target="_blank" rel="noopener">PaperFold for iOS</a></td><td>实现了类似折纸效果的视图切换, 可从不同方向进行切换, 该项目已经许久未更新</td></tr><tr><td>92. <a href="https://github.com/vfr/Reader" target="_blank" rel="noopener">Reader</a></td><td>一款开源的 iOS PDF 阅读器, 附带书签, 列纲要等功能</td></tr><tr><td>93. <a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="noopener">WebViewJavascriptBridge</a></td><td>一个方便使用 Objective-C 与 JavaScript 进行通信的第三方库, 支持消息发送, 接收, 消息处理器的注册与调用以及设置消息处理的回调</td></tr><tr><td>94. <a href="https://github.com/shu223/iOS8-Sampler" target="_blank" rel="noopener">iOS8-Sampler</a></td><td>iOSX-Sampler 系列之一, 整合演示了多个具有 iOS8 新特性的的项目, 提供了非常多的例子参考</td></tr><tr><td>95. <a href="https://github.com/robbiehanson/CocoaHTTPServer" target="_blank" rel="noopener">CocoaHTTPServer</a></td><td>一个用于 Mac OS X 或 iOS 应用的轻量级、可嵌入的HTTP 服务器框架, 方便开发者在应用中嵌入一个 HTTP 服务器</td></tr><tr><td>96. <a href="https://github.com/rsms/kod" target="_blank" rel="noopener">Kod</a></td><td>Mac OS X 上一款专为程序员打造的编辑器, 这是其开源代码, 可惜的是作者在 2011 年停止了维护</td></tr><tr><td>97. <a href="https://github.com/michaeltyson/TPKeyboardAvoiding" target="_blank" rel="noopener">TPKeyboardAvoiding</a></td><td>下拉键盘在 iOS 移动文本字段的通用解决方案, 能够自动处理键盘弹出后出现遮挡到文本输入框的问题</td></tr><tr><td>98. <a href="https://github.com/MugunthKumar/MKNetworkKit" target="_blank" rel="noopener">MKNetworkKit</a></td><td>一个轻量级网络请求框架, 完全基于 ARC, 仅有两个类, 具有自主操作多个网络请求, 更加准确的显示网络活动指标等优点</td></tr><tr><td>99. <a href="https://github.com/pkluz/PKRevealController" target="_blank" rel="noopener">PKRevealController</a></td><td>一个 iOS 平台上的视图控制器集合, 通过展现多个视图控制器来进行控制器之间的切换. 设置简单, 高度灵活</td></tr><tr><td>00. <a href="https://github.com/AlanQuatermain/AQGridView" target="_blank" rel="noopener">AQGridView</a></td><td>一个命令行工具, 通过项目里的 <code>.xcdatamodel</code> 文件, 可以为每个 entity 生成两个类, 方便 CoreData 的使用</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;转-GitHub-Top-100-简介&quot;&gt;&lt;a href=&quot;#转-GitHub-Top-100-简介&quot; class=&quot;headerlink&quot; title=&quot;(转) GitHub Top 100 简介&quot;&gt;&lt;/a&gt;(转) GitHub Top 100 简介&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="develop" scheme="http://yoursite.com/categories/develop/"/>
    
    
      <category term="develop" scheme="http://yoursite.com/tags/develop/"/>
    
  </entry>
  
  <entry>
    <title>Android ack 解决</title>
    <link href="http://yoursite.com/2018/07/11/Android-ack-%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2018/07/11/Android-ack-解决/</id>
    <published>2018-07-11T01:14:27.000Z</published>
    <updated>2018-07-11T01:15:32.754Z</updated>
    
    <content type="html"><![CDATA[<p>当adb出现如下异常时：可以考虑如下做法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\zhaohao1&gt;adb remount</span><br><span class="line">* daemon not running. starting it now on port 5037 *</span><br><span class="line">ADB server didn&apos;t ACK</span><br><span class="line">* failed to start daemon *</span><br><span class="line">error: cannot connect to daemon</span><br></pre></td></tr></table></figure></p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>方法一：<br>（1）查看任务管理器，关闭所有adb.exe,或者运行-&gt;cmd，在命令窗口输入adb kill-server<br>（2）重启eclipse即可<br>方法二, ：<br>如果方法一不行，就查看下自己电脑是否启动了如：91手机助手，360手机 豌豆荚等先把他关闭，重新连接试试，再不行就卸载这些软件应该可以解决。因为这些软件可能占用了android手机跟eclipse连接启动adb的端口<br> 方法三：<br>5037端口被占用的话，也会出现如下提示……<br>于是乎，真像是找到了救命稻草一般，先在命令行中输入如下指令，查看5037这个端口现在是被谁占用了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -a -o <span class="number">5037</span></span><br></pre></td></tr></table></figure></p><p>然后得到如下的一个结果，还真被占用了哦：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP    127.0.0.1:5037         USER-20161115XS:0      LISTENING       7608</span><br><span class="line">TCP    127.0.0.1:5037         USER-20161115XS:64426  CLOSE_WAIT      7608</span><br></pre></td></tr></table></figure></p><pre><code>C:\Users\zhaohao1&gt;netstat -ano | findstr &quot;5037&quot; TCP    127.0.0.1:5037         0.0.0.0:0              LISTENING       4436 TCP    127.0.0.1:5037         127.0.0.1:49343        TIME_WAIT       0</code></pre><p>那这个4792在我机器上，到底是个什么进程呢，好的，接着输入以下命令，把真凶找出来：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /fi <span class="string">"pid eq 4792"</span></span><br></pre></td></tr></table></figure></p><p>然后，额……我郁闷了……是存在adb进程占用端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">映像名称                       PID 会话名              会话#       内存使用</span><br><span class="line">========================= ======== ================</span><br><span class="line">adb.exe                       7608 Console                    1      9,740 K</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当adb出现如下异常时：可以考虑如下做法。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 拉起通知设置界面</title>
    <link href="http://yoursite.com/2018/07/07/Android-%E6%8B%89%E8%B5%B7%E9%80%9A%E7%9F%A5%E8%AE%BE%E7%BD%AE%E7%95%8C%E9%9D%A2/"/>
    <id>http://yoursite.com/2018/07/07/Android-拉起通知设置界面/</id>
    <published>2018-07-06T17:19:08.000Z</published>
    <updated>2018-07-06T17:28:46.589Z</updated>
    
    <content type="html"><![CDATA[<p>4.4以下并没有提过从app跳转到应用通知设置页面的Action，可考虑跳转到应用详情页面,下面是直接跳转到应用通知设置的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (android.os.Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">                   Intent intent = new Intent();</span><br><span class="line">                   intent.setAction(&quot;android.settings.APP_NOTIFICATION_SETTINGS&quot;);</span><br><span class="line">                   intent.putExtra(&quot;app_package&quot;, getActivity().getPackageName());</span><br><span class="line">                   intent.putExtra(&quot;app_uid&quot;, getActivity().getApplicationInfo().uid);</span><br><span class="line">                   startActivity(intent);</span><br><span class="line">               &#125; else if (android.os.Build.VERSION.SDK_INT == Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">                   Intent intent = new Intent();</span><br><span class="line">                   intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);</span><br><span class="line">                   intent.addCategory(Intent.CATEGORY_DEFAULT);</span><br><span class="line">                   intent.setData(Uri.parse(&quot;package:&quot; + getActivity().getPackageName()));</span><br><span class="line">                   startActivity(intent);</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure></p><p>跳转到应用详情页面的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Intent localIntent = new Intent();</span><br><span class="line">              localIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">              if (Build.VERSION.SDK_INT &gt;= 9) &#123;</span><br><span class="line">                  localIntent.setAction(&quot;android.settings.APPLICATION_DETAILS_SETTINGS&quot;);</span><br><span class="line">                  localIntent.setData(Uri.fromParts(&quot;package&quot;, getActivity().getPackageName(), null));</span><br><span class="line">              &#125; else if (Build.VERSION.SDK_INT &lt;= 8) &#123;</span><br><span class="line">                  localIntent.setAction(Intent.ACTION_VIEW);</span><br><span class="line">                  localIntent.setClassName(&quot;com.android.settings&quot;, &quot;com.android.settings.InstalledAppDetails&quot;);</span><br><span class="line">                  localIntent.putExtra(&quot;com.android.settings.ApplicationPkgName&quot;, getActivity().getPackageName());</span><br><span class="line">              &#125;</span><br><span class="line">              startActivity(localIntent);</span><br></pre></td></tr></table></figure></p><p>对于检测app是否开启通知，同样是针对4.4以上的系统才有效:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NotificationManagerCompat manager = NotificationManagerCompat.from(App.getInstance().getContext());</span><br><span class="line">boolean isOpened = manager.areNotificationsEnabled();</span><br></pre></td></tr></table></figure></p><p>4.4以下调用该方法并不会出错，只是全部返回true,默认开启状态</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;4.4以下并没有提过从app跳转到应用通知设置页面的Action，可考虑跳转到应用详情页面,下面是直接跳转到应用通知设置的代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="http://yoursite.com/2018/07/07/hello-world/"/>
    <id>http://yoursite.com/2018/07/07/hello-world/</id>
    <published>2018-07-06T17:19:08.000Z</published>
    <updated>2018-07-06T17:29:33.119Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="blogs" scheme="http://yoursite.com/tags/blogs/"/>
    
  </entry>
  
  <entry>
    <title>makedown 语法</title>
    <link href="http://yoursite.com/2018/07/05/makedown-%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2018/07/05/makedown-语法/</id>
    <published>2018-07-05T15:02:47.000Z</published>
    <updated>2018-07-06T17:30:40.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown-语法，参考CMD-Markdown"><a href="#Markdown-语法，参考CMD-Markdown" class="headerlink" title="Markdown 语法，参考CMD Markdown"></a>Markdown 语法，参考CMD Markdown</h1><hr><p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p><blockquote><ul><li>整理知识，学习笔记</li><li>发布日记，杂文，所见所想</li><li>撰写发布技术文稿（代码支持）</li><li>撰写发布学术论文（LaTeX 公式支持）</li></ul></blockquote><p><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"></p><p>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p><h3 id="Windows-Mac-Linux-全平台客户端"><a href="#Windows-Mac-Linux-全平台客户端" class="headerlink" title="Windows/Mac/Linux 全平台客户端"></a><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="noopener">Windows/Mac/Linux 全平台客户端</a></h3><blockquote><p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class="icon-file"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p></blockquote><hr><h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p><h3 id="1-制作一份待办事宜-Todo-列表"><a href="#1-制作一份待办事宜-Todo-列表" class="headerlink" title="1. 制作一份待办事宜 Todo 列表"></a>1. 制作一份待办事宜 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表" target="_blank" rel="noopener">Todo 列表</a></h3><ul><li style="list-style: none"><input type="checkbox"> 支持以 PDF 格式导出文稿</li><li style="list-style: none"><input type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li><li style="list-style: none"><input type="checkbox" checked> 新增 Todo 列表功能</li><li style="list-style: none"><input type="checkbox" checked> 修复 LaTex 公式渲染问题</li><li style="list-style: none"><input type="checkbox" checked> 新增 LaTex 公式编号功能</li></ul><h3 id="2-书写一个质能守恒公式-LaTeX"><a href="#2-书写一个质能守恒公式-LaTeX" class="headerlink" title="2. 书写一个质能守恒公式[^LaTeX]"></a>2. 书写一个质能守恒公式[^LaTeX]</h3><p>$$E=mc^2$$</p><h3 id="3-高亮一段代码-code"><a href="#3-高亮一段代码-code" class="headerlink" title="3. 高亮一段代码[^code]"></a>3. 高亮一段代码[^code]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># A comment</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure><h3 id="4-高效绘制-流程图"><a href="#4-高效绘制-流程图" class="headerlink" title="4. 高效绘制 流程图"></a>4. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图" target="_blank" rel="noopener">流程图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><h3 id="5-高效绘制-序列图"><a href="#5-高效绘制-序列图" class="headerlink" title="5. 高效绘制 序列图"></a>5. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图" target="_blank" rel="noopener">序列图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><h3 id="6-高效绘制-甘特图"><a href="#6-高效绘制-甘特图" class="headerlink" title="6. 高效绘制 甘特图"></a>6. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-甘特图" target="_blank" rel="noopener">甘特图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title 项目开发流程</span><br><span class="line">section 项目确定</span><br><span class="line">    需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">    可行性报告     :after a1, 5d</span><br><span class="line">    概念验证       : 5d</span><br><span class="line">section 项目实施</span><br><span class="line">    概要设计      :2016-07-05  , 5d</span><br><span class="line">    详细设计      :2016-07-08, 10d</span><br><span class="line">    编码          :2016-07-15, 10d</span><br><span class="line">    测试          :2016-07-22, 5d</span><br><span class="line">section 发布验收</span><br><span class="line">    发布: 2d</span><br><span class="line">    验收: 3d</span><br></pre></td></tr></table></figure><h3 id="7-绘制表格"><a href="#7-绘制表格" class="headerlink" title="7. 绘制表格"></a>7. 绘制表格</h3><table><thead><tr><th>项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td>计算机</td><td style="text-align:right">\$1600</td><td style="text-align:center">5</td></tr><tr><td>手机</td><td style="text-align:right">\$12</td><td style="text-align:center">12</td></tr><tr><td>管线</td><td style="text-align:right">\$1</td><td style="text-align:center">234</td></tr></tbody></table><h3 id="8-更详细语法说明"><a href="#8-更详细语法说明" class="headerlink" title="8. 更详细语法说明"></a>8. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考我们准备的 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown" target="_blank" rel="noopener">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册" target="_blank" rel="noopener">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p><p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p><hr><h2 id="什么是-Cmd-Markdown"><a href="#什么是-Cmd-Markdown" class="headerlink" title="什么是 Cmd Markdown"></a>什么是 Cmd Markdown</h2><p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p><h3 id="1-实时同步预览"><a href="#1-实时同步预览" class="headerlink" title="1. 实时同步预览"></a>1. 实时同步预览</h3><p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p><h3 id="2-编辑工具栏"><a href="#2-编辑工具栏" class="headerlink" title="2. 编辑工具栏"></a>2. 编辑工具栏</h3><p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p><p><img src="https://www.zybuluo.com/static/img/toolbar-editor.png" alt="tool-editor"></p><h3 id="3-编辑模式"><a href="#3-编辑模式" class="headerlink" title="3. 编辑模式"></a>3. 编辑模式</h3><p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右侧的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p><h3 id="4-实时的云端文稿"><a href="#4-实时的云端文稿" class="headerlink" title="4. 实时的云端文稿"></a>4. 实时的云端文稿</h3><p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p><h3 id="5-离线模式"><a href="#5-离线模式" class="headerlink" title="5. 离线模式"></a>5. 离线模式</h3><p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p><h3 id="6-管理工具栏"><a href="#6-管理工具栏" class="headerlink" title="6. 管理工具栏"></a>6. 管理工具栏</h3><p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p><p><img src="https://www.zybuluo.com/static/img/toolbar-manager.jpg" alt="tool-manager"></p><p>通过管理工具栏可以：</p><p><i class="icon-share"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class="icon-file"></i> 新建：开始撰写一篇新的文稿<br><i class="icon-trash"></i> 删除：删除当前的文稿<br><i class="icon-cloud"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class="icon-reorder"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class="icon-pencil"></i> 模式：切换 普通/Vim/Emacs 编辑模式</p><h3 id="7-阅读工具栏"><a href="#7-阅读工具栏" class="headerlink" title="7. 阅读工具栏"></a>7. 阅读工具栏</h3><p><img src="https://www.zybuluo.com/static/img/toolbar-reader.jpg" alt="tool-manager"></p><p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p><p>工具栏上的五个图标依次为：</p><p><i class="icon-list"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class="icon-chevron-sign-left"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class="icon-adjust"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class="icon-desktop"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class="icon-fullscreen"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p><h3 id="8-阅读模式"><a href="#8-阅读模式" class="headerlink" title="8. 阅读模式"></a>8. 阅读模式</h3><p>在 <strong>阅读工具栏</strong> 点击 <i class="icon-desktop"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p><h3 id="9-标签、分类和搜索"><a href="#9-标签、分类和搜索" class="headerlink" title="9. 标签、分类和搜索"></a>9. 标签、分类和搜索</h3><p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p><p>标签： 未分类</p><p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p><p><img src="https://www.zybuluo.com/static/img/file-list.png" alt="file-list"></p><h3 id="10-文稿发布和分享"><a href="#10-文稿发布和分享" class="headerlink" title="10. 文稿发布和分享"></a>10. 文稿发布和分享</h3><p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p><hr><p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class="icon-file"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p><p>作者 <a href="http://weibo.com/ghosert" target="_blank" rel="noopener">@ghosert</a><br>2016 年 07月 07日    </p><p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a> 参考更多使用方法。</p><p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown-语法，参考CMD-Markdown&quot;&gt;&lt;a href=&quot;#Markdown-语法，参考CMD-Markdown&quot; class=&quot;headerlink&quot; title=&quot;Markdown 语法，参考CMD Markdown&quot;&gt;&lt;/a&gt;Markdown
      
    
    </summary>
    
      <category term="blog" scheme="http://yoursite.com/categories/blog/"/>
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 入门</title>
    <link href="http://yoursite.com/2018/07/05/hexo/"/>
    <id>http://yoursite.com/2018/07/05/hexo/</id>
    <published>2018-07-05T12:29:15.000Z</published>
    <updated>2018-07-06T17:30:24.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo的下载和安装"><a href="#hexo的下载和安装" class="headerlink" title="hexo的下载和安装"></a>hexo的下载和安装</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">常用命令：</span><br><span class="line">hexo new post “博客名”  #创建</span><br><span class="line">hexo d -g  #发布</span><br><span class="line">hexo s --debug  #测试界面</span><br><span class="line"></span><br><span class="line">hexo new "postName" #新建文章</span><br><span class="line">hexo new page "pageName" #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br><span class="line"></span><br><span class="line">清除缓存的方法：</span><br><span class="line">- 执行命令：hexo clean</span><br><span class="line">- 然后可以生成静态博客并在本地预览：hexo g &amp; hexo s</span><br></pre></td></tr></table></figure><p>1、利用 npm 命令即可安装。在任意位置点击鼠标右键，选择Git Bash输入命令：npm install -g hexo<br>2、创建文件夹（我的是在E盘创建的Hexo），然后在Hexo文件下，右键运行Git Bash，输入命令：hexo init在_config.yml,进行基础配置</p><p><strong> 部分报错 </strong><br>1.找不到git部署 ERROR Deployer not found: git<br>解决方法<br>    npm install hexo-deployer-git –save<br>3.部署类型设置git<br>hexo 3.0 部署类型不再是github，_config.yml 中修改</p><h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><h2 id="Docs-http-hexo-io-docs-deployment-html"><a href="#Docs-http-hexo-io-docs-deployment-html" class="headerlink" title="Docs: http://hexo.io/docs/deployment.html"></a>Docs: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="noopener">http://hexo.io/docs/deployment.html</a></h2><p>deploy:<br>  type: git<br>  repository: git@<strong><em>.github.com:</em></strong>/***.github.io.git<br>  branch: master</p><ol start="4"><li>xcodebuild<br>xcode-select: error: tool ‘xcodebuild’ requires Xcode, but active developer directory ‘/Library/Developer/CommandLineTools’ is a command line tools instance<br>npm install bcrypt</li><li>RSS不显示<br>安装RSS插件<br>npm install hexo-generator-feed –save<br>开启RSS功能<br>编辑hexo/_config.yml，添加如下代码：</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;hexo的下载和安装&quot;&gt;&lt;a href=&quot;#hexo的下载和安装&quot; class=&quot;headerlink&quot; title=&quot;hexo的下载和安装&quot;&gt;&lt;/a&gt;hexo的下载和安装&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
      <category term="blog" scheme="http://yoursite.com/categories/blog/"/>
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>第一次使用hexo部署博客</title>
    <link href="http://yoursite.com/2018/07/05/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8hexo%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/07/05/第一次使用hexo部署博客/</id>
    <published>2018-07-05T11:48:13.000Z</published>
    <updated>2018-07-06T17:30:50.097Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是第一次使用hexo部署博客，后续将开始自发的写些文章，算是整理下之前一直没有做的事情吧~~~</p></blockquote><p>Mark： 坚持，自律，严于律己</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是第一次使用hexo部署博客，后续将开始自发的写些文章，算是整理下之前一直没有做的事情吧~~~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Mark： 坚持，自律，严于律己&lt;/p&gt;

      
    
    </summary>
    
      <category term="blog" scheme="http://yoursite.com/categories/blog/"/>
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
</feed>
